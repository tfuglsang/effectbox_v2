# **3.4 Memory access instructions**

*[Table 25](#page-0-0)* shows the memory access instructions:

**Table 25. Memory access instructions**

<span id="page-0-0"></span>

| Mnemonic    | Brief description                       | See                                      |
|-------------|-----------------------------------------|------------------------------------------|
| ADR         | Load PC-relative address                | ADR on page 70                           |
| CLREX       | Clear exclusive                         | CLREX on page 80                         |
| LDM{mode}   | Load multiple registers                 | LDM and STM on page 76                   |
| LDR{type}   | Load register using immediate offset    | LDR and STR, immediate offset on page 71 |
| LDR{type}   | Load register using register offset     | LDR and STR, register offset on page 73  |
| LDR{type}T  | Load register with unprivileged access  | LDR and STR, unprivileged on page 74     |
| LDR         | Load register using PC-relative address | LDR, PC-relative on page 75              |
| LDRD        | Load register dual                      | LDR and STR, immediate offset on page 71 |
| LDREX{type} | Load register exclusive                 | LDREX and STREX on page 79               |
| POP         | Pop registers from stack                | PUSH and POP on page 78                  |
| PUSH        | Push registers onto stack               | PUSH and POP on page 78                  |
| STM{mode}   | Store multiple registers                | LDM and STM on page 76                   |
| STR{type}   | Store register using immediate offset   | LDR and STR, immediate offset on page 71 |
| STR{type}   | Store register using register offset    | LDR and STR, register offset on page 73  |
| STR{type}T  | Store register with unprivileged access | LDR and STR, unprivileged on page 74     |
| STREX{type} | Store register exclusive                | LDREX and STREX on page 79               |

![](_page_0_Picture_6.jpeg)

PM0214 Rev 10 69/262

## <span id="page-1-0"></span>**3.4.1 ADR**

Load PC-relative address.

## **Syntax**

ADR{cond} Rd, label

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register
- '*label*' is a PC-relative expression (see *PC-relative expressions on page 65*)

### **Operation**

ADR determines the address by adding an immediate value to the PC. It writes the result to the destination register.

ADR produces position-independent code, because the address is PC-relative.

If you use ADR to generate a target address for a BX or BLX instruction, you must ensure that bit[0] of the address you generate is set to1 for correct execution.

Values of *label* must be within the range -4095 to 4095 from the address in the PC.

*Note: You might have to use the .W suffix to get the maximum offset range or to generate addresses that are not word-aligned (see Instruction width selection on page 68).*

### **Restrictions**

*Rd* must be neither SP nor PC.

## **Condition flags**

This instruction does not change the flags.

### **Examples**

ADR R1, TextMessage; write address value of a location labelled as ; TextMessage to R1

## <span id="page-2-0"></span>**3.4.2 LDR and STR, immediate offset**

Load and Store with immediate offset, pre-indexed immediate offset, or post-indexed immediate offset.

### **Syntax**

```
op{type}{cond} Rt, [Rn {, #offset}]; immediate offset
op{type}{cond} Rt, [Rn, #offset]!; pre-indexed
op{type}{cond} Rt, [Rn], #offset; post-indexed
opD{cond} Rt, Rt2, [Rn {, #offset}]; immediate offset, two words
opD{cond} Rt, Rt2, [Rn, #offset]!; pre-indexed, two words
opD{cond} Rt, Rt2, [Rn], #offset; post-indexed, two words
```

#### Where:

- '*op*' is either LDR (load register) or STR (store register)
- '*type*' is one of the following:
  - B: Unsigned byte, zero extends to 32 bits on loads
  - SB: Signed byte, sign extends to 32 bits (LDR only)
  - H: Unsigned halfword, zero extends to 32 bits on loads
  - SH: Signed halfword, sign extends to 32 bits (LDR only)
  - —: Omit, for word
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rt*' is the register to load or store
- '*Rn*' is the register on which the memory address is based
- '*offset*' is an offset from *Rn*. If *offset* is omitted, the address is the contents of *Rn*
- '*Rt2*' is the additional register to load or store for two-word operations

### **Operation**

LDR instructions load one or two registers with a value from memory. STR instructions store one or two register values to memory.

Load and store instructions with immediate offset can use the following addressing modes:

### **Offset addressing**

The offset value is added to or subtracted from the address obtained from the register *Rn*. The result is used as the address for the memory access. The register *Rn* is unaltered. The assembly language syntax for this mode is: [*Rn*, #*offset*].

### **Pre-indexed addressing**

The offset value is added to or subtracted from the address obtained from the register *Rn*. The result is used as the address for the memory access and written back into the register *Rn*. The assembly language syntax for this mode is: [*Rn*, #*offset*]!

### **Post-indexed addressing**

The address obtained from the register *Rn* is used as the address for the memory access. The offset value is added to or subtracted from the address, and written back into the register *Rn*. The assembly language syntax for this mode is: [*Rn*], #*offset.*

PM0214 Rev 10 71/262

The value to load or store can be a byte, halfword, word, or two words. Bytes and halfwords can either be signed or unsigned (see *Address alignment on page 65*).

*[Table 26](#page-3-0)* shows the range of offsets for immediate, pre-indexed and post-indexed forms.

**Table 26. Immediate, pre-indexed and post-indexed offset ranges** 

<span id="page-3-0"></span>

| Instruction type                                         | Immediate offset                            | Pre-indexed                                 | Post-indexed                                |
|----------------------------------------------------------|---------------------------------------------|---------------------------------------------|---------------------------------------------|
| Word, halfword, signed<br>halfword, byte, or signed byte | -255 to 4095                                | -255 to 255                                 | -255 to 255                                 |
| Two words                                                | Multiple of 4 in the<br>range -1020 to 1020 | Multiple of 4 in the<br>range -1020 to 1020 | Multiple of 4 in the<br>range -1020 to 1020 |

### **Restrictions**

- For load instructions:
  - *Rt* can be SP or PC for word loads only.
  - *Rt* must be different from *Rt2* for two-word loads.
  - *Rn* must be different from *Rt* and *Rt2* in the pre-indexed or post-indexed forms.
- When *Rt* is PC in a word load instruction.
  - bit[0] of the loaded value must be 1 for correct execution.
  - A branch occurs to the address created by changing bit[0] of the loaded value to 0.
  - If the instruction is conditional, it must be the last instruction in the IT block.
- For store instructions:
  - *Rt* can be SP for word stores only.
  - *Rt* must not be PC.
  - *Rn* must not be PC.
  - *Rn* must be different from *Rt* and *Rt2* in the pre-indexed or post-indexed forms

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
LDR R8, [R10] ; loads R8 from the address in R10.
LDRNE R2, [R5, #960]!; loads (conditionally) R2 from a word
                     ; 960 bytes above the address in R5, and
                     ; increments R5 by 960.
STR R2, [R9,#const-struc]; const-struc is an expression evaluating
                     ; to a constant in the range 0-4095.
STRH R3, [R4], #4; Store R3 as halfword data into address in
                     ; R4, then increment R4 by 4
LDRD R8, R9, [R3, #0x20]; Load R8 from a word 32 bytes above the
                     ; address in R3, and load R9 from a word 36
                     ; bytes above the address in R3
STRD R0, R1, [R8], #-16; Store R0 to address in R8, and store R1 to
                     ; a word 4 bytes above the address in R8, 
                     ; and then decrement R8 by 16.
```

![](_page_3_Picture_25.jpeg)

## <span id="page-4-0"></span>**3.4.3 LDR and STR, register offset**

Load and Store with register offset.

### **Syntax**

```
op{type}{cond} Rt, [Rn, Rm {, LSL #n}]
Where:
```

- '*op*' is either LDR (load register) or STR (store register).
- '*type*' is one of the following:
  - B: Unsigned byte, zero extends to 32 bits on loads.
  - SB: Signed byte, sign extends to 32 bits (LDR only).
  - H: Unsigned halfword, zero extends to 32 bits on loads.
  - SH: Signed halfword, sign extends to 32 bits (LDR only).
  - —: Omit, for word.
- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rt*' is the register to load or store.
- '*Rn*' is the register on which the memory address is based.
- '*Rm*' is a register containing a value to be used as the offset.
- '*LSL #n*' is an optional shift, with *n* in the range 0 to 3.

### **Operation**

LDR instructions load a register with a value from memory. STR instructions store a register value into memory. The memory address to load from or store to is at an offset from the register *Rn*. The offset is specified by the *Rm* register and can be shifted left by up to 3 bits using LSL. The value to load or store can be a byte, halfword, or word. For load instructions, bytes and halfwords can either be signed or unsigned (see *Address alignment on page 65*).

### **Restrictions**

In these instructions:

- *Rn* must not be PC.
- *Rm* must be neither SP nor PC.
- *Rt* can be SP only for word loads and word stores.
- *Rt* can be PC only for word loads.

When *Rt* is PC in a word load instruction:

- bit[0] of the loaded value must be 1 for correct execution, and a branch occurs to this halfword-aligned address.
- If the instruction is conditional, it must be the last instruction in the IT block.

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
STR R0, [R5, R1]; store value of R0 into an address equal to
                ; sum of R5 and R1
LDRSB R0, [R5, R1, LSL #1]; read byte value from an address equal to
                        ; sum of R5 and two times R1, sign extended it
```

PM0214 Rev 10 73/262

```
; to a word value and put it in R0
STR R0, [R1, R2, LSL #2]; stores R0 to an address equal to sum of R1
                        ; and four times R2
```

## <span id="page-5-0"></span>**3.4.4 LDR and STR, unprivileged**

Load and Store with unprivileged access.

### **Syntax**

```
op{type}T{cond} Rt, [Rn {, #offset}]; immediate offset
Where:
```

- '*op*' is either LDR (load register) or STR (store register).
- '*type*' is one of the following:
  - B: Unsigned byte, zero extends to 32 bits on loads.
    - SB: Signed byte, sign extends to 32 bits (LDR only).
    - H: Unsigned halfword, zero extends to 32 bits on loads.
    - SH: Signed halfword, sign extends to 32 bits (LDR only).
    - —: Omit, for word.
- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rt*' is the register to load or store.
- '*Rn*' is the register on which the memory address is based.
- '*offset*' is an offset from *Rn* and can be 0 to 255. If *offset* is omitted, the address is the value in *Rn*.

### **Operation**

These load and store instructions perform the same function as the memory access instructions with immediate offset (see *[LDR and STR, immediate offset on page 71](#page-2-0)*). The difference is that these instructions have only unprivileged access even when used in privileged software.

When used in unprivileged software, these instructions behave in exactly the same way as normal memory access instructions with immediate offset.

## **Restrictions**

In these instructions:

- *Rn* must not be PC.
- *Rt* must be neither SP nor PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
STRBTEQ R4, [R7] ; conditionally store least significant byte in
                  ; R4 to an address in R7, with unprivileged access
LDRHT R2, [R2, #8]; load halfword value from an address equal to
             ; sum of R2 and 8 into R2, with unprivileged access
```

![](_page_5_Picture_30.jpeg)

## <span id="page-6-0"></span>**3.4.5 LDR, PC-relative**

Load register from memory.

## **Syntax**

```
LDR{type}{cond} Rt, label
LDRD{cond} Rt, Rt2, label; load two words
```

#### Where:

- '*type*' is one of the following:
  - B: Unsigned byte, zero extends to 32 bits.
  - SB: Signed byte, sign extends to 32 bits.
  - H: Unsigned halfword, sign extends to 32 bits.
  - SH: Signed halfword, sign extends to 32 bits.
  - —: Omit, for word.
- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rt*' is the register to load or store.
- '*Rt2*' is the second register to load or store.
- '*label'* is a PC-relative expression, see *PC-relative expressions on page 65*.

### **Operation**

LDR loads a register with a value from a PC-relative memory address.

The memory address is specified by a label or by an offset from the PC.

The value to load or store can be a byte, halfword, or word. For load instructions, bytes and halfwords can either be signed or unsigned (see *Address alignment on page 65*).

*'label'* must be within a limited range of the current instruction. *[Table 27](#page-6-1)* shows the possible offsets between *label* and the PC. You might have to use the .W suffix to get the maximum offset range (see *Instruction width selection on page 68*).

**Table 27.** *label***-PC offset ranges** 

<span id="page-6-1"></span>

| Instruction type                                   | Offset range  |
|----------------------------------------------------|---------------|
| Word, halfword, signed halfword, byte, signed byte | −4095 to 4095 |
| Two words                                          | −1020 to 1020 |

### **Restrictions**

In these instructions:

- *Rt2* must be neither SP nor PC
- *Rt* must be different from *Rt2*
- *Rt* can be SP or PC only for word loads
- When *Rt* is PC in a word load instruction: bit[0] of the loaded value must be 1 for correct execution, and a branch occurs to this halfword-aligned address. If the instruction is conditional, it must be the last instruction in the IT block.

![](_page_6_Picture_30.jpeg)

PM0214 Rev 10 75/262

## **Condition flags**

These instructions do not change the flags.

## **Examples**

```
LDR R0, LookUpTable; load R0 with a word of data from an address
                     ; labelled as LookUpTable
LDRSB R7, localdata; load a byte value from an address labelled
                     ; as localdata, sign extend it to a word
                     ; value, and put it in R7
```

## <span id="page-7-0"></span>**3.4.6 LDM and STM**

Load and Store Multiple registers.

### **Syntax**

```
op{addr_mode}{cond} Rn{!}, reglist
```

#### Where:

- '*op*' is either LDM (load multiple register) or STM (store multiple register).
- '*addr\_mode*' is any of the following:
  - IA: Increment address after each access (this is the default).
  - DB: Decrement address before each access.
- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rn*' is the register on which the memory addresses are based.
- '*!*' is an optional writeback suffix. If ! is present, the final address that is loaded from or stored to is written back into *Rn*.
- '*reglist*' is a list of one or more registers to be loaded or stored, enclosed in braces. It can contain register ranges. It must be comma-separated if it contains more than one register or register range, see *[Examples on page 77](#page-8-0)*.

LDM and LDMFD are synonyms for LDMIA. LDMFD refers to its use for popping data from full descending stacks.

LDMEA is a synonym for LDMDB, and refers to its use for popping data from empty ascending stacks.

STM and STMEA are synonyms for STMIA. STMEA refers to its use for pushing data onto empty ascending stacks.

STMFD is s synonym for STMDB, and refers to its use for pushing data onto full descending stacks

### **Operation**

LDM instructions load the registers in *reglist* with word values from memory addresses based on *Rn*.

STM instructions store the word values in the registers in *reglist* to memory addresses based on *Rn*.

For LDM, LDMIA, LDMFD, STM, STMIA, and STMEA the memory addresses used for the accesses are at 4-byte intervals ranging from *Rn* to *Rn* + 4 \* (*n*-1), where *n* is the number of registers in *reglist*. The accesses happen in order of increasing register numbers, with the

![](_page_7_Picture_28.jpeg)

lowest numbered register using the lowest memory address and the highest number register using the highest memory address. If the writeback suffix is specified, the value of *Rn* + 4 \* (*n*-1) is written back to *Rn*.

For LDMDB, LDMEA, STMDB, and STMFD the memory addresses used for the accesses are at 4-byte intervals ranging from *Rn* to *Rn* - 4 \* (*n*-1), where *n* is the number of registers in *reglist*. The accesses happen in order of decreasing register numbers, with the highest numbered register using the highest memory address and the lowest number register using the lowest memory address. If the writeback suffix is specified, the value *Rn* - 4 \* (*n*) is written back to *Rn*.

The PUSH and POP instructions can be expressed in this form (see *[PUSH and POP](#page-9-0)* for details).

### **Restrictions**

In these instructions:

- *Rn* must not be PC.
- *reglist* must not contain SP.
- In any STM instruction, *reglist* must not contain PC.
- In any LDM instruction, *reglist* must not contain PC if it contains LR.
- *reglist* must not contain *Rn* if you specify the writeback suffix.

When PC is in *reglist* in an LDM instruction:

- bit[0] of the value loaded to the PC must be 1 for correct execution, and a branch occurs to this halfword-aligned address.
- If the instruction is conditional, it must be the last instruction in the IT block.

### **Condition flags**

These instructions do not change the flags.

### <span id="page-8-0"></span>**Examples**

```
LDM R8,{R0,R2,R9} ; LDMIA is a synonym for LDM
STMDB R1!,{R3-R6,R11,R12}
```

## **Incorrect examples**

```
STM R5!,{R5,R4,R9} ; value stored for R5 is unpredictable 
LDM R2, {} ; there must be at least one register in the list
```

PM0214 Rev 10 77/262

## <span id="page-9-0"></span>**3.4.7 PUSH and POP**

Push registers onto, and pop registers off a full-descending stack. PUSH and POP are synonyms for STMDB and LDM (or LDMIA) with the memory addresses for the access based on SP, and with the final address for the access written back to the SP. PUSH and POP are the preferred mnemonics in these cases.

### **Syntax**

```
PUSH{cond} reglist
POP{cond} reglist
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*reglist*' is a non-empty list of registers (or register ranges), enclosed in braces. Commas must separate register lists or ranges (see *[Examples on page 77](#page-8-0)*).

### **Operation**

- PUSH stores registers on the stack in order of decreasing register numbers, with the highest numbered register using the highest memory address and the lowest numbered register using the lowest memory address.
- POP loads registers from the stack in order of increasing register numbers, with the lowest numbered register using the lowest memory address and the highest numbered register using the highest memory address.
- PUSH uses the value in the SP register minus four as the highest memory address, POP uses the SP register value as the lowest memory address, implementing a fulldescending stack. On completion, PUSH updates the SP register to point to the location of the lowest store value, and POP updates the SP register to point to the location above the highest location loaded.
- If a POP instruction includes PC in its reglist, a branch to this location is performed when the POP instruction has completed. Bit[0] of the value read for the PC is used to update the APSR T-bit. This bit must be 1 to ensure correct operation. See *[LDM and](#page-7-0)  [STM on page 76](#page-7-0)* for more information.

### **Restrictions**

In these instructions:

- *'reglist'* must not contain SP.
- For the PUSH instruction, *reglist* must not contain PC.
- For the POP instruction, *reglist* must not contain PC if it contains LR. When PC is in *reglist* in a POP instruction: bit[0] of the value loaded to the PC must be 1 for correct execution, and a branch occurs to this halfword-aligned address. If the instruction is conditional, it must be the last instruction in the IT block.

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
PUSH {R0,R4-R7} ; Push R0,R4,R5,R6,R7 onto the stack
PUSH {R2,LR} ; Push R2 and the link-register onto the stack
POP {R0,R6,PC} ; Pop r0,r6 and PC from the stack, then branch to new PC.
```

![](_page_9_Picture_24.jpeg)

## <span id="page-10-0"></span>**3.4.8 LDREX and STREX**

Load and Store Register Exclusive.

## **Syntax**

```
LDREX{cond} Rt, [Rn {, #offset}]
STREX{cond} Rd, Rt, [Rn {, #offset}]
LDREXB{cond} Rt, [Rn]
STREXB{cond} Rd, Rt, [Rn]
LDREXH{cond} Rt, [Rn]
STREXH{cond} Rd, Rt, [Rn]
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register for the returned status.
- '*Rt*' is the register to load or store.
- '*Rn*' is the register on which the memory address is based.
- '*offset*' is an optional offset applied to the value in *Rn*. If *offset* is omitted, the address is the value in *Rn*.

### **Operation**

LDREX, LDREXB, and LDREXH load a word, byte, and halfword respectively from a memory address.

STREX, STREXB, and STREXH attempt to store a word, byte, and halfword respectively to a memory address. The address used in any store-exclusive instruction must be the same as the address in the most recently executed load-exclusive instruction. The value stored by the store-exclusive instruction must also have the same data size as the value loaded by the preceding load-exclusive instruction. This means software must always use a loadexclusive instruction and a matching store-exclusive instruction to perform a synchronization operation, see *Synchronization primitives on page 34*.

If a store-exclusive instruction performs the store, it writes 0 to its destination register. If it does not perform the store, it writes 1 to its destination register.

If the store-exclusive instruction writes 0 to the destination register, it is guaranteed that no other process in the system has accessed the memory location between the load-exclusive and store-exclusive instructions.

For reasons of performance, keep the number of instructions between corresponding loadexclusive and store-exclusive instruction to a minimum.

*Note: The result of executing a store-exclusive instruction to an address that is different from that used in the preceding load-exclusive instruction is unpredictable.*

![](_page_10_Picture_20.jpeg)

PM0214 Rev 10 79/262

### **Restrictions**

In these instructions:

- Do not use PC.
- Do not use SP for *Rd* and *Rt.*
- For STREX, *Rd* must be different from both *Rt* and *Rn.*
- The value of offset must be a multiple of four in the range 0-1020.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
MOV R1, #0x1 ; initialize the 'lock taken' value try
LDREX R0, [LockAddr] ; load the lock value
CMP R0, #0 ; is the lock free?
ITT EQ ; IT instruction for STREXEQ and CMPEQ
STREXEQ R0, R1, [LockAddr] ; try and claim the lock
CMPEQ R0, #0 ; did this succeed?
BNE try ; no – try again
                      ; yes – we have the lock
```

## <span id="page-11-0"></span>**3.4.9 CLREX**

Clear Exclusive.

### **Syntax**

```
CLREX{cond}
```

Where:

'*cond*' is an optional condition code (see *Conditional execution on page 65*)

### **Operation**

Use CLREX to make the next STREX, STREXB, or STREXH instruction write 1 to its destination register and fail to perform the store. It is useful in exception handler code to force the failure of the store exclusive if the exception occurs between a load exclusive instruction and the matching store exclusive instruction in a synchronization operation.

See *Synchronization primitives on page 34* for more information.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

CLREX

![](_page_11_Picture_26.jpeg)