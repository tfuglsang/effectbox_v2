## 2.4.3 Fault status registers and fault address registers

The fault status registers indicate the cause of a fault. For bus faults and memory management faults, the fault address register indicates the address accessed by the operation that caused the fault, as shown in *Table 20*.

<span id="page-0-0"></span>

| Handler                 | Status register name | Address register name | Register description                                                      |
|-------------------------|----------------------|-----------------------|---------------------------------------------------------------------------|
| Hard fault              | HFSR                 | -                     | Hard fault status register (HFSR) on page 241                             |
| Memory management fault | MMFSR                | MMFAR                 | Memory management fault address register (MMFAR) on page 242              |
| Bus fault               | BFSR                 | BFAR                  | Bus fault address register (BFAR) on page 242                             |
| Usage fault             | UFSR                 | -                     | Configurable fault status register (CFSR;<br>UFSR+BFSR+MMFSR) on page 237 |

Table 20. Fault status and fault address registers

## 2.4.4 Lockup

The processor enters a lockup state if a hard fault occurs when executing the NMI or hard fault handlers. When the processor is in lockup state it does not execute any instructions. The processor remains in lockup state until either:

- It is reset
- An NMI occurs
- It is halted by a debugger

If lockup state occurs from the NMI handler a subsequent NMI does not cause the processor to leave lockup state.

# 2.5 Power management

The STM32 and Cortex-M4 processor sleep modes reduce power consumption:

- Sleep mode stops the processor clock. All other system and peripheral clocks may still be running.
- Deep sleep mode stops most of the STM32 system and peripheral clocks. At product level, this corresponds to either the Stop or the Standby mode. For more details, please refer to the "Power modes" Section in the STM32 reference manual.

The SLEEPDEEP bit of the SCR selects which sleep mode is used, as described in *System control register (SCR) on page 230*. For more information about the behavior of the sleep modes see the STM32 product reference manual.

This section describes the mechanisms for entering sleep mode, and the conditions for waking up from sleep mode.

![](_page_0_Picture_18.jpeg)

PM0214 Rev 10 47/262

## **2.5.1 Entering sleep mode**

This section describes the mechanisms software can use to put the processor into sleep mode.

The system can generate spurious wakeup events, for example a debug operation that wakes up the processor. Therefore software must be able to put the processor back into sleep mode after such an event. A program might have an idle loop to put the processor back to sleep mode.

#### **Wait for interrupt**

The *wait for interrupt* instruction, WFI, causes immediate entry to sleep mode (unless the wake-up condition is true, as shown in *[Wakeup from WFI or sleep-on-exit on page 48](#page-1-0)*). When the processor executes a WFI instruction, it stops executing instructions and enters sleep mode. See *WFI on page 192* for more information.

#### <span id="page-1-1"></span>**Wait for event**

The *wait for event* instruction, WFE, causes entry to sleep mode depending on the value of a one-bit event register. When the processor executes a WFE instruction, it checks the value of the event register:

- 0: the processor stops executing instructions and enters sleep mode
- 1: the processor clears the register to 0 and continues executing instructions without entering sleep mode.

See *WFE on page 191* for more information.

If the event register is 1, this indicates that the processor must not enter sleep mode on execution of a WFE instruction. Typically, this is because an external event signal is asserted, or a processor in the system has executed an SEV instruction, as shown in *SEV on page 189*. Software cannot access this register directly.

#### **Sleep-on-exit**

If the SLEEPONEXIT bit of the SCR is set to 1, when the processor completes the execution of an exception handler, it returns to Thread mode and immediately enters sleep mode. Use this mechanism in applications that only require the processor to run when an exception occurs.

## **2.5.2 Wakeup from sleep mode**

The conditions for the processor to wakeup depend on the mechanism that caused it to enter sleep mode.

### <span id="page-1-0"></span>**Wakeup from WFI or sleep-on-exit**

Normally, the processor wakes up only when it detects an exception with sufficient priority to cause exception entry.

Some embedded systems might have to execute system restore tasks after the processor wakes up, and before it executes an interrupt handler. To achieve this set the PRIMASK bit to 1 and the FAULTMASK bit to 0. If an interrupt arrives that is enabled and has a higher priority than current exception priority, the processor wakes up but does not execute the interrupt handler until the processor sets PRIMASK to zero. For more information about PRIMASK and FAULTMASK see *Exception mask registers on page 23*.

48/262 PM0214 Rev 10

![](_page_1_Picture_21.jpeg)

#### **Wakeup from WFE**

The processor wakes up if:

- it detects an exception with sufficient priority to cause exception entry
- it detects an external event signal, see *[Section 2.5.3: External event input / extended](#page-2-0)  [interrupt and event input](#page-2-0)*
- in a multiprocessor system, another processor in the system executes an SEV instruction.

In addition, if the SEVONPEND bit in the SCR is set to 1, any new pending interrupt triggers an event and wakes up the processor, even if the interrupt is disabled or has insufficient priority to cause exception entry. For more information about the SCR see *System control register (SCR) on page 230*.

# <span id="page-2-0"></span>**2.5.3 External event input / extended interrupt and event input**

The processor provides an external event input signal.

This signal is generated by the External or Extended Interrupt/event Controller (EXTI) on asynchronous event detection (from external input pins or asynchronous peripheral event).

This signal can wakeup the processor from WFE, or set the internal WFE event register to one to indicate that the processor must not enter sleep mode on a later WFE instruction, as described in *[Wait for event on page 48](#page-1-1)*. Fore more details please refer to the STM32 reference manual, Low power modes section.

## **2.5.4 Power management programming hints**

ISO/IEC C cannot directly generate the WFI and WFE instructions. The CMSIS provides the following functions for these instructions:

```
void __WFE(void) // Wait for Event
void __WFI(void) // Wait for Interrupt
```

![](_page_2_Picture_15.jpeg)

PM0214 Rev 10 49/262