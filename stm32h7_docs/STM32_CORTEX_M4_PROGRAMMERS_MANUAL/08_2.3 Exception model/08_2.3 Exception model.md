# **2.3 Exception model**

This section describes the exception model.

# **2.3.1 Exception states**

Each exception is in one of the following states:

**Inactive** The exception is not active and not pending.

**Pending** The exception is waiting to be serviced by the processor. An interrupt

request from a peripheral or from software can change the state of the

corresponding interrupt to pending.

**Active** An exception that is being serviced by the processor but has not

completed.

*Note: An exception handler can interrupt the execution of another exception* 

*handler. In this case both exceptions are in the active state.*

**Active and pending**The exception is being serviced by the processor and there is a

pending exception from the same source.

### **2.3.2 Exception types**

The exception types are:

**Reset** Reset is invoked on power up or a warm reset. The exception model treats reset as a special form of exception. When reset is asserted, the operation of the processor stops, potentially at any point in an instruction. When reset is deasserted, execution restarts from the address provided by the reset entry in the vector table. Execution

restarts as privileged execution in Thread mode.

**NMI** A *NonMaskable Interrupt* (NMI) can be signalled by a peripheral or

triggered by software. This is the highest priority exception other than reset. It is permanently enabled and has a fixed priority of -2. NMIs

cannot be:

• Masked or prevented from activation by any other exception

• Preempted by any exception other than Reset.

**Hard fault** A hard fault is an exception that occurs because of an error during

exception processing, or because an exception cannot be managed by any other exception mechanism. Hard faults have a fixed priority of -1, meaning they have higher priority than any exception with configurable

priority.

**Memory management fault** A memory management fault is an exception that occurs because of a memory protection related fault. The MPU or the fixed memory protection constraints determines this fault, for both instruction and data memory transactions. This fault is used to abort instruction

accesses to *Execute Never* (XN) memory regions.

![](_page_0_Picture_32.jpeg)

PM0214 Rev 10 37/262

**Bus fault** 

A bus fault is an exception that occurs because of a memory related fault for an instruction or data memory transaction. This might be from an error detected on a bus in the memory system.

#### **Usage fault**

A usage fault is an exception that occurs in case of an instruction execution fault. This includes:

- An undefined instruction
- An illegal unaligned access
- Invalid state on instruction execution
- An error on exception return.

The following can cause a usage fault when the core is configured to report it:

- An unaligned address on word and halfword memory access
- Division by zero

**SVCall** A *supervisor call* (SVC) is an exception that is triggered by the SVC

instruction. In an OS environment, applications can use SVC instructions to access OS kernel functions and device drivers.

**PendSV** PendSV is an interrupt-driven request for system-level service. In an

OS environment, use PendSV for context switching when no other

exception is active.

**SysTick** A SysTick exception is an exception the system timer generates when

it reaches zero. Software can also generate a SysTick exception. In an OS environment, the processor can use this exception as system tick.

**Interrupt (IRQ)** An interrupt, or IRQ, is an exception signalled by a peripheral, or

generated by a software request. All interrupts are asynchronous to instruction execution. In the system, peripherals use interrupts to

communicate with the processor.

Table 17. Properties of the different exception types

<span id="page-1-0"></span>

| Exception number <sup>(1)</sup> | IRQ<br>number <sup>(1)</sup> | Exception type          | Priority         | Vector address<br>or offset <sup>(2)</sup> | Activation                                           |  |
|---------------------------------|------------------------------|-------------------------|------------------|--------------------------------------------|------------------------------------------------------|--|
| 1                               | -                            | Reset                   | -3, the highest  | 0x00000004                                 | Asynchronous                                         |  |
| 2                               | -14                          | NMI                     | -2               | 0x00000008                                 | Asynchronous                                         |  |
| 3                               | -13                          | Hard fault              | -1               | 0x000000C                                  | -                                                    |  |
| 4                               | -12                          | Memory management fault | Configurable (3) | 0x0000010                                  | Synchronous                                          |  |
| 5                               | -11                          | Bus fault               | Configurable (3) | 0x00000014                                 | Synchronous when precise Asynchronous when imprecise |  |
| 6                               | -10                          | Usage fault             | Configurable (3) | 0x00000018                                 | Synchronous                                          |  |
| 7-10                            | -                            | -                       | -                | Reserved                                   | -                                                    |  |
| 11                              | -5                           | SVCall                  | Configurable (3) | 0x0000002C                                 | Synchronous                                          |  |
| 12-13                           | -                            | -                       | -                | Reserved                                   | -                                                    |  |
| 14                              | -2                           | PendSV                  | Configurable (3) | 0x00000038                                 | Asynchronous                                         |  |

![](_page_1_Picture_25.jpeg)

![](_page_1_Picture_26.jpeg)

| Exception number <sup>(1)</sup> | IRQ<br>number <sup>(1)</sup> | Exception type  | Priority                    | Vector address<br>or offset <sup>(2)</sup> | Activation   |
|---------------------------------|------------------------------|-----------------|-----------------------------|--------------------------------------------|--------------|
| 15                              | -1                           | SysTick         | Configurable (3)            | 0x0000003C                                 | Asynchronous |
| 16 and above                    | 0 and<br>above               | Interrupt (IRQ) | Configurable <sup>(4)</sup> | 0x00000040 and above <sup>(5)</sup>        | Asynchronous |

Table 17. Properties of the different exception types (continued)

- To simplify the software layer, the CMSIS only uses IRQ numbers and therefore uses negative values for exceptions other than interrupts. The IPSR returns the Exception number. For further information see *Interrupt program status register on* page 22.
- 2. See Vector table on page 40 for more information.
- 3. See System handler priority registers (SHPRx) on page 233.
- 4. See Interrupt priority register x (NVIC\_IPRx) on page 215.
- 5. Increasing in steps of 4.

For an asynchronous exception other than reset, the processor can execute another instruction between when the exception is triggered and when the processor enters the exception handler.

Privileged software can disable the exceptions that *Table 17 on page 38* shows as having configurable priority. For further information, see:

- System handler control and state register (SHCSR) on page 235
- Interrupt clear-enable register x (NVIC\_ICERx) on page 211

For more information about hard faults, memory management faults, bus faults, and usage faults, see *Section 2.4: Fault handling on page 44*.

### 2.3.3 Exception handlers

The processor handles exceptions using:

Interrupt Service Interrupts IRQ0 to IRQ81 are the exceptions handled by ISRs. Routines (ISRs)

Fault handlers Hard fault, memory management fault, usage fault, bus fault are fault

exceptions handled by the fault handlers.

System handlers NMI, PendSV, SVCall SysTick, and the fault exceptions are all

system exceptions that are handled by system handlers.

![](_page_2_Picture_21.jpeg)

PM0214 Rev 10 39/262

# <span id="page-3-0"></span>**2.3.4 Vector table**

The vector table contains the reset value of the stack pointer, and the start addresses, also called exception vectors, for all exception handlers. *[Figure 11 on page 40](#page-3-1)* shows the order of the exception vectors in the vector table. The least-significant bit of each vector must be 1, indicating that the exception handler is Thumb code.

**Figure 11. Vector table**

<span id="page-3-1"></span>

| Figure 11. Vector table |            |                                                          |                         |           |  |  |  |  |  |
|-------------------------|------------|----------------------------------------------------------|-------------------------|-----------|--|--|--|--|--|
| Exception number        | IRQ number | Offset                                                   | Vector                  |           |  |  |  |  |  |
| 255                     | 239        | 0x03FC                                                   | IRQ239                  |           |  |  |  |  |  |
|                         | •          |                                                          |                         |           |  |  |  |  |  |
| i i                     |            |                                                          |                         |           |  |  |  |  |  |
| 18                      | 2          | 0x004C<br>0x0048<br>0x0044                               | IRQ2                    |           |  |  |  |  |  |
| 17                      | 1          |                                                          | IRQ1                    |           |  |  |  |  |  |
| 16                      | 0          | 0x0044                                                   | IRQ0                    |           |  |  |  |  |  |
| 15                      | -1         | 0x003C                                                   | Systick                 |           |  |  |  |  |  |
| 14                      | -2         | 0x0038                                                   | PendSV                  |           |  |  |  |  |  |
| 13                      |            | 0,0000                                                   | Reserved                |           |  |  |  |  |  |
| 12                      |            | -5<br>0x002C                                             | Reserved for Debug      |           |  |  |  |  |  |
| 11                      | -5         |                                                          | SVCall                  |           |  |  |  |  |  |
| 10                      |            | 0,0020                                                   |                         |           |  |  |  |  |  |
| 9                       |            |                                                          | Reserved                |           |  |  |  |  |  |
| 8                       |            |                                                          |                         |           |  |  |  |  |  |
| 7                       |            |                                                          |                         |           |  |  |  |  |  |
| 6                       | -10        | 0x0018<br>0x0014<br>0x0010<br>0x000C<br>0x0008<br>0x0004 | Usage fault             |           |  |  |  |  |  |
| 5                       | -11        |                                                          | Bus fault               |           |  |  |  |  |  |
| 4                       | -12<br>-13 |                                                          | Memory management fault |           |  |  |  |  |  |
| 3                       |            |                                                          | Hard fault              |           |  |  |  |  |  |
| 2                       | -14        |                                                          | NMI                     |           |  |  |  |  |  |
| 1                       |            |                                                          | Reset                   |           |  |  |  |  |  |
|                         |            | 0x0004                                                   | Initial SP value        |           |  |  |  |  |  |
|                         |            |                                                          | N                       | 1S30018V1 |  |  |  |  |  |

On system reset, the vector table is fixed at address 0x00000000. Privileged software can write to the VTOR to relocate the vector table start address to a different memory location, in the range 0x00000080 to 0x3FFFFF80. For further information see *Vector table offset register (VTOR) on page 227*.

40/262 PM0214 Rev 10

![](_page_3_Picture_8.jpeg)

### **2.3.5 Exception priorities**

*[Table 17 on page 38](#page-1-0)* shows that all exceptions have an associated priority, in details:

- A lower priority value indicating a higher priority
- Configurable priorities for all exceptions except Reset, Hard fault, and NMI.

If software does not configure any priorities, then all exceptions with a configurable priority have a priority of 0. For information about configuring exception priorities see

- *System handler priority registers (SHPRx) on page 233*
- *Interrupt priority register x (NVIC\_IPRx) on page 215*

Configurable priority values are in the range 0-15. This means that the Reset, Hard fault, and NMI exceptions, with fixed negative priority values, always have higher priority than any other exception.

For example, assigning a higher priority value to IRQ[0] and a lower priority value to IRQ[1] means that IRQ[1] has higher priority than IRQ[0]. If both IRQ[1] and IRQ[0] are asserted, IRQ[1] is processed before IRQ[0].

If multiple pending exceptions have the same priority, the pending exception with the lowest exception number takes precedence. For example, if both IRQ[0] and IRQ[1] are pending and have the same priority, then IRQ[0] is processed before IRQ[1].

When the processor is executing an exception handler, the exception handler is preempted if a higher priority exception occurs. If an exception occurs with the same priority as the exception being handled, the handler is not preempted, irrespective of the exception number. However, the status of the new interrupt changes to pending.

### <span id="page-4-0"></span>**2.3.6 Interrupt priority grouping**

To increase priority control in systems with interrupts, the NVIC supports priority grouping. This divides each interrupt priority register entry into two fields:

- An upper field that defines the *group priority*
- A lower field that defines a *subpriority* within the group.

Only the group priority determines preemption of interrupt exceptions. When the processor is executing an interrupt exception handler, another interrupt with the same group priority as the interrupt being handled does not preempt the handler,

If multiple pending interrupts have the same group priority, the subpriority field determines the order in which they are processed. If multiple pending interrupts have the same group priority and subpriority, the interrupt with the lowest IRQ number is processed first.

For information about splitting the interrupt priority fields into group priority and subpriority, see *Application interrupt and reset control register (AIRCR) on page 228*.

![](_page_4_Picture_20.jpeg)

PM0214 Rev 10 41/262

### **2.3.7 Exception entry and return**

Descriptions of exception handling use the following terms:

**Preemption** When the processor is executing an exception handler, an exception can preempt the exception handler if its priority is higher than the priority of the exception being handled. See *[Section 2.3.6: Interrupt priority grouping](#page-4-0)* for more information about preemption by an interrupt.

> When one exception preempts another, the exceptions are called nested exceptions. See *[Exception entry on page 42](#page-5-0)* more information.

**Return** This occurs when the exception handler is completed, and:

- There is no pending exception with sufficient priority to be serviced
- The completed exception handler was not handling a late-arriving exception.

The processor pops the stack and restores the processor state to the state it had before the interrupt occurred. See *Exception return on page 44* for more information.

**Tail-chaining** This mechanism speeds up exception servicing. On completion of an exception handler, if there is a pending exception that meets the requirements for exception entry, the stack pop is skipped and control transfers to the new exception handler.

**Late-arriving** This mechanism speeds up preemption. If a higher priority exception occurs during state saving for a previous exception, the processor switches to handle the higher priority exception and initiates the vector fetch for that exception. State saving is not affected by late arrival because the state saved is the same for both exceptions. Therefore the state saving continues uninterrupted. The processor can accept a late arriving exception until the first instruction of the exception handler of the original exception enters the execute stage of the processor. On return from the exception handler of the late-arriving exception, the normal tail-chaining rules apply.

#### <span id="page-5-0"></span>**Exception entry**

Exception entry occurs when there is a pending exception with sufficient priority and either:

- The processor is in Thread mode
- The new exception is of higher priority than the exception being handled, in which case the new exception preempts the original exception.

When one exception preempts another, the exceptions are nested.

Sufficient priority means the exception has more priority than any limits set by the mask registers. For more information see *Exception mask registers on page 23*. An exception with less priority than this is pending but is not handled by the processor.

When the processor takes an exception, unless the exception is a tail-chained or a latearriving exception, the processor pushes information onto the current stack. This operation is referred as *stacking* and the structure of eight data words is referred as *stack frame*.

When using floating-point routines, the Cortex-M4 processor automatically stacks the architected floating-point state on exception entry. *[Figure 12 on page 43](#page-6-0)* shows the Cortex-M4 stack frame layout when floating-point state is preserved on the stack as the result of an interrupt or an exception. Where stack space for floating-point state is not allocated, the

42/262 PM0214 Rev 10

![](_page_5_Picture_25.jpeg)

stack frame is the same as that of Armv7-M implementations without an FPU. *[Figure 12 on](#page-6-0)  [page 43](#page-6-0)* also shows this stack frame.

<span id="page-6-0"></span>Pre-IRQ top of stack *x*PSR PC LR R12 R3 R2 R1 R0 {aligner} IRQ top of stack Decreasing memory address *x*PSR PC LR R12 R3 R2 R1 R0 S7 S6 S5 S4 S3 S2 S1 S0 S9 S8 FPSCR S15 S14 S13 S12 S11 S10 {aligner} IRQ top of stack ... Exception frame with floating-point storage Exception frame without floating-point storage Pre-IRQ top of stack ... MS30019V1

**Figure 12. Cortex-M4 stack frame layout**

Immediately after stacking, the stack pointer indicates the lowest address in the stack frame. The alignment of the stack frame is controlled via the STKALIGN bit of the Configuration Control Register (CCR).

The stack frame includes the return address. This is the address of the next instruction in the interrupted program. This value is restored to the PC at exception return so that the interrupted program resumes.

In parallel to the stacking operation, the processor performs a vector fetch that reads the exception handler start address from the vector table. When stacking is complete, the processor starts executing the exception handler. At the same time, the processor writes an EXC\_RETURN value to the LR. This indicates which stack pointer corresponds to the stack frame and what operation mode the was processor was in before the entry occurred.

If no higher priority exception occurs during exception entry, the processor starts executing the exception handler and automatically changes the status of the corresponding pending interrupt to active.

If another higher priority exception occurs during exception entry, the processor starts executing the exception handler for this exception and does not change the pending status of the earlier exception. This is the late arrival case.

![](_page_6_Picture_10.jpeg)

PM0214 Rev 10 43/262