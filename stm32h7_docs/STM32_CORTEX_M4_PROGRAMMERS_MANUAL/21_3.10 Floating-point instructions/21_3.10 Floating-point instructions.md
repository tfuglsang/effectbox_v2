# **3.10 Floating-point instructions**

These instructions are only available if the FPU is included, and enabled, in the system. See *Enabling the FPU on page 257* for information about enabling the floating-point unit.

**Table 35. Floating-point instructions**

| Mnemonic | Brief description                                                                                             | See                                                                |
|----------|---------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|
| VABS     | Floating-point Absolute                                                                                       | VABS on page 151                                                   |
| VADD     | Floating-point Add                                                                                            | VADD on page 152                                                   |
| VCMP     | Compare two floating-point registers, or one floating<br>point register and zero                              | VCMP, VCMPE on page 153                                            |
| VCMPE    | Compare two floating-point registers, or one floating<br>point register and zero with Invalid Operation check | VCMP, VCMPE on page 153                                            |
| VCVT     | Convert between floating-point and integer                                                                    | VCVT, VCVTR between floating<br>point and integer on page 154      |
| VCVT     | Convert between floating-point and fixed point                                                                | VCVT between floating-point<br>and fixed-point on page 155         |
| VCVTR    | Convert between floating-point and integer with<br>rounding                                                   | VCVT, VCVTR between floating<br>point and integer on page 154      |
| VCVTB    | Converts half-precision value to single-precision                                                             | VCVTB, VCVTT on page 156                                           |
| VCVTT    | Converts single-precision register to half-precision                                                          | VCVTB, VCVTT on page 156                                           |
| VDIV     | Floating-point Divide                                                                                         | VDIV on page 157                                                   |
| VFMA     | Floating-point Fused Multiply Accumulate                                                                      | VFMA, VFMS on page 158                                             |
| VFNMA    | Floating-point Fused Negate Multiply Accumulate                                                               | VFNMA, VFNMS on page 159                                           |
| VFMS     | Floating-point Fused Multiply Subtract                                                                        | VFMA, VFMS on page 158                                             |
| VFNMS    | Floating-point Fused Negate Multiply Subtract                                                                 | VFNMA, VFNMS on page 159                                           |
| VLDM     | Load Multiple extension registers                                                                             | VLDM on page 160                                                   |
| VLDR     | Loads an extension register from memory                                                                       | VLDR on page 161                                                   |
| VLMA     | Floating-point Multiply Accumulate                                                                            | VLMA, VLMS on page 162                                             |
| VLMS     | Floating-point Multiply Subtract                                                                              | VLMA, VLMS on page 162                                             |
| VMOV     | Floating-point Move Immediate                                                                                 | VMOV immediate on page 163                                         |
| VMOV     | Floating-point Move Register                                                                                  | VMOV register on page 164                                          |
| VMOV     | Copy Arm core register to single precision                                                                    | VMOV scalar to Arm core<br>register on page 165                    |
| VMOV     | Copy 2 Arm core registers to 2 single precision                                                               | VMOV Arm core register to<br>single precision on page 166          |
| VMOV     | Copies between Arm core register to scalar                                                                    | VMOV two Arm core registers to<br>two single precision on page 167 |
| VMOV     | Copies between Scalar to Arm core register                                                                    | VMOV Arm Core register to<br>scalar on page 168                    |
| VMRS     | Move to Arm core register from floating-point<br>System Register                                              | VMRS on page 169                                                   |

![](_page_0_Picture_6.jpeg)

PM0214 Rev 10 149/262

**Table 35. Floating-point instructions**

| Mnemonic | Brief description                                                | See                                |
|----------|------------------------------------------------------------------|------------------------------------|
| VMSR     | Move to floating-point System Register from Arm<br>Core register | VMSR on page 170                   |
| VMUL     | Multiply floating-point                                          | VMUL on page 171                   |
| VNEG     | Floating-point negate                                            | VNEG on page 172                   |
| VNMLA    | Floating-point multiply and add                                  | VNMLA, VNMLS, VNMUL on<br>page 173 |
| VNMLS    | Floating-point multiply and subtract                             | VNMLA, VNMLS, VNMUL on<br>page 173 |
| VNMUL    | Floating-point multiply                                          | VNMLA, VNMLS, VNMUL on<br>page 173 |
| VPOP     | Pop extension registers                                          | VPOP on page 174                   |
| VPUSH    | Push extension registers                                         | VPUSH on page 175                  |
| VSQRT    | Floating-point square root                                       | VSQRT on page 176                  |
| VSTM     | Store Multiple extension registers                               | VSTM on page 177                   |
| VSTR     | Stores an extension register to memory                           | VSTR on page 178                   |
| VSUB     | Floating-point Subtract                                          | VSUB on page 179                   |

# <span id="page-2-0"></span>**3.10.1 VABS**

Floating-point Absolute.

## **Syntax**

VABS{cond}.F32 Sd, Sm

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd, Sm'* are the destination floating-point value and the operand floating-point value.

### **Operation**

This instruction:

- 1. Takes the absolute value of the operand floating-point register.
- 2. Places the results in the destination floating-point register.

## **Restrictions**

There are no restrictions.

## **Condition flags**

The floating-point instruction clears the sign bit.

#### **Examples**

VABS.F32 S4, S6

![](_page_2_Picture_19.jpeg)

PM0214 Rev 10 151/262

# <span id="page-3-0"></span>**3.10.2 VADD**

Floating-point Add

#### **Syntax**

```
VADD{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sn, Sm'* are the operand floating-point values.

#### **Operation**

This instruction:

- 1. Adds the values in the two floating-point operand registers.
- 2. Places the results in the destination floating-point register.

## **Restrictions**

There are no restrictions.

# **Condition flags**

This instruction does not change the flags.

### **Examples**

```
VADD.F32 S4, S6, S7
```

# <span id="page-4-0"></span>**3.10.3 VCMP, VCMPE**

Compares two floating-point registers, or one floating-point register and zero.

### **Syntax**

```
VCMP{E}{cond}.F32 Sd, Sm
VCMP{E}{cond}.F32 Sd, #0.0
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'E'* If present, any NaN operand causes an Invalid Operation exception. Otherwise, only a signaling NaN causes the exception.
- *'Sd'* is the floating-point operand to compare.
- *'Sm'* is the floating-point operand that is compared with

# **Operation**

This instruction:

1. Compares:

Two floating-point registers.

One floating-point register and zero.

1. Writes the result to the FPSCR flags.

# **Restrictions**

This instruction can raise an Invalid Operation exception if either operand is any type of NaN. It always raises an Invalid **Operation** exception if either operand is a signaling NaN.

### **Condition flags**

When this instruction writes the result to the FPSCR flags, the values are normally transferred to the Arm flags by a subsequent VMRS instruction, see *[VMRS on page 169](#page-20-0)*.

#### **Examples**

```
VCMP.F32 S4, #0.0
VCMP.F32 S4, S2
```

![](_page_4_Picture_23.jpeg)

PM0214 Rev 10 153/262

# <span id="page-5-0"></span>**3.10.4 VCVT, VCVTR between floating-point and integer**

Converts a value in a register from floating-point to a 32-bit integer.

### **Syntax**

```
VCVT{R}{cond}.Tm.F32 Sd, Sm
VCVT{cond}.F32.Tm Sd, Sm
```

#### Where:

• *'R'* .

If R is specified, the operation uses the rounding mode specified by the FPSCR. If R is omitted. the operation uses the Round towards Zero rounding mode.

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Tm'* is the data type for the operand. It must be one of:
  - S32 signed 32-bit value.
  - U32 unsigned 32-bit value.
- *'Sd, Sm'* are the destination register and the operand register.

# **Operation**

These instructions:

- 1. Either
- Converts a value in a register from floating-point value to a 32-bit integer.
- Converts from a 32-bit integer to floating-point value.
- 2. Places the result in a second register.

The floating-point to integer operation normally uses the Round towards Zero rounding mode, but can optionally use the rounding mode specified by the FPSCR.

The integer to floating-point operation uses the rounding mode specified by the FPSCR.

#### **Restrictions**

There are no restrictions.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-6-0"></span>**3.10.5 VCVT between floating-point and fixed-point**

Converts a value in a register from floating-point to and from fixed-point.

### **Syntax**

```
VCVT{cond}.Td.F32 Sd, Sd, #fbits
VCVT{cond}.F32.Td Sd, Sd, #fbits
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Td'* is the data type for the fixed-point number. It must be one of:
  - S16 signed 16-bit value.
  - U16 unsigned 16-bit value.
  - S32 signed 32-bit value.
  - U32 unsigned 32-bit value.
- *'Sd'* is the destination register and the operand register.
- *'fbits'* is the number of fraction bits in the fixed-point number:

If Td is S16 or U16, fbits must be in the range 0-16.

I f Td is S32 or U32, fbits must be in the range 1-32.

#### **Operation**

These instructions:

Either

Converts a value in a register from floating-point to fixed-point.

Converts a value in a register from fixed-point to floating-point.

Places the result in a second register.

The floating-point values are single-precision.

The fixed-point value can be 16-bit or 32-bit. Conversions from fixed-point values take their operand from the low-order bits of the source register and ignore any remaining bits.

Signed conversions to fixed-point values sign-extend the result value to the destination register width.

Unsigned conversions to fixed-point values zero-extend the result value to the destination register width.

The floating-point to fixed-point operation uses the Round towards Zero rounding mode. The fixed-point to floating-point operation uses the Round to Nearest rounding mode.

#### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

![](_page_6_Picture_32.jpeg)

PM0214 Rev 10 155/262

# <span id="page-7-0"></span>**3.10.6 VCVTB, VCVTT**

Converts between a half-precision value and a single-precision value.

### **Syntax**

```
VCVT{y}{cond}.F32.F16 Sd, Sm
VCVT{y}{cond}.F16.F32 Sd, Sm
```

#### Where:

• *'y'* Specifies which half of the operand register Sm or destination register Sd is used for the operand or destination:

If y is B, then the bottom half, bits [15:0], of Sm or Sd is used.

If y is T, then the top half, bits [31:16], of Sm or Sd is used.

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination register
- *'Sm'* is the operand register.

#### **Operation**

This instruction with the .F16.32 suffix:

- 1. Converts the half-precision value in the top or bottom half of a single-precision. register to single-precision.
- 2. Writes the result to a single-precision register.

This instruction with the .F32.F16 suffix:

- 1. Converts the value in a single-precision register to half-precision.
- 2. Writes the result into the top or bottom half of a single-precision register, preserving the other half of the target register.

# **Restrictions**

There are no restrictions.

## **Condition flags**

These instructions do not change the flags.

# <span id="page-8-0"></span>**3.10.7 VDIV**

Divides floating-point values.

#### **Syntax**

```
VDIV{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination register
- *'Sn, Sm'* are the operand registers.

#### **Operation**

This instruction:

- 1. Divides one floating-point value by another floating-point value.
- 2. Writes the result to the floating-point destination register.

## **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

![](_page_8_Picture_18.jpeg)

PM0214 Rev 10 157/262

# <span id="page-9-0"></span>**3.10.8 VFMA, VFMS**

Floating-point Fused Multiply Accumulate and Subtract.

### **Syntax**

```
VFMA{cond}.F32 {Sd,} Sn, Sm
VFMS{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination register
- *'Sn, Sm'* are the operand registers.

#### **Operation**

The VFMA instruction:

- 1. Multiplies the floating-point values in the operand registers.
- 2. Accumulates the results into the destination register.
- 3. The result of the multiply is not rounded before the accumulation.

## The VFMS instruction:

- 1. Negates the first operand register.
- 2. Multiplies the floating-point values of the first and second operand registers.
- 3. Adds the products to the destination register.
- 4. Places the results in the destination register.
- 5. The result of the multiply is not rounded before the addition.

### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

# <span id="page-10-0"></span>**3.10.9 VFNMA, VFNMS**

Floating-point Fused Negate Multiply Accumulate and Subtract.

### **Syntax**

```
VFNMA{cond}.F32 {Sd,} Sn, Sm
VFNMS{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination register
- *'Sn, Sm'* are the operand registers.

#### **Operation**

The VFNMA instruction:

- 1. Negates the first floating-point operand register.
- 2. Multiplies the first floating-point operand with second floating-point operand.
- 3. Adds the negation of the floating -point destination register to the product
- 4. Places the result into the destination register.

The result of the multiply is not rounded before the addition.

The VFNMS instruction:

- 1. Multiplies the first floating-point operand with second floating-point operand.
- 2. Adds the negation of the floating-point value in the destination register to the product.
- 3. Places the result in the destination register.

The result of the multiply is not rounded before the addition.

# **Restrictions**

There are no restrictions.

## **Condition flags**

These instructions do not change the flags.

![](_page_10_Picture_26.jpeg)

PM0214 Rev 10 159/262

# <span id="page-11-0"></span>**3.10.10 VLDM**

Floating-point Load Multiple

#### **Syntax**

```
VLDM{mode}{cond}{.size} Rn{!}, list
```

#### Where:

• *'mode'* is the addressing mode:

IA: Increment After. The consecutive addresses start at the address specified in Rn. DB: Decrement Before. The consecutive addresses end just before the address specified in Rn.

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Size'* is an optional data size specifier.
- *'Rn'* is the base register. The SP can be used
- *'!'* is the command to the instruction to write a modified value back to Rn. This is required if mode == DB, and is optional if mode == IA.
- *'list'* is the list of extension registers to be loaded, as a list of consecutively numbered doubleword or singleword registers, separated by commas and surrounded by brackets.

#### **Operation**

This instruction loads multiple extension registers from consecutive memory locations using an address from an Arm core register as the base address.

#### **Restrictions**

The restrictions are:

- If size is present, it must be equal to the size in bits, 32 or 64, of the registers in list.
- For the base address, the SP can be used.
- In the Arm instruction set, if ! is not specified the PC can be used.
- list must contain at least one register. If it contains doubleword registers, it must not contain more than 16 registers.
- If using the Decrement Before addressing mode, the write back flag, !, must be appended to the base register specification.

### **Condition flags**

These instructions do not change the flags.

![](_page_11_Picture_26.jpeg)

# <span id="page-12-0"></span>**3.10.11 VLDR**

Loads a single extension register from memory

### **Syntax**

```
VLDR{cond}{.64} Dd, [Rn{#imm}]
VLDR{cond}{.64} Dd, label
VLDR{cond}{.64} Dd, [PC, #imm}]
VLDR{cond}{.32} Sd, [Rn {, #imm}]
VLDR{cond}{.32} Sd, label
VLDR{cond}{.32} Sd, [PC, #imm]
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'64, 32* are the optional data size specifiers.
- *Dd* is the destination register for a doubleword load.
- *Sd* is the destination register for a singleword load.
- *Rn* is the base register. The SP can be used.
- *imm* is the + or immediate offset used to form the address. Permitted address values are multiples of 4 in the range 0 to 1020.
- *label* is the label of the literal data item to be loaded.

## **Operation**

This instruction loads a single extension register from memory, using a base address from an Arm core register, with an optional offset.

# **Restrictions**

There are no restrictions.

## **Condition flags**

These instructions do not change the flags.

![](_page_12_Picture_20.jpeg)

PM0214 Rev 10 161/262

# <span id="page-13-0"></span>**3.10.12 VLMA, VLMS**

Multiplies two floating-point values, and accumulates or subtracts the results.

### **Syntax**

```
VLMA{cond}.F32 Sd, Sn, Sm
VLMS{cond}.F32 Sd, Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sn, Sm'* are the operand floating-point values.

### **Operation**

The floating-point Multiply Accumulate instruction:

- 1. Multiplies two floating-point values.
- 2. Adds the results to the destination floating-point value.

The floating-point Multiply Subtract instruction:

- 1. Multiplies two floating-point values.
- 2. Subtracts the products from the destination floating-point value.

Places the results in the destination register.

## **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-14-0"></span>**3.10.13 VMOV immediate**

Move floating-point immediate

# **Syntax**

VMOV{cond}.F32 Sd, #imm

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the branch destination
- *'imm'* is a floating-point constant.

#### **Operation**

This instruction copies a constant value to a floating-point register.

#### **Restrictions**

There are no restrictions.

## **Condition flags**

These instructions do not change the flags.

![](_page_14_Picture_16.jpeg)

PM0214 Rev 10 163/262

# <span id="page-15-0"></span>**3.10.14 VMOV register**

Copies the contents of one register to another.

#### **Syntax**

```
VMOV{cond}.F64 Dd, Dm
VMOV{cond}.F32 Sd, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Dd'* is the destination register, for a doubleword operation.
- *'Dm'* is the source register, for a doubleword operation.
- *'Sd'* is the destination register, for a singleword operation.
- *'Sm'* is the source register, for a singleword operation.

### **Operation**

This instruction copies the contents of one floating-point register to another.

Restrictions

There are no restrictions

Condition flags

These instructions do not change the flags.

# <span id="page-16-0"></span>**3.10.15 VMOV scalar to Arm core register**

Transfers one word of a doubleword floating-point register to an Arm core register.

## **Syntax**

VMOV{cond} Rt, Dn[x]

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Rt'* is the destination Arm core register.
- *'Dn'* is the 64-bit doubleword register.
- *'x'* Specifies which half of the doubleword register to use: If x is 0, use lower half, if x is 1, use upper half.

# **Operation**

This instruction transfers one word from the upper or lower half of a doubleword floatingpoint register to an Arm core register.

#### **Restrictions**

Rt cannot be PC or SP.

#### **Condition flags**

These instructions do not change the flags.

![](_page_16_Picture_17.jpeg)

PM0214 Rev 10 165/262

# <span id="page-17-0"></span>**3.10.16 VMOV Arm core register to single precision**

Transfers a single-precision register to and from an Arm core register.

# **Syntax**

```
VMOV{cond} Sn, Rt
VMOV{cond} Rt, Sn
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sn'* is the single-precision floating-point register.
- *'Rt'* is the Arm core register.

# **Operation**

This instruction transfers:

- The contents of a single-precision register to an Arm core register.
- The contents of an Arm core register to a single-precision register.

### **Restrictions**

Rt cannot be PC or SP.

## **Condition flags**

These instructions do not change the flags.

# <span id="page-18-0"></span>**3.10.17 VMOV two Arm core registers to two single precision**

Transfers two consecutively numbered single-precision registers to and from two Arm core registers.

## **Syntax**

```
VMOV{cond} Sm, Sm1, Rt, Rt2
VMOV{cond} Rt, Rt2, Sm, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sm*' is the first single-precision register.
- *'Sm1'* is a second single-precision register (the next single-precision register after Sm).
- *'Rt*' is the Arm core register that Sm is transferred to or from.
- *'Rt2'* is the Arm core register that Sm1 is transferred to or from.

# **Operation**

This instruction transfers:

- 1. Contents of two consecutively numbered single-precision registers to two Arm core registers.
- 2. Contents of two Arm core registers to a pair of single-precision registers.

#### **Restrictions**

The restrictions are:

- The floating-point registers must be contiguous, one after the other.
- The Arm core registers do not have to be contiguous.
- Rt cannot be PC or SP.

### **Condition flags**

These instructions do not change the flags.

![](_page_18_Picture_23.jpeg)

PM0214 Rev 10 167/262

# <span id="page-19-0"></span>**3.10.18 VMOV Arm Core register to scalar**

Transfers one word to a floating-point register from an Arm core register.

#### **Syntax**

```
VMOV{cond}{.32} Dd[x], Rt
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *32* is an optional data size specifier.
- *Dd[x]* is the destination, where [x] defines which half of the doubleword is transferred, as follows:

If x is 0, the lower half is extracted

If x is 1, the upper half is extracted.

• *Rt* is the source Arm core register.

#### **Operation**

This instruction transfers one word to the upper or lower half of a doubleword floating-point register from an Arm core register.

#### **Restrictions**

Rt cannot be PC or SP.

## **Condition flags**

These instructions do not change the flags.

# <span id="page-20-0"></span>**3.10.19 VMRS**

Move to Arm Core register from floating-point System Register.

## **Syntax**

```
VMRS{cond} Rt, FPSCR
VMRS{cond} APSR_nzcv, FPSCR
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Rt'* is the destination Arm core register. This register can be R0-R14.
- *'APSR\_nzcv'* Transfer floating-point flags to the APSR flags.

### **Operation**

This instruction performs one of the following actions:

- 1. Copies the value of the FPSCR to a general-purpose register.
- 2. Copies the value of the FPSCR flag bits to the APSR N, Z, C, and V flags.

## **Restrictions**

Rt cannot be PC or SP.

## **Condition flags**

These instructions optionally change the flags: N, Z, C, V

![](_page_20_Picture_18.jpeg)

PM0214 Rev 10 169/262

# <span id="page-21-0"></span>**3.10.20 VMSR**

Move to floating-point System Register from Arm Core register.

## **Syntax**

VMSR{cond} FPSCR, Rt

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Rt'* is the general-purpose register to be transferred to the FPSCR.

### **Operation**

This instruction moves the value of a general-purpose register to the FPSCR. See *Floatingpoint status control register (FPSCR) on page 255* for more information.

## **Restrictions**

The restrictions are Rt cannot be PC or SP.

## **Condition flags**

This instruction updates the FPSCR.

# <span id="page-22-0"></span>**3.10.21 VMUL**

Floating-point Multiply.

#### **Syntax**

```
VMUL{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sn, Sm'* are the operand floating-point values.

#### **Operation**

This instruction:

- 1. Multiplies two floating-point values.
- 2. Places the results in the destination register.

## **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

![](_page_22_Picture_18.jpeg)

PM0214 Rev 10 171/262

# <span id="page-23-0"></span>**3.10.22 VNEG**

Floating-point Negate.

#### **Syntax**

VNEG{cond}.F32 Sd, Sm

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sm'* is the operand floating-point value.

#### **Operation**

This instruction:

- 1. Negates a floating-point value.
- 2. Places the results in a second floating-point register.
- 3. The floating-point instruction inverts the sign bit.

# **Restrictions**

There are no restrictions.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-24-0"></span>**3.10.23 VNMLA, VNMLS, VNMUL**

Floating-point multiply with negation followed by add or subtract.

### **Syntax**

```
VNMLA{cond}.F32 Sd, Sn, Sm
VNMLS{cond}.F32 Sd, Sn, Sm
VNMUL{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sn, Sm'* are the operand floating-point values.

### **Operation**

The VNMLA instruction:

- 1. Multiplies two floating-point register values.
- 2. Adds the negation of the floating-point value in the destination register to the negation of the product.
- 3. Writes the result back to the destination register.

The VNMLS instruction:

- 1. Multiplies two floating-point register values.
- 2. Adds the negation of the floating-point value in the destination register to the product.
- 3. writes the result back to the destination register.

The VNMUL instruction:

- 1. Multiplies together two floating-point register values.
- 2. Writes the negation of the result to the destination register.

## **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

![](_page_24_Picture_26.jpeg)

PM0214 Rev 10 173/262

# <span id="page-25-0"></span>**3.10.24 VPOP**

Floating-point extension register Pop.

## **Syntax**

```
VPOP{cond}{.size} list
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'size'* is an optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers in list.
- *'list'* is a list of extension registers to be loaded, as a list of consecutively numbered doubleword or singleword registers, separated by commas and surrounded by brackets.

### **Operation**

This instruction loads multiple consecutive extension registers from the stack.

#### **Restrictions**

The list must contain at least one register, and not more than sixteen registers.

## **Condition flags**

These instructions do not change the flags.

# <span id="page-26-0"></span>**3.10.25 VPUSH**

Floating-point extension register Push.

## **Syntax**

VPUSH{cond}{.size} list

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'size'* is an optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers in list.
- *'list'* is a list of the extension registers to be stored, as a list of consecutively numbered doubleword or singleword registers, separated by commas and surrounded by brackets.

### **Operation**

This instruction stores multiple consecutive extension registers to the stack.

### **Restrictions**

The restrictions are list must contain at least one register, and not more than sixteen.

### **Condition flags**

These instructions do not change the flags.

![](_page_26_Picture_16.jpeg)

PM0214 Rev 10 175/262

# <span id="page-27-0"></span>**3.10.26 VSQRT**

Floating-point Square Root.

#### **Syntax**

VSQRT{cond}.F32 Sd, Sm

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sm'* is the operand floating-point value.

#### **Operation**

This instruction:

- 1. Calculates the square root of the value in a floating-point register.
- 2. Writes the result to another floating-point register.

## **Restrictions**

There are no restrictions.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-28-0"></span>**3.10.27 VSTM**

Floating-point Store Multiple.

### **Syntax**

VSTM{mode}{cond}{.size} Rn{!}, list

#### Where:

• *'mode'* is the addressing mode:

IA Increment After. The consecutive addresses start at the address specified in Rn. This is the default and can be omitted.

DB Decrement Before. The consecutive addresses end just before the address specified in Rn.

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'size'* is an optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers in list.
- *'Rn'* is the base register. The SP can be used.
- *'!*' is the function that causes the instruction to write a modified value back to Rn. Required if mode == DB.
- *'list'* is a list of the extension registers to be stored, as a list of consecutively numbered doubleword or singleword registers, separated by commas and surrounded by brackets.

## **Operation**

This instruction stores multiple extension registers to consecutive memory locations using a base address from an Arm core register.

#### **Restrictions**

The restrictions are:

- list must contain at least one register.
- If it contains doubleword registers it must not contain more than 16 registers.
- Use of the PC as Rn is deprecated.

#### **Condition flags**

These instructions do not change the flags.

![](_page_28_Picture_24.jpeg)

PM0214 Rev 10 177/262

# <span id="page-29-0"></span>**3.10.28 VSTR**

Floating-point Store.

#### **Syntax**

```
VSTR{cond}{.32} Sd, [Rn{, #imm}]
VSTR{cond}{.64} Dd, [Rn{, #imm}]
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'32, 64'* are the optional data size specifiers.
- *'Sd'* is the source register for a singleword store.
- *'Dd*' is the source register for a doubleword store.
- *'Rn*' is the base register. The SP can be used.
- *'imm'* is the + or immediate offset used to form the address. Values are multiples of 4 in the range 0-1020. imm can be omitted, meaning an offset of +0.

#### **Operation**

This instruction stores a single extension register to memory, using an address from an Arm core register, with an optional offset, defined in imm.

#### **Restrictions**

The restrictions are the use of PC for Rn is deprecated.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-30-0"></span>**3.10.29 VSUB**

Floating-point Subtract.

#### **Syntax**

```
VSUB{cond}.F32 {Sd,} Sn, Sm
```

#### Where:

- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'Sd'* is the destination floating-point value
- *'Sn, Sm'* are the operand floating-point values.

#### **Operation**

This instruction:

- 1. Subtracts one floating-point value from another floating-point value.
- 2. Places the results in the destination floating-point register.

## **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

![](_page_30_Picture_18.jpeg)

PM0214 Rev 10 179/262