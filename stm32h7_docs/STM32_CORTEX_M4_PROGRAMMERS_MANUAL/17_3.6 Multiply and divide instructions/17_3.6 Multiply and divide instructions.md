# **3.6 Multiply and divide instructions**

*[Table 29](#page-0-0)* shows the multiply and divide instructions.

**Table 29. Multiply and divide instructions** 

<span id="page-0-0"></span>

| Mnemonic        | Brief description                                                            | See                                   |
|-----------------|------------------------------------------------------------------------------|---------------------------------------|
| MLA             | Multiply with Accumulate, 32-bit result                                      | MUL, MLA, and MLS on page 110         |
| MLS             | Multiply and Subtract, 32-bit result                                         | MUL, MLA, and MLS on page 110         |
| MUL             | Multiply, 32-bit result                                                      | MUL, MLA, and MLS on page 110         |
| SDIV            | Signed Divide                                                                | SDIV and UDIV on page 124             |
| SMLA[B,T]       | Signed Multiply Accumulate (halfwords)                                       | SMLA and SMLAW on page 112            |
| SMLAD, SMLADX   | Signed Multiply Accumulate dual                                              | SMLAD on page 114                     |
| SMLAL           | Signed Multiply with Accumulate (32x32+64), 64-bit<br>result                 | SMLAL and SMLALD on page 115          |
| SMLAL[B,T]      | Signed Multiply Accumulate Long (halfwords)                                  | SMLAL and SMLALD on page 115          |
| SMLALD, SMLALDX | Signed Multiply Accumulate Long Dual                                         | SMLAL and SMLALD on page 115          |
| SMLAW[B T]      | Signed Multiply Accumulate (word by halfword)                                | SMLA and SMLAW on page 112            |
| SMLSD           | Signed Multiply Subtract Dual                                                | SMLSD and SMLSLD on page 117          |
| SMLSLD          | Signed Multiply Subtract Long Dual                                           | SMLSD and SMLSLD on page 117          |
| SMMLA           | Signed Most Significant Word Multiply Accumulate                             | SMMLA and SMMLS on page 119           |
| SMMLS, SMMLSR   | Signed Most Significant Word Multiply Subtract                               | SMMLA and SMMLS on page 119           |
| SMUAD, SMUADX   | Signed dual multiply add                                                     | SMUAD and SMUSD on page 121           |
| SMUL[B,T]       | Signed multiply (word by halfword)                                           | SMUL and SMULW on page 122            |
| SMMUL, SMMULR   | Signed most significant word multiply                                        | SMMUL on page 120                     |
| SMULL           | Signed multiply (32x32), 64-bit result                                       | SMMUL on page 120                     |
| SMULWB, SMULWT  | Signed multiply (word by halfword)                                           | SMUL and SMULW on page 122            |
| SMUSD, SMUSDX   | Signed dual multiply subtract                                                | SMUAD and SMUSD on page 121           |
| UDIV            | Unsigned Divide                                                              | SMLA and SMLAW on page 112            |
| UMAAL           | Unsigned Multiply Accumulate Accumulate Long<br>(32x32+32+32), 64-bit result | UMULL, UMAAL and UMLAL on<br>page 111 |
| UMLAL           | Unsigned Multiply with Accumulate (32x32+64), 64-bit<br>result               | UMULL, UMAAL and UMLAL on<br>page 111 |
| UMULL           | Unsigned Multiply (32x32), 64-bit result                                     | UMULL, UMAAL and UMLAL on<br>page 111 |

![](_page_0_Picture_6.jpeg)

PM0214 Rev 10 109/262

# <span id="page-1-0"></span>**3.6.1 MUL, MLA, and MLS**

Multiply, Multiply with Accumulate, and Multiply with Subtract, using 32-bit operands, and producing a 32-bit result.

### **Syntax**

```
MUL{S}{cond} {Rd,} Rn, Rm ; Multiply
MLA{cond} Rd, Rn, Rm, Ra ; Multiply with accumulate
MLS{cond} Rd, Rn, Rm, Ra ; Multiply with subtract
```

### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*S*' is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation (see *Conditional execution on page 65*).
- '*Rd*' is the destination register. If *Rd* is omitted, the destination register is *Rn.*
- '*Rn*', '*Rm*' are registers holding the values to be multiplied.
- '*Ra*' is a register holding the value to be added to or subtracted from.

### **Operation**

The MUL instruction multiplies the values from *Rn* and *Rm*, and places the least significant 32 bits of the result in *Rd*.

The MLA instruction multiplies the values from *Rn* and *Rm*, adds the value from *Ra*, and places the least significant 32 bits of the result in *Rd*.

The MLS instruction multiplies the values from *Rn* and *Rm*, subtracts the product from the value from *Ra*, and places the least significant 32 bits of the result in *Rd*.

The results do not depend on whether the operands are signed or unsigned.

### **Restrictions**

In these instructions, do not use either SP or PC.

If you use the S suffix with the MUL instruction:

- *Rd*, *Rn*, and *Rm* must all be in the range R0 to R7
- *Rd* must be the same as *Rm*
- You must not use the *cond* suffix

### **Condition flags**

If S is specified, the MUL instruction:

- Updates the N and Z flags according to the result.
- Does not affect the C and V flags.

### **Examples**

```
MUL R10, R2, R5 ; multiply, R10 = R2 x R5
MLA R10, R2, R1, R5 ; multiply with accumulate, R10 = (R2 x R1) + R5
MULS R0, R2, R2 ; multiply with flag update, R0 = R2 x R2
MULLT R2, R3, R2 ; conditionally multiply, R2 = R3 x R2
MLS R4, R5, R6, R7 ; multiply with subtract, R4 = R7 - (R5 x R6)
```

![](_page_1_Picture_30.jpeg)

# <span id="page-2-0"></span>**3.6.2 UMULL, UMAAL and UMLAL**

Unsigned Long Multiply, with Optional Accumulate, 32-bit operands, producing a 64-bit result.

# **Syntax**

```
op{cond} RdLo, RdHi, Rn, Rm
```

#### Where:

• '*op*' is one of the following:

UMULL: Unsigned long multiply.

UMAAL: Unsigned long multiply, with accumulate accumulate.

UMLAL: Unsigned long multiply, with accumulate

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*RdHi, RdLo*' are the destination registers. They also hold the accumulating value.
- '*Rn, Rm*' are registers holding the first and second operands.

## **Operation**

The UMULL instruction:

- 1. Multiplies the two unsigned integers in the first and second operands.
- 2. Writes the least significant 32 bits of the result in *RdLo*.
- 3. Writes the most significant 32 bits of the result in *RdHi*.

The UMAAL instruction:

- 1. Multiplies the two unsigned 32-bit integers in the first and second operands.
- 2. Adds the unsigned 32-bit integer in *RdHi* to the 64-bit result of the multiplication.
- 3. Adds the unsigned 32-bit integer in *RdLo* to the 64-bit result of the addition.
- 4. Writes the top 32-bits of the result to *RdHi*.
- 5. Writes the lower 32-bits of the result to *RdLo*.

The UMLAL instruction:

- 1. Multiplies the two unsigned integers in the first and second operands.
- 2. Adds the 64-bit result to the 64-bit unsigned integer contained in *RdHi* and *RdLo*.
- 3. Writes the result back to *RdHi* and *RdLo*.

# **Restrictions**

In these instructions:

- Do not use either SP or PC.
- *RdHi* and *RdLo* must be different registers.

# **Condition flags**

These instructions do not affect the condition code flags.

# **Examples**

```
UMULL R0, R4, R5, R6 ; Multiplies R5 and R6, writes the top 32 bits to R4
                       ; and the bottom 32 bits to R0
UMAAL R3, R6, R2, R7 ; Multiplies R2 and R7, adds R6, adds R3, writes the
```

![](_page_2_Picture_37.jpeg)

PM0214 Rev 10 111/262

```
; top 32 bits to R6, and the bottom 32 bits to R3
UMLAL R2, R1, R3, R5 ; Multiplies R5 and R3, adds R1:R2, writes to R1:R2.
```

# <span id="page-3-0"></span>**3.6.3 SMLA and SMLAW**

Signed Multiply Accumulate (halfwords).

#### Syntax

```
op{XY}{cond} Rd, Rn, Rm
op{Y}{cond} Rd, Rn, Rm, Ra
```

### Where

• op is one of the following:

SMLA: Signed multiply accumulate long (halfwords). X and Y specifies which half of the source registers *Rn* and *Rm* are used as the first and second multiply operand.

- If X is B, then the bottom halfword, bits [15:0], of *Rn* is used.
- If X is T, then the top halfword, bits [31:16], of *Rn* is used.
- If Y is B, then the bottom halfword, bits [15:0], of *Rm* is used.
- If Y is T, then the top halfword, bits [31:16], of *Rm* is used.

SMLAW: Signed multiply accumulate (word by halfword). Y specifies which half of the source *Rm* register is used as the second multiply operand.

- If Y is T, then the top halfword, bits [31:16] of *Rm* is used.
- If Y is B, then the bottom halfword, bits [15:0] of *Rm* is used.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register. If *Rd* is omitted, the destination register is *Rn.*
- '*Rn*', '*Rm*' are registers holding the values to be multiplied.
- '*Ra*' is a register holding the value to be added to or subtracted from.

### **Operation**

The SMALBB, SMLABT, SMLATB, SMLATT instructions:

- 1. Multiply the specified signed halfword, top or bottom, values from *Rn* and *Rm*.
- 2. Add the value in *Ra* to the resulting 32-bit product.
- 3. Write the result of the multiplication and addition in Rd.
- 4. The non-specified halfwords of the source registers are ignored.

The SMLAWB and SMLAWT instructions:

- 1. Multiply the 32-bit signed values in *Rn* with:
  - a) The top signed halfword of *Rm*, T instruction suffix.
  - b) The bottom signed halfword of *Rm*, B instruction suffix.
- 2. Add the 32-bit signed value in *Ra* to the top 32 bits of the 48-bit product.
- 3. Write the result of the multiplication and addition in Rd.
- 4. The bottom 16 bits of the 48-bit product are ignored.
- 5. If overflow occurs during the addition of the accumulate value, the instruction sets the Q flag in the APSR. No overflow can occur during the multiplication.

### **Restrictions**

In these instructions, do not use SP or PC.

![](_page_3_Picture_38.jpeg)

# **Condition flags**

If an overflow is detected, the Q flag is set.

# **Examples**

```
SMLABB R5, R6, R4, R1 ; Multiplies bottom halfwords of R6 and R4, adds
                   ; R1 and writes to R5
SMLATB R5, R6, R4, R1 ; Multiplies top halfword of R6 with bottom halfword
                   ; of R4, adds R1 and writes to R5
SMLATT R5, R6, R4, R1 ; Multiplies top halfwords of R6 and R4, adds 
                   ; R1 and writes the sum to R5
SMLABT R5, R6, R4, R1 ; Multiplies bottom halfword of R6 with top halfword
                   ; of R4, adds R1 and writes to R5
SMLABT R4, R3, R2 ; Multiplies bottom halfword of R4 with top halfword
                   ; of R3, adds R2 and writes to R4
SMLAWB R10, R2, R5, R3 ; Multiplies R2 with bottom halfword of R5, adds
                   ; R3 to the result and writes top 32-bits to R10
SMLAWT R10, R2, R1, R5 ; Multiplies R2 with top halfword of R1, adds R5 
                   ; and writes top 32-bits to R10.
```

![](_page_4_Picture_6.jpeg)

PM0214 Rev 10 113/262

# <span id="page-5-0"></span>**3.6.4 SMLAD**

Signed Multiply Accumulate Long Dual

### **Syntax**

```
op{X}{cond} Rd, Rn, Rm, Ra ; 
Where:
```

• op is one of the following:

SMLAD: Signed multiply accumulate dual.

SMLADX: Signed multiply accumulate dual reverse. X specifies which halfword of the source register *Rn* is used as the multiply operand.

If X is omitted, the multiplications are bottom × bottom and top × top.

If X is present, the multiplications are bottom × top and top × bottom.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the first operand register holding the values to be multiplied.
- '*Rm*' is the second operand register.
- '*Ra*' is the accumulate value.

### **Operation**

The SMLAD and SMLADX instructions regard the two operands as four halfword 16-bit values. The SMLAD and SMLADX instructions:

- 1. Either:
  - a) If X is not present, multiply the top signed halfword value in *Rn* with the top signed halfword of *Rm* and the bottom signed halfword values in *Rn* with the bottom signed halfword of *Rm*.
  - b) If X is present, multiply the top signed halfword value in *Rn* with the bottom signed halfword of *Rm* and the bottom signed halfword values in *Rn* with the top signed halfword of *Rm*.
- 2. Add both multiplication results to the signed 32-bit value in *Ra*.
- 3. Write the 32-bit signed result of the multiplication and addition to Rd.

### **Restrictions**

Do not use either SP or PC.

### **Condition flags**

These instructions do not change the flags.

# Examples

```
SMLAD R10, R2, R1, R5 ; Multiplies two halfword values in R2 with 
                       ; corresponding halfwords in R1, adds R5 and writes
                       ; to R10
SMLALDX R0, R2, R4, R6 ; Multiplies top halfword of R2 with bottom halfword
                   ; of R4, multiplies bottom halfword of R2 with top 
                   ; halfword of R4, adds R6 and writes to R0.
```

![](_page_5_Picture_30.jpeg)

# <span id="page-6-0"></span>**3.6.5 SMLAL and SMLALD**

Signed Multiply Accumulate Long, Signed Multiply Accumulate Long (halfwords) and Signed Multiply Accumulate Long Dual.

# **Syntax**

```
op{cond} RdLo, RdHi, Rn, Rm
op{XY}{cond} RdLo, RdHi, Rn, Rm
op{X}{cond} RdLo, RdHi, Rn, Rm
```

### Where:

- op is one of the following:
  - SMLAL: Signed multiply accumulate long.
  - SMLAL: Signed multiply accumulate long (halfwords, X and Y). X and Y specify which halfword of the source registers *Rn* and *Rm* are used as the first and second multiply operand:

If X is B, then the bottom halfword, bits [15:0], of *Rn* is used.

If X is T, then the top halfword, bits [31:16], of *Rn* is used.

If Y is B, then the bottom halfword, bits [15:0], of *Rm* is used.

If Y is T, then the top halfword, bits [31:16], of *Rm* is used.

- SMLALD: Signed multiply accumulate long Dual.
- SMLALDX: Signed multiply accumulate long dual reversed: If the X is omitted, the multiplications are bottom × bottom and top × top. If X is present, the multiplications are bottom × top and top × bottom.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*RdHi, RdLo*' are the destination registers. *RdLo* is the lower 32 bits and *RdHi* is the upper 32 bits of the 64-bit integer. For SMLAL, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLALD and SMLALDX, they also hold the accumulating value.
- '*Rn*', '*Rm*' are registers holding the first and second operands

### **Operation**

The SMLAL instruction:

- 1. Multiplies the two's complement signed word values from *Rn* and *Rm*.
- 2. Adds the 64-bit value in *RdLo* and *RdHi* to the resulting 64-bit product.
- 3. Writes the 64-bit result of the multiplication and addition in *RdLo* and *RdHi*.

The SMLALBB, SMLALBT, SMLALTB and SMLALTT instructions:

- 1. Multiplies the specified signed halfword, top or bottom, values from *Rn* and *Rm*.
- 2. Adds the resulting sign-extended 32-bit product to the 64-bit value in *RdLo* and *RdHi*.
- 3. Writes the 64-bit result of the multiplication and addition in *RdLo* and *RdHi*.

The non-specified halfwords of the source registers are ignored.

![](_page_6_Picture_29.jpeg)

PM0214 Rev 10 115/262

The SMLALD and SMLALDX instructions interpret the values from *Rn* and *Rm* as four halfword two's complement signed 16-bit integers. These instructions:

- If X is not present, multiply the top signed halfword value of *Rn* with the top signed halfword of *Rm* and the bottom signed halfword values of *Rn* with the bottom signed halfword of *Rm*.
- Or if X is present, multiply the top signed halfword value of *Rn* with the bottom signed halfword of *Rm* and the bottom signed halfword values of *Rn* with the top signed halfword of *Rm*.
- Add the two multiplication results to the signed 64-bit value in *RdLo* and *RdHi* to create the resulting 64-bit product.
- Write the 64-bit product in *RdLo* and *RdHi*.

## **Restrictions**

In these instructions:

Do not use either SP or PC.

*RdHi* and *RdLo* must be different registers.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
SMLAL R4, R5, R3, R8 ; Multiplies R3 and R8, adds R5:R4 and writes to 
                       ; R5:R4
SMLALBT R2, R1, R6, R7 ; Multiplies bottom halfword of R6 with top 
                       ; halfword of R7, sign extends to 32-bit, adds 
                       ; R1:R2 and writes to R1:R2
SMLALTB R2, R1, R6, R7 ; Multiplies top halfword of R6 with bottom
                       ; halfword of R7,sign extends to 32-bit, adds R1:R2
                       ; and writes to R1:R2
SMLALD R6, R8, R5, R1 ; Multiplies top halfwords in R5 and R1 and bottom
                       ; halfwords of R5 and R1, adds R8:R6 and writes to
                       ; R8:R6
SMLALDX R6, R8, R5, R1 ; Multiplies top halfword in R5 with bottom
                       ; halfword of R1, and bottom halfword of R5 with 
                       ; top halfword of R1, adds R8:R6 and writes to 
                       ; R8:R6.
```

# <span id="page-8-0"></span>**3.6.6 SMLSD and SMLSLD**

Signed Multiply Subtract Dual and Signed Multiply Subtract Long Dual

# **Syntax**

op{X}{cond} Rd, Rn, Rm, Ra

#### Where:

• op is one of:

SMLSD: Signed multiply subtract dual.

SMLSDX: Signed multiply subtract dual reversed

SMLSLD: Signed multiply subtract long dual.

SMLSLDX: Signed multiply subtract long dual reversed.

- If X is present, the multiplications are bottom × top and top × bottom.
- If the X is omitted, the multiplications are bottom × bottom and top × top.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register.
- '*Rn*', '*Rm*' are registers holding the first and second operands
- '*Ra*' is the register holding the accumulate value

## **Operation**

The SMLSD instruction interprets the values from the first and second operands as four signed halfwords. This instruction:

- 1. Optionally rotates the halfwords of the second operand.
- 2. Performs two signed 16 × 16-bit halfword multiplications.
- 3. Subtracts the result of the upper halfword multiplication from the result of the lower halfword multiplication.
- 4. Adds the signed accumulate value to the result of the subtraction.
- 5. Writes the result of the addition to the destination register.

The SMLSLD instruction interprets the values from *Rn* and *Rm* as four signed halfwords.

#### This instruction:

- 1. Optionally rotates the halfwords of the second operand.
- 2. Performs two signed 16 × 16-bit halfword multiplications.
- 3. Subtracts the result of the upper halfword multiplication from the result of the lower halfword multiplication.
- 4. Adds the 64-bit value in *RdHi* and *RdLo* to the result of the subtraction.
- 5. Writes the 64-bit result of the addition to the *RdHi* and *RdLo*.

## **Restrictions**

In these instructions: Do not use either SP or PC.

### **Condition flags**

This instruction sets the Q flag if the accumulate operation overflows. Overflow cannot occur during the multiplications or subtraction.

![](_page_8_Picture_36.jpeg)

PM0214 Rev 10 117/262

For the Thumb instruction set, these instructions do not affect the condition code flags.

### **Examples**

```
SMLS R0, R4, R5, R6 ; Multiplies bottom halfword of R4 with bottom
                       ; halfword of R5, multiplies top halfword of R4
                       ; with top halfword of R5, subtracts second from
                       ; first, adds R6, writes to R0
SMLSDX R1, R3, R2, R0 ; Multiplies bottom halfword of R3 with top
                       ; halfword of R2, multiplies top halfword of R3
                       ; with bottom halfword of R2, subtracts second from
                       ; first, adds R0, writes to R1
SMLSLD R3, R6, R2, R7 ; Multiplies bottom halfword of R6 with bottom 
                       ; halfword of R2, multiplies top halfword of R6
                       ; with top halfword of R2, subtracts second from
                       ; first, adds R6:R3, writes to R6:R3
SMLSLDX R3, R6, R2, R7 ; Multiplies bottom halfword of R6 with top
                       ; halfword of R2, multiplies top halfword of R6
                       ; with bottom halfword of R2, subtracts second from
                       ; first, adds R6:R3, writes to R6:R3.
```

![](_page_9_Picture_5.jpeg)

# <span id="page-10-0"></span>**3.6.7 SMMLA and SMMLS**

Signed Most Significant Word Multiply Accumulate and Signed Most Significant Word Multiply Subtract.

# **Syntax**

```
op{R}{cond} Rd, Rn, Rm, Ra
```

#### Where:

- op is one of the following:
  - SMMLA: Signed most significant word multiply accumulate.
    - SMMLS: Signed most significant word multiply subtract.
- R is a rounding error flag. If R is specified, the result is rounded instead of being truncated, 0x80000000 is added to the product before the high word is extracted.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register.
- '*Rn*', '*Rm*' are registers holding the first and second multiply operands
- '*Ra*' is the register holding the accumulate value

### **Operation**

The SMMLA instruction interprets the values from *Rn* and *Rm* as signed 32-bit words:

- 1. Multiplies the values in *Rn* and *Rm*.
- 2. Optionally rounds the result by adding 0x80000000.
- 3. Extracts the most significant 32 bits of the result.
- 4. Adds the value of *Ra* to the signed extracted value.
- 5. Writes the result of the addition in *Rd*.

The SMMLS instruction interprets the values from *Rn* and *Rm* as signed 32-bit words:

- 1. Multiplies the values in *Rn* and *Rm*.
- 2. Optionally rounds the result by adding 0x80000000.
- 3. Extracts the most significant 32 bits of the result.
- 4. Subtracts the extracted value of the result from the value in *Ra*.
- 5. Writes the result of the subtraction in *Rd*.

### **Restrictions**

In these instructions: Do not use either SP or PC.

# **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
SMMLA R0, R4, R5, R6 ; Multiplies R4 and R5, extracts top 32 bits,
                         ; adds R6, truncates and writes to R0
SMMLAR R6, R2, R1, R4 ; Multiplies R2 and R1, extracts top 32 bits,
                         ; adds R4, rounds and writes to R6
SMMLSR R3, R6, R2, R7 ; Multiplies R6 and R2, extracts top 32 bits,
                         ; subtracts R7, rounds and writes to R3
```

PM0214 Rev 10 119/262

```
SMMLS R4, R5, R3, R8 ; Multiplies R5 and R3, extracts top 32 bits, 
                         ; subtracts R8, truncates and writes to R4.
```

# <span id="page-11-0"></span>**3.6.8 SMMUL**

Signed most significant word multiply

# **Syntax**

```
op{R}{cond} Rd, Rn, Rm
```

### Where:

• op is one of the following:

SMMUL: Signed most significant word multiply.

R: a rounding error flag. If R is specified, the result is rounded instead of being truncated. In this case the constant 0x80000000 is added to the product before the high word is extracted.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*', '*Rm*' are registers holding the first and second operands.

# **Operation**

The SMMUL instruction interprets the values from *Rn* and *Rm* as two's complement 32-bit signed integers. The SMMUL instruction:

- 1. Multiplies the values from *Rn* and *Rm*.
- 2. Optionally rounds the result, otherwise truncates the result.
- 3. Writes the most significant signed 32 bits of the result in *Rd*.

# **Restrictions**

In this instruction: Do not use either SP or PC.

### **Condition flags**

This instruction does not affect the condition code flags.

# **Examples**

```
SMULL R0, R4, R5 ; Multiplies R4 and R5, truncates top 32 bits
                    ; and writes to R0
SMULLR R6, R2 ; Multiplies R6 and R2, rounds the top 32 bits
                    ; and writes to R6.
```

![](_page_11_Picture_26.jpeg)

# <span id="page-12-0"></span>**3.6.9 SMUAD and SMUSD**

Signed Dual Multiply Add and Signed Dual Multiply Subtract

### **Syntax**

```
op{X}{cond} Rd, Rn, Rm
Where:
```

• op is one of:

SMUAD: Signed dual multiply add.

SMUADX: Signed dual multiply add reversed.

SMUSD: Signed dual multiply subtract.

SMUSDX: Signed dual multiply subtract reversed.

- If X is present, the multiplications are bottom × top and top × bottom. If the X is omitted, the multiplications are bottom × bottom and top × top.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register.
- '*Rn*', '*Rm*' are registers holding the first and second operands

### **Operation**

SMUAD interprets first and second operand values as two signed halfwords:

- 1. Optionally rotates the halfwords of the second operand.
- 2. Performs two signed 16 × 16-bit multiplications.
- 3. Adds the two multiplication results together.
- 4. Writes the result of the addition to the destination register.

SMUSD interprets the values from the first and second operands as two's complement signed integers:

- 1. Optionally rotates the halfwords of the second operand.
- 2. Performs two signed 16 × 16-bit multiplications.
- 3. Subtracts the result of the top halfword multiplication from the result of the bottom halfword multiplication.
- 4. Writes the result of the subtraction to the destination register.

### **Restrictions**

In these instructions: Do not use either SP or PC.

### **Condition flags**

Sets the Q flag if the addition overflows. The multiplications cannot overflow.

# **Examples**

```
SMUAD R0, R4, R5 ; Multiplies bottom halfword of R4 with the bottom
                  ; halfword of R5, adds multiplication of top halfword
                  ; of R4 with top halfword of R5, writes to R0
SMUADX R3, R7, R4 ; Multiplies bottom halfword of R7 with top halfword
                  ; of R4, adds multiplication of top halfword of R7 
                  ; with bottom halfword of R4, writes to R3
```

![](_page_12_Picture_32.jpeg)

PM0214 Rev 10 121/262

```
SMUSD R3, R6, R2 ; Multiplies bottom halfword of R4 with bottom halfword
                  ; of R6, subtracts multiplication of top halfword of R6
                  ; with top halfword of R3, writes to R3
SMUSDX R4, R5, R3 ; Multiplies bottom halfword of R5 with top halfword of
                  ; R3, subtracts multiplication of top halfword of R5
                  ; with bottom halfword of R3, writes to R4.
```

# <span id="page-13-0"></span>**3.6.10 SMUL and SMULW**

Signed Multiply (halfwords) and Signed Multiply (word by halfword)

# **Syntax**

```
op{XY}{cond} Rd, Rn, Rm
op{Y}{cond} Rd. Rn, Rm
```

• op is one of:

SMUL{XY} Signed multiply (halfwords). X and Y specify which halfword of the source registers *Rn* and *Rm* is used as the first and second multiply operand.

```
If X is B, then the bottom halfword, bits [15:0] of Rn is used.
```

If X is T, then the top halfword, bits [31:16] of *Rn* is used.

If Y is B, then the bottom halfword, bits [15:0], of *Rm* is used.

If Y is T, then the top halfword, bits [31:16], of *Rm* is used.

SMULW{Y} Signed multiply (word by halfword). Y specifies which halfword of the source *Rm* register is used as the second multiply operand.

If Y is B, then the bottom halfword (bits [15:0]) of *Rm* is used.

If Y is T, then the top halfword (bits [31:16]) of *Rm* is used.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register.
- '*Rn*', '*Rm*' are registers holding the first and second operands

### **Operation**

The SMULBB, SMULTB, SMULBT and SMULTT instructions interprets the values from *Rn* and *Rm* as four signed 16-bit integers. These instructions:

- 1. Multiply the specified signed halfword, top or bottom, values from *Rn* and *Rm*.
- 2. Write the 32-bit result of the multiplication in *Rd*.

The SMULWT and SMULWB instructions interprets the values from *Rn* as a 32-bit signed integer and *Rm* as two halfword 16-bit signed integers. These instructions:

- 1. Multiply the first operand and the top, T suffix, or the bottom, B suffix, halfword of the second operand.
- 2. Write the 32 signed most significant bits of the 48-bit result in the destination register.

### **Restrictions**

Do not use either SP or PC.

### **Examples**

```
SMULBT R0, R4, R5 ; Multiplies the bottom halfword of R4 with the top
                  ; halfword of R5, multiplies results and writes to R0
```

![](_page_13_Picture_31.jpeg)

```
SMULBB R0, R4, R5 ; Multiplies the bottom halfword of R4 with the bottom
                  ; halfword of R5, multiplies results and writes to R0
SMULTT R0, R4, R5 ; Multiplies the top halfword of R4 with the top 
                  ; halfword of R5, multiplies results and writes to R0
SMULTB R0, R4, R5 ; Multiplies the top halfword of R4 with the bottom
                  ; halfword of R5, multiplies results and writes to R0
SMULWT R4, R5, R3 ; Multiplies R5 with the top halfword of R3,
                  ; extracts top 32 bits and writes to R4
SMULWB R4, R5, R3 ; Multiplies R5 with the bottom halfword of R3,
                  ; extracts top 32 bits and writes to R4.
```

# **3.6.11 UMULL, UMLAL, SMULL, and SMLAL**

Signed and Unsigned Long Multiply, with optional Accumulate, using 32-bit operands and producing a 64-bit result.

### **Syntax**

```
op{cond} RdLo, RdHi, Rn, Rm
```

## Where:

• *op'* is one of:

UMULL: Unsigned long multiply.

UMLAL: Unsigned long multiply, with accumulate.

SMULL: Signed long multiply.

SMLAL: Signed long multiply, with accumulate.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*RdHi, RdLo*' are the destination registers. For UMLAL and SMLAL they also hold the accumulating value.
- '*Rn*', '*Rm*' are registers holding the operands

# **Operation**

The UMULL instruction interprets the values from *Rn* and *Rm* as unsigned integers. It multiplies these integers and places the least significant 32 bits of the result in *RdLo*, and the most significant 32 bits of the result in *RdHi*.

The UMLAL instruction interprets the values from *Rn* and *Rm* as unsigned integers. It multiplies these integers, adds the 64-bit result to the 64-bit unsigned integer contained in *RdHi* and *RdLo*, and writes the result back to *RdHi* and *RdLo*.

The SMULL instruction interprets the values from *Rn* and *Rm* as two's complement signed integers. It multiplies these integers and places the least significant 32 bits of the result in *RdLo*, and the most significant 32 bits of the result in *RdHi*.

The SMLAL instruction interprets the values from *Rn* and *Rm* as two's complement signed integers. It multiplies these integers, adds the 64-bit result to the 64-bit signed integer contained in *RdHi* and *RdLo*, and writes the result back to *RdHi* and *RdLo*.

PM0214 Rev 10 123/262

## **Restrictions**

In these instructions:

- Do not use either SP or PC
- *RdHi* and *RdLo* must be different registers.

## **Condition flags**

These instructions do not affect the condition code flags.

## **Examples**

```
 UMULL R0, R4, R5, R6 ; Unsigned (R4,R0) = R5 x R6
 SMLAL R4, R5, R3, R8 ; Signed (R5,R4) = (R5,R4) + R3 x R8
```

# <span id="page-15-0"></span>**3.6.12 SDIV and UDIV**

Signed Divide and Unsigned Divide.

# **Syntax**

```
SDIV{cond} {Rd,} Rn, Rm
UDIV{cond} {Rd,} Rn, Rm
```

### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register. If *Rd* is omitted, the destination register is *Rn.*
- '*Rn,*' is the register holding the value to be divided.
- '*Rm*' is a register holding the divisor.

### **Operation**

SDIV performs a signed integer division of the value in *Rn* by the value in *Rm*.

UDIV performs an unsigned integer division of the value in *Rn* by the value in *Rm*.

For both instructions, if the value in *Rn* is not divisible by the value in *Rm*, the result is rounded towards zero.

# **Restrictions**

Do not use either SP or PC*.*

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SDIV R0, R2, R4; signed divide, R0 = R2/R4
UDIV R8, R8, R1; unsigned divide, R8 = R8/R1
```