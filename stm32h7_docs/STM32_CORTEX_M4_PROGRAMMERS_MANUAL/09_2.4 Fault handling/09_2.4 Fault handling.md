## **Exception return**

Exception return occurs when the processor is in Handler mode and executes one of the following instructions to load the EXC\_RETURN value into the PC:

- an LDM or POP instruction that loads the PC
- an LDR instruction with PC as the destination
- a BX instruction using any register.

EXC\_RETURN is the value loaded into the LR on exception entry. The exception mechanism relies on this value to detect when the processor has completed an exception handler. The lowest five bits of this value provide information on the return stack and processor mode. *[Table 18](#page-0-0)* shows the EXC\_RETURN values with a description of the exception return behavior.

All EXC\_RETURN values have bits[31:5] set to one. When this value is loaded into the PC it indicates to the processor that the exception is complete, and the processor initiates the appropriate exception return sequence.

<span id="page-0-0"></span>

| EXC_RETURN[31:0] | Description                                                                                                                 |  |  |
|------------------|-----------------------------------------------------------------------------------------------------------------------------|--|--|
| 0xFFFFFFF1       | Return to Handler mode, exception return uses non-floating-point state from<br>the MSP and execution uses MSP after return. |  |  |
| 0xFFFFFFF9       | Return to Thread mode, exception return uses non-floating-point state from<br>MSP and execution uses MSP after return.      |  |  |
| 0xFFFFFFFD       | Return to Thread mode, exception return uses non-floating-point state from<br>the PSP and execution uses PSP after return.  |  |  |
| 0xFFFFFFE1       | Return to Handler mode, exception return uses floating-point-state from MSP<br>and execution uses MSP after return.         |  |  |
| 0xFFFFFFE9       | Return to Thread mode, exception return uses floating-point state from MSP<br>and execution uses MSP after return.          |  |  |
| 0xFFFFFFED       | Return to Thread mode, exception return uses floating-point state from PSP<br>and execution uses PSP after return.          |  |  |

**Table 18. Exception return behavior** 

## **2.4 Fault handling**

Faults are a subset of the exceptions. For more information, see *Exception model on page 37*. The following elements generate a fault:

- A bus error on:
  - An instruction fetch or vector table load
  - A data access
- An internally-detected error such as an undefined instruction
- Attempting to execute an instruction from a memory region marked as *Non-Executable* (XN).
- A privilege violation or an attempt to access an unmanaged region causing an MPU fault.

44/262 PM0214 Rev 10

![](_page_0_Picture_20.jpeg)

## 2.4.1 Fault types

*Table 19* shows the types of fault, the handler used for the fault, the corresponding fault status register, and the register bit that indicates that the fault has occurred. See *Configurable fault status register (CFSR; UFSR+BFSR+MMFSR) on page 237* for more information about the fault status registers.

Table 19. Faults

<span id="page-1-0"></span>

| Fault                                                            | Handler     | Bit name                | Fault status register                                                           |
|------------------------------------------------------------------|-------------|-------------------------|---------------------------------------------------------------------------------|
| Bus error on a vector read                                       | Hard fault  | VECTTBL                 | Hard fault status register<br>(HFSR) on page 241                                |
| Fault escalated to a hard fault                                  |             | FORCED                  |                                                                                 |
| MPU or default memory map mismatch:                              | - MemManage | -                       | Memory management fault<br>address register (MMFAR)<br>on page 242              |
| - on instruction access                                          |             | IACCVIOL <sup>(1)</sup> |                                                                                 |
| â€“ on data access                                                 |             | DACCVIOL                |                                                                                 |
| <ul> <li>during exception stacking</li> </ul>                    |             | MSTKERR                 |                                                                                 |
| - during exception unstacking                                    |             | MUNSKERR                |                                                                                 |
| during lazy floating-point state preservation                    |             | MLSPERR                 |                                                                                 |
| Bus error:                                                       | Bus fault   | -                       | -                                                                               |
| <ul> <li>During exception stacking</li> </ul>                    |             | STKERR                  | - Bus fault address register<br>(BFAR) on page 242                              |
| During exception unstacking                                      |             | UNSTKERR                |                                                                                 |
| - During instruction prefetch                                    |             | IBUSERR                 |                                                                                 |
| During lazy floating-point state preservation                    |             | LSPERR                  |                                                                                 |
| Precise data bus error                                           |             | PRECISERR               |                                                                                 |
| Imprecise data bus error                                         |             | IMPRECISERR             |                                                                                 |
| Attempt to access a coprocessor                                  |             | NOCP                    | Configurable fault status<br>register (CFSR;<br>UFSR+BFSR+MMFSR) on<br>page 237 |
| Undefined instruction                                            | Usage fault | UNDEFINSTR              |                                                                                 |
| Attempt to enter an invalid instruction set state <sup>(2)</sup> |             | INVSTATE                |                                                                                 |
| Invalid EXC_RETURN value                                         |             | INVPC                   |                                                                                 |
| Illegal unaligned load or store                                  |             | UNALIGNED               |                                                                                 |
| Divide By 0                                                      |             | DIVBYZERO               |                                                                                 |

<sup>1.</sup> Occurs on an access to an XN region even if the MPU is disabled.

![](_page_1_Picture_8.jpeg)

PM0214 Rev 10 45/262

Attempting to use an instruction set other than the Thumb instruction set, or returns to a non load/storemultiple instruction with ICI continuation.

## **2.4.2 Fault escalation and hard faults**

All faults exceptions except for hard fault have configurable exception priority, as described in *System handler priority registers (SHPRx) on page 233*. Software can disable execution of the handlers for these faults, as described in *System handler control and state register (SHCSR) on page 235*.

Usually, the exception priority, together with the values of the exception mask registers, determines whether the processor enters the fault handler, and whether a fault handler can preempt another fault handler, as described in *Section 2.3: Exception model on page 37*.

In some situations, a fault with configurable priority is treated as a hard fault. This is called *priority escalation*, and the fault is described as *escalated to hard fault*. Escalation to hard fault occurs when:

- A fault handler causes the same kind of fault as the one it is servicing. This escalation to hard fault occurs when a fault handler cannot preempt itself because it must have the same priority as the current priority level.
- A fault handler causes a fault with the same or lower priority as the fault it is servicing. This is because the handler for the new fault cannot preempt the currently executing fault handler.
- An exception handler causes a fault for which the priority is the same as or lower than the currently executing exception.
- A fault occurs and the handler for that fault is not enabled.

If a bus fault occurs during a stack push when entering a bus fault handler, the bus fault does not escalate to a hard fault. This means that if a corrupted stack causes a fault, the fault handler executes even though the stack push for the handler failed. The fault handler operates but the stack contents are corrupted.

Only Reset and NMI can preempt the fixed priority hard fault. A hard fault can preempt any exception other than Reset, NMI, or another hard fault.

46/262 PM0214 Rev 10