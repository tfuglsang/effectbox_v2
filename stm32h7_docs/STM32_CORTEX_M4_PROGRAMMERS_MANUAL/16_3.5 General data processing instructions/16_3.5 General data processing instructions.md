# **3.5 General data processing instructions**

*[Table 28](#page-0-0)* shows the data processing instructions.

**Table 28. Data processing instructions** 

<span id="page-0-0"></span>

| Brief description                                     | See                                    |
|-------------------------------------------------------|----------------------------------------|
| Add with carry                                        | ADD, ADC, SUB, SBC, and RSB on page 83 |
| Add                                                   | ADD, ADC, SUB, SBC, and RSB on page 83 |
| Add                                                   | ADD, ADC, SUB, SBC, and RSB on page 83 |
| Logical AND                                           | AND, ORR, EOR, BIC, and ORN on page 85 |
| Arithmetic Shift Right                                | ASR, LSL, LSR, ROR, and RRX on page 86 |
| Bit Clear                                             | AND, ORR, EOR, BIC, and ORN on page 85 |
| Count leading zeros                                   | CLZ on page 87                         |
| Compare Negative                                      | CMP and CMN on page 88                 |
| Compare                                               | CMP and CMN on page 88                 |
| Exclusive OR                                          | AND, ORR, EOR, BIC, and ORN on page 85 |
| Logical Shift Left                                    | ASR, LSL, LSR, ROR, and RRX on page 86 |
| Logical Shift Right                                   | ASR, LSL, LSR, ROR, and RRX on page 86 |
| Move                                                  | MOV and MVN on page 89                 |
| Move Top                                              | MOVT on page 91                        |
| Move 16-bit constant                                  | MOV and MVN on page 89                 |
| Move NOT                                              | MOV and MVN on page 89                 |
| Logical OR NOT                                        | AND, ORR, EOR, BIC, and ORN on page 85 |
| Logical OR                                            | AND, ORR, EOR, BIC, and ORN on page 85 |
| Reverse Bits                                          | REV, REV16, REVSH, and RBIT on page 92 |
| Reverse byte order in a word                          | REV, REV16, REVSH, and RBIT on page 92 |
| Reverse byte order in each halfword                   | REV, REV16, REVSH, and RBIT on page 92 |
| Reverse byte order in bottom halfword and sign extend | REV, REV16, REVSH, and RBIT on page 92 |
| Rotate Right                                          | ASR, LSL, LSR, ROR, and RRX on page 86 |
| Rotate Right with Extend                              | ASR, LSL, LSR, ROR, and RRX on page 86 |
| Reverse Subtract                                      | ADD, ADC, SUB, SBC, and RSB on page 83 |
| Signed Add 16                                         | SADD16 and SADD8 on page 93            |
| Signed Add 8                                          | SADD16 and SADD8 on page 93            |
| Signed Add and Subtract with Exchange                 | SASX and SSAX on page 98               |
| Signed Subtract and Add with Exchange                 | SASX and SSAX on page 98               |
| Subtract with Carry                                   | ADD, ADC, SUB, SBC, and RSB on page 83 |
| Signed Halving Add 16                                 | SHADD16 and SHADD8 on page 94          |
| Signed Halving Add 8                                  | SHADD16 and SHADD8 on page 94          |
|                                                       |                                        |

![](_page_0_Picture_6.jpeg)

PM0214 Rev 10 81/262

**Table 28. Data processing instructions (continued)**

| Mnemonic | Brief description                                   | See                                    |
|----------|-----------------------------------------------------|----------------------------------------|
| SHASX    | Signed Halving Add and Subtract with Exchange       | SHASX and SHSAX on page 95             |
| SHSAX    | Signed Halving Subtract and Add with exchange       | SHASX and SHSAX on page 95             |
| SHSUB16  | Signed Halving Subtract 16                          | SHSUB16 and SHSUB8 on page 96          |
| SHSUB8   | Signed Halving Subtract 8                           | SHSUB16 and SHSUB8 on page 96          |
| SSUB16   | Signed Subtract 16                                  | SSUB16 and SSUB8 on page 97            |
| SSUB8    | Signed subtract 8                                   | SSUB16 and SSUB8 on page 97            |
| SUB      | Subtract                                            | ADD, ADC, SUB, SBC, and RSB on page 83 |
| SUBW     | Subtract                                            | ADD, ADC, SUB, SBC, and RSB on page 83 |
| TEQ      | Test Equivalence                                    | SADD16 and SADD8 on page 93            |
| TST      | Test                                                | SADD16 and SADD8 on page 93            |
| UADD16   | Unsigned Add 16                                     | UADD16 and UADD8 on page 100           |
| UADD8    | Unsigned Add 8                                      | UADD16 and UADD8 on page 100           |
| UASX     | Unsigned Add and Subtract with Exchange             | UASX and USAX on page 101              |
| USAX     | Unsigned Subtract and Add with Exchange             | UASX and USAX on page 101              |
| UHADD16  | Unsigned Halving Add 16                             | UHADD16 and UHADD8 on page 102         |
| UHADD8   | Unsigned Halving Add 8                              | UHADD16 and UHADD8 on page 102         |
| UHASX    | Unsigned Halving Add and Subtract with Exchange     | UHASX and UHSAX on page 103            |
| UHSAX    | Unsigned Halving Subtract and Add with Exchange     | UHASX and UHSAX on page 103            |
| UHSUB16  | Unsigned Halving Subtract 16                        | UHSUB16 and UHSUB8 on page 104         |
| UHSUB8   | Unsigned Halving Subtract 8                         | UHSUB16 and UHSUB8 on page 104         |
| USAD8    | Unsigned Sum of Absolute Differences                | USAD8 on page 106                      |
| USADA8   | Unsigned Sum of Absolute Differences and accumulate | USADA8 on page 107                     |
| USUB16   | Unsigned Subtract 16                                | USUB16 and USUB8 on page 108           |
| USUB8    | Unsigned Subtract 8                                 | USUB16 and USUB8 on page 108           |

## <span id="page-2-0"></span>**3.5.1 ADD, ADC, SUB, SBC, and RSB**

Add, Add with Carry, Subtract, Subtract with Carry, and Reverse Subtract.

### **Syntax**

```
op{S}{cond} {Rd,} Rn, Operand2
op{cond} {Rd,} Rn, #imm12; ADD and SUB only
```

#### Where:

• '*op*' is one of the following:

ADD: Add

ADC: Add with carry

SUB: Subtract

SBC: Subtract with carry

RSB: Reverse subtract

- '*S*' is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation (see *Conditional execution on page 65*)
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register. If Rd is omitted, the destination register is Rn
- '*Rn*' is the register holding the first operand
- '*Operand2*' is a flexible second operand (see *Flexible second operand on page 60* for details of the options)
- '*imm12*' is any value in the range 0—4095

## **Operation**

The ADD instruction adds the value of *operand2* or *imm12* to the value in *Rn*.

The ADC instruction adds the values in Rn and *operand2*, together with the carry flag.

The SUB instruction subtracts the value of *operand2* or imm12 from the value in *Rn*.

The SBC instruction subtracts the value of *operand2* from the value in *Rn*. If the carry flag is clear, the result is reduced by one.

The RSB instruction subtracts the value in *Rn* from the value of *operand2*. This is useful because of the wide range of options for *operand2*.

Use ADC and SBC to synthesize multiword arithmetic (see *[Multiword arithmetic examples](#page-3-0)  [on page 84](#page-3-0)* and *ADR on page 70*).

ADDW is equivalent to the ADD syntax that uses the *imm12* operand. SUBW is equivalent to the SUB syntax that uses the *imm12* operand.

![](_page_2_Picture_27.jpeg)

PM0214 Rev 10 83/262

### **Restrictions**

In these instructions:

- *Operand2* must be neither SP nor PC
- *Rd* can be SP only in ADD and SUB, and only with the following additional restrictions:
  - *Rn* must also be SP.
  - Any shift in operand2 must be limited to a maximum of three bits using LSL.
- *Rn* can be SP only in ADD and SUB.
- *Rd* can be PC only in the ADD{cond} PC, PC, *Rm* instruction where:
  - You must not specify the S suffix.
  - *Rm* must be neither PC nor SP.
  - If the instruction is conditional, it must be the last instruction in the IT block.
- With the exception of the ADD{cond} PC, PC, *Rm* instruction, *Rn* can be PC only in ADD and SUB, and only with the following additional restrictions:
  - You must not specify the S suffix.
  - The second operand must be a constant in the range 0 to 4095.

- *Note: 1 When using the PC for an addition or a subtraction, bits[1:0] of the PC are rounded to b00 before performing the calculation, making the base address for the calculation word-aligned.*
  - *2 If you want to generate the address of an instruction, you have to adjust the constant based on the value of the PC. Arm recommends that you use the ADR instruction instead of ADD or SUB with Rn equal to the PC, because your assembler automatically calculates the correct constant for the ADR instruction.*

When *Rd* is PC in the ADD{cond} PC, PC, *Rm* instruction:

- Bit[0] of the value written to the PC is ignored.
- A branch occurs to the address created by forcing bit[0] of that value to 0.

### **Condition flags**

If S is specified, these instructions update the N, Z, C and V flags according to the result.

### **Examples**

```
ADD R2, R1, R3
SUBS R8, R6, #240 ; sets the flags on the result
RSB R4, R4, #1280 ; subtracts contents of R4 from 1280
ADCHI R11, R0, R3 ; only executed if C flag set and Z flag clear
```

### <span id="page-3-0"></span>**Multiword arithmetic examples**

*[Specific example 4: 64-bit addition](#page-3-1)* shows two instructions that add a 64-bit integer contained in R2 and R3 to another 64-bit integer contained in R0 and R1, and place the result in R4 and R5.

### <span id="page-3-1"></span>**Specific example 4: 64-bit addition**

```
ADDS R4, R0, R2 ; add the least significant words
ADC R5, R1, R3 ; add the most significant words with carry
```

![](_page_3_Picture_31.jpeg)

Multiword values do not have to use consecutive registers. *[Specific example 5: 96-bit](#page-4-1)  [subtraction](#page-4-1)* shows instructions that subtract a 96-bit integer contained in R9, R1, and R11 from another contained in R6, R2, and R8. The example stores the result in R6, R9, and R2.

### <span id="page-4-1"></span>**Specific example 5: 96-bit subtraction**

```
SUBS R6, R6, R9 ; subtract the least significant words
SBCS R9, R2, R1 ; subtract the middle words with carry
SBC R2, R8, R11 ; subtract the most significant words with carry
```

## <span id="page-4-0"></span>**3.5.2 AND, ORR, EOR, BIC, and ORN**

Logical AND, OR, Exclusive OR, Bit Clear, and OR NOT.

### **Syntax**

```
op{S}{cond} {Rd,} Rn, Operand2
Where:
```

• '*op*' is one of:

AND: Logical AND.

ORR: Logical OR or bit set. EOR: Logical exclusive OR.

BIC: Logical AND NOT or bit clear.

ORN: Logical OR NOT.

- '*S*' is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation, see *Conditional execution on page 65*.
- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rd*' is the destination register.
- '*Rn*' is the register holding the first operand.
- '*Operand2*' is a flexible second operand, see *Flexible second operand on page 60* for details of the options.

### **Operation**

The AND, EOR, and ORR instructions perform bitwise AND, exclusive OR, and OR operations on the values in *Rn* and *operand2*.

The BIC instruction performs an AND operation on the bits in *Rn* with the complements of the corresponding bits in the value of *operand2*.

The ORN instruction performs an OR operation on the bits in *Rn* with the complements of the corresponding bits in the value of *operand2*.

# **Restrictions**

Do not use either SP or PC.

![](_page_4_Picture_25.jpeg)

PM0214 Rev 10 85/262

# **Condition flags**

If S is specified, these instructions:

- Update the N and Z flags according to the result.
- Can update the C flag during the calculation of *operand2*, see *Flexible second operand on page 60*.
- Do not affect the V flag.

## **Examples**

```
AND R9, R2,#0xFF00
ORREQ R2, R0, R5
ANDS R9, R8, #0x19
EORS R7, R11, #0x18181818
BIC R0, R1, #0xab
ORN R7, R11, R14, ROR #4
ORNS R7, R11, R14, ASR #32
```

## <span id="page-5-0"></span>**3.5.3 ASR, LSL, LSR, ROR, and RRX**

Arithmetic Shift Right, Logical Shift Left, Logical Shift Right, Rotate Right, and Rotate Right with Extend.

## **Syntax**

```
op{S}{cond} Rd, Rm, Rs
op{S}{cond} Rd, Rm, #n
RRX{S}{cond} Rd, Rm
```

#### Where:

• '*op*' is one of the following:

ASR: Arithmetic Shift Right

LSL: Logical Shift Left LSR: Logical Shift Right

ROR: Rotate Right

- '*S*' is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation, see *Conditional execution on page 65*.
- '*Rd*' is the destination register.
- '*Rm*' is the register holding the value to be shifted.
- '*Rs*' is the register holding the shift length to apply to the value *Rm*. Only the least significant byte is used and can be in the range 0 to 255.
- '*n*' is the shift length. The range of shift lengths depends on the instruction as follows:

ASR: Shift length from 1 to 32 LSL: Shift length from 0 to 31 LSR: Shift length from 1 to 32 ROR: Shift length from 1 to 31

*Note: MOVS Rd, Rm is the preferred syntax for LSLS Rd, Rm, #0.*

## **Operation**

ASR, LSL, LSR, and ROR move the bits in the *Rm* register to the left or right by the number of places specified by constant *n* or register *Rs*.

RRX moves the bits in *Rm* register to the right by 1.

In all these instructions, the result is written to *Rd*, but the value in *Rm* register remains unchanged. For details on what result is generated by the different instructions see *Shift operations on page 62*.

### **Restrictions**

Do not use either SP or PC.

### **Condition flags**

If S is specified:

- These instructions update the N and Z flags according to the result
- The C flag is updated to the last bit shifted out, except when the shift length is 0 (see *Shift operations on page 62*).

### **Examples**

```
ASR R7, R8, #9 ; arithmetic shift right by 9 bits
LSLS R1, R2, #3 ; logical shift left by 3 bits with flag update
LSR R4, R5, #6 ; logical shift right by 6 bits
ROR R4, R5, R6 ; rotate right by the value in the bottom byte of R6
RRX R4, R5 ; rotate right with extend
```

# <span id="page-6-0"></span>**3.5.4 CLZ**

Count leading zeros.

### **Syntax**

```
CLZ{cond} Rd, Rm
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rm*' is the operand register.

### **Operation**

The CLZ instruction counts the number of leading zeros in the value in *Rm* and returns the result in *Rd*. The result value is 32 if no bits are set in the source register, and zero if bit[31] is set.

# **Restrictions**

Do not use either SP or PC.

## **Condition flags**

This instruction does not change the flags.

![](_page_6_Picture_28.jpeg)

PM0214 Rev 10 87/262

### **Examples**

```
CLZ R4,R9
CLZNE R2,R3
```

## <span id="page-7-0"></span>**3.5.5 CMP and CMN**

Compare and Compare Negative.

### **Syntax**

```
CMP{cond} Rn, Operand2
CMN{cond} Rn, Operand2
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rn*' is the register holding the first operand.
- '*Operand2*' is a flexible second operand (see *Flexible second operand on page 60*) for details of the options.

### **Operation**

These instructions compare the value in a register with *operand2*. They update the condition flags on the result, but do not write the result to a register.

The CMP instruction subtracts the value of *operand2* from the value in *Rn*. This is the same as a SUBS instruction, except that the result is discarded.

The CMN instruction adds the value of *operand2* to the value in *Rn*. This is the same as an ADDS instruction, except that the result is discarded.

### **Restrictions**

In these instructions:

- Do not use PC.
- *Operand2* must not be SP.

### **Condition flags**

These instructions update the N, Z, C and V flags according to the result.

### **Examples**

```
CMP R2, R9
CMN R0, #6400
CMPGT SP, R7, LSL #2
```

# <span id="page-8-0"></span>**3.5.6 MOV and MVN**

Move and Move NOT.

### **Syntax**

```
MOV{S}{cond} Rd, Operand2
MOV{cond} Rd, #imm16
MVN{S}{cond} Rd, Operand2
```

#### Where:

- '*S*' is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation (see *Conditional execution on page 65*).
- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Operand2*' is a flexible second operand (see *Flexible second operand on page 60*) for details of the options.
- '*imm16*' is any value in the range 0—65535.

### **Operation**

The MOV instruction copies the value of *operand2* into *Rd*.

When *operand2* in a MOV instruction is a register with a shift other than LSL #0, the preferred syntax is the corresponding shift instruction:

- ASR{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, ASR #n
- LSL{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, LSL #n if n != 0
- LSR{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, LSR #n
- ROR{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, ROR #n
- RRX{S}{cond} Rd, Rm is the preferred syntax for MOV{S}{cond} Rd, Rm, RRX

Also, the MOV instruction permits additional forms of *operand2* as synonyms for shift instructions:

- MOV{S}{cond} Rd, Rm, ASR Rs is a synonym for ASR{S}{cond} Rd, Rm, Rs
- MOV{S}{cond} Rd, Rm, LSL Rs is a synonym for LSL{S}{cond} Rd, Rm, Rs
- MOV{S}{cond} Rd, Rm, LSR Rs is a synonym for LSR{S}{cond} Rd, Rm, Rs
- MOV{S}{cond} Rd, Rm, ROR Rs is a synonym for ROR{S}{cond} Rd, Rm, Rs

See *[ASR, LSL, LSR, ROR, and RRX on page 86](#page-5-0)*.

The MVN instruction takes the value of *operand2*, performs a bitwise logical NOT operation on the value, and places the result into *Rd*.

*Note: The MOVW instruction provides the same function as MOV, but is restricted to use of the imm16 operand.*

![](_page_8_Picture_29.jpeg)

PM0214 Rev 10 89/262

### **Restrictions**

You can use SP and PC only in the MOV instruction, with the following restrictions:

- The second operand must be a register without shift
- You must not specify the S suffix

When *Rd* is PC in a MOV instruction:

- bit[0] of the value written to the PC is ignored
- A branch occurs to the address created by forcing bit[0] of that value to 0.

*Note: Though it is possible to use MOV as a branch instruction, Arm strongly recommends the use of a BX or BLX instruction to branch for software portability to the Arm instruction set.*

### **Condition flags**

If S is specified, these instructions:

- Update the N and Z flags according to the result
- Can update the C flag during the calculation of *operand2* (see *Flexible second operand on page 60*).
- Do not affect the V flag

## **Example**

```
MOVS R11, #0x000B ; write value of 0x000B to R11, flags get updated
MOV R1, #0xFA05 ; write value of 0xFA05 to R1, flags not updated
MOVS R10, R12 ; write value in R12 to R10, flags get updated
MOV R3, #23 ; write value of 23 to R3
MOV R8, SP ; write value of stack pointer to R8
MVNS R2, #0xF ; write value of 0xFFFFFFF0 (bitwise inverse of 0xF)
                   ; to the R2 and update flags
```

# <span id="page-10-0"></span>**3.5.7 MOVT**

Move Top.

### **Syntax**

```
MOVT{cond} Rd, #imm16
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*imm16*' is a 16-bit immediate constant.

### **Operation**

MOVT writes a 16-bit immediate value, *imm16*, to the top halfword, *Rd*[31:16], of its destination register. The write does not affect *Rd*[15:0].

The MOV, MOVT instruction pair enables you to generate any 32-bit constant.

### **Restrictions**

*Rd* must be neither SP nor PC.

## **Condition flags**

This instruction does not change the flags.

### **Examples**

```
MOVT R3, #0xF123 ; write 0xF123 to upper halfword of R3,
                    ; lower halfword and APSR are unchanged
```

PM0214 Rev 10 91/262

# <span id="page-11-0"></span>**3.5.8 REV, REV16, REVSH, and RBIT**

Reverse bytes and Reverse bits.

# **Syntax**

```
op{cond} Rd, Rn
```

#### Where:

• '*op*' is one of the following:

REV: Reverse byte order in a word.

REV16: Reverse byte order in each halfword independently.

REVSH: Reverse byte order in the bottom halfword, and sign extends to 32 bits.

RBIT: Reverse the bit order in a 32-bit word.

- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rd*' is the destination register.
- '*Rn*' is the register holding the operand.

### **Operation**

Use these instructions to change endianness of data:

- REV**:** Converts either:
  - 32-bit big-endian data into little-endian data
  - or 32-bit little-endian data into big-endian data.
- REV16**:** Converts either:
  - 16-bit big-endian data into little-endian data
  - or 16-bit little-endian data into big-endian data.
- REVSH: Converts either:
  - 16-bit signed big-endian data into 32-bit signed little-endian data
  - or 16-bit signed little-endian data into 32-bit signed big-endian data.

### **Restrictions**

Do not use either SP or PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
REV R3, R7 ; reverse byte order of value in R7 and write it to R3
REV16 R0, R0 ; reverse byte order of each 16-bit halfword in R0
REVSH R0, R5 ; reverse Signed Halfword
REVHS R3, R7 ; reverse with Higher or Same condition
RBIT R7, R8 ; reverse bit order of value in R8 and write result to R7
```

![](_page_11_Picture_33.jpeg)

# <span id="page-12-0"></span>**3.5.9 SADD16 and SADD8**

Signed Add 16 and Signed Add 8

# **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

• op is any of the following:

SADD16: Performs two 16-bit signed integer additions.

SADD8: Performs four 8-bit signed integer additions.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the register holding the operand.
- '*Rm*' is the second register holding the operand.

### **Operation**

Use these instructions to perform a halfword or byte add in parallel:

The SADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Writes the result in the corresponding halfwords of the destination register.

The SADD8 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Writes the result in the corresponding bytes of the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SADD16 R1, R0 ; Adds the halfwords in R0 to the corresponding halfword 
 ; of R1 and writes to corresponding halfword of R1.
SADD8 R4, R0, R5 ; Adds bytes of R0 to the corresponding byte in R5 and
 ; writes to the corresponding byte in R4.
```

PM0214 Rev 10 93/262

![](_page_12_Picture_29.jpeg)

# <span id="page-13-0"></span>**3.5.10 SHADD16 and SHADD8**

Signed Halving Add 16 and Signed Halving Add 8

# **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

- op is any of the following:
  - SHADD16: Signed halving add 16.
    - SHADD8: Signed halving add 8.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the register holding the operand.
- '*Rm*' is the second operand register.

## **Operation**

Use these instructions to add 16-bit and 8-bit data and then to halve the result before writing the result to the destination register:

The SHADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the halfword results in the destination register.

The SHADDB8 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the byte results in the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SHADD16 R1, R0 ; Adds halfwords in R0 to corresponding halfword of R1 & 
 ; writes halved result to corresponding halfword in R1
SHADD8 R4, R0, R5 ; Adds bytes of R0 to corresponding byte in R5 and 
 ; writes halved result to corresponding byte in R4.
```

# <span id="page-14-0"></span>**3.5.11 SHASX and SHSAX**

Signed Halving Add and Subtract with Exchange / Signed Halving Subtract and Add with Exchange.

### **Syntax**

```
op{cond} {Rd}, Rn, Rm
```

#### Where:

- op is any of the following:
  - SHASX: Add and subtract with exchange and halving. SHSAX: Subtract and add with exchange and halving.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*):
- '*Rd*' is the destination register:
- '*Rn*' is the register holding the operand:
- '*Rn*', '*Rm*' are the registers holding the first and second operands:

### **Operation**

The SHASX instruction:

- 1. Adds the top halfword of the first operand to the bottom halfword of second operand.
- 2. Writes the halfword result of the addition to the top halfword of the destination register, shifted by one bit to the right, causing a divide by two, or halving.
- 3. Subtracts the top halfword of the second operand from the bottom highword of the first operand.
- 4. Writes the halfword result of the division in the bottom halfword of the destination register, shifted by one bit to the right, causing a divide by two, or halving.

#### The SHSAX instruction:

- 1. Subtracts the bottom halfword of the second operand from the top highword of the first operand.
- 2. Writes the halfword result of the addition to the bottom halfword of the destination register, shifted by one bit to the right, causing a divide by two, or halving.
- 3. Adds the bottom halfword of the first operand to the top halfword of the second operand.
- 4. Writes the halfword result of the division in the top halfword of the destination register, shifted by one bit to the right, causing a divide by two, or halving.

# **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
SHASX R7, R4, R2 ; Adds top halfword of R4 to bottom halfword of R2 
                  ; and writes halved result to top halfword of R7
                  ; Subtracts top halfword of R2 from bottom halfword of
```

![](_page_14_Picture_30.jpeg)

PM0214 Rev 10 95/262

```
; R4 and writes halved result to bottom halfword of R7
SHSAX R0, R3, R5 ; Subtracts bottom halfword of R5 from top halfword 
                  ; of R3 and writes halved result to top halfword of R0
                  ; Adds top halfword of R5 to bottom halfword of R3 and 
                  ; writes halved result to bottom halfword of R0.
```

## <span id="page-15-0"></span>**3.5.12 SHSUB16 and SHSUB8**

Signed Halving Subtract 16 and Signed Halving Subtract 8

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

• op is any of the following:

SHSUB16: Signed halving subtract 16 SHSUB8: Signed halving subtract 8

- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register
- '*Rn*' is the register holding the operand
- '*Rm*' is the second operand register

## **Operation**

Use these instructions to add 16-bit and 8-bit data and then to halve the result before writing the result to the destination register:

The SHSUB16 instruction:

- 1. Subtracts each halfword of the second operand from the corresponding halfwords of the first operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the halved halfword results in the destination register.

The SHSUBB8 instruction:

- 1. Subtracts each byte of the second operand from the corresponding byte of the first operand,
- 2. Shuffles the result by one bit to the right, halving the data,
- 3. Writes the corresponding signed byte results in the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SHSUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding halfword
 ; of R1 and writes to corresponding halfword of R1
SHSUB8 R4, R0, R5 ; Subtracts bytes of R0 from corresponding byte in R5,
```

![](_page_15_Picture_31.jpeg)

; and writes to corresponding byte in R4.

## <span id="page-16-0"></span>**3.5.13 SSUB16 and SSUB8**

Signed Subtract 16 and Signed Subtract 8

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

- op is one of the following:
  - SSUB16: Performs two 16-bit signed integer subtractions.
  - SSUB8: Performs four 8-bit signed integer subtractions.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the register holding the operand.
- '*Rm*' is the second operand register.

### **Operation**

Use these instructions to change endianness of data:

The SSUB16 instruction:

- 1. Subtracts each halfword from the second operand from the corresponding halfword of the first operand.
- 2. Writes the difference result of two signed halfwords in the corresponding halfword of the destination register.

The SSUB8 instruction:

- 1. Subtracts each byte of the second operand from the corresponding byte of the first operand.
- 2. Writes the difference result of four signed bytes in the corresponding byte of the destination register.

# **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SSUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding halfword
 ; of R1 and writes to corresponding halfword of R1
SSUB8 R4, R0, R5 ; Subtracts bytes of R5 from corresponding byte in 
 ; R0, and writes to corresponding byte of R4.
```

PM0214 Rev 10 97/262

# <span id="page-17-0"></span>**3.5.14 SASX and SSAX**

Signed Add and Subtract with Exchange and Signed Subtract and Add with Exchange.

## **Syntax**

```
op{cond} {Rd}, Rm, Rn
```

#### Where:

- op is any of the following:
  - SASX: Signed add and subtract with exchange.
  - SSAX: Signed subtract and add with exchange.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' ,'*Rm*' are the registers holding the first and second operands.

### **Operation**

The SASX instruction:

- 1. Adds the signed top halfword of the first operand with to the signed bottom halfword of the second operand.
- 2. Writes the signed result of the addition to the top halfword of the destination register.
- 3. Subtracts the signed bottom halfword of the second operand from the top signed highword of the first operand.
- 4. Writes the signed result of the subtraction to the bottom halfword of the destination register.

The SSAX instruction:

- 1. Subtracts the signed bottom halfword of the second operand from the top signed highword of the first operand.
- 2. Writes the signed result of the addition to the bottom halfword of the destination register.
- 3. Adds the signed top halfword of the first operand to the signed bottom halfword of the second operand.
- 4. Writes the signed result of the subtraction to the top halfword of the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
SASX R0, R4, R5 ; Adds top halfword of R4 to bottom halfword of R5 and 
                  ; writes to top halfword of R0
                  ; Subtracts bottom halfword of R5 from top halfword of R4
                  ; and writes to bottom halfword of R0
SSAX R7, R3, R2 ; Subtracts top halfword of R2 from bottom halfword of R3
                  ; and writes to bottom halfword of R7
```

![](_page_17_Picture_31.jpeg)

```
; Adds top halfword of R3 with bottom halfword of R2 and 
; writes to top halfword of R7.
```

## **3.5.15 TST and TEQ**

Test bits and Test Equivalence.

### **Syntax**

```
TST{cond} Rn, Operand2
TEQ{cond} Rn, Operand2
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rn*' is the register holding the first operand.
- '*Operand2*' is a flexible second operand (see *Flexible second operand on page 60*) for details of the options.

### **Operation**

These instructions test the value in a register against *operand2*. They update the condition flags based on the result, but do not write the result to a register.

The TST instruction performs a bitwise AND operation on the value in *Rn* and the value of *operand2*. This is the same as the ANDS instruction, except that it discards the result.

To test whether a bit of *Rn* is 0 or 1, use the TST instruction with an *operand2* constant that has that bit set to 1 and all other bits cleared to 0.

The TEQ instruction performs a bitwise exclusive OR operation on the value in *Rn* and the value of *operand2*. This is the same as the EORS instruction, except that it discards the result.

Use the TEQ instruction to test if two values are equal without affecting the V or C flags.

TEQ is also useful for testing the sign of a value. After the comparison, the N flag is the logical exclusive OR of the sign bits of the two operands.

## **Restrictions**

Do not use either SP or PC.

### **Condition flags**

These instructions:

- Update the N and Z flags according to the result
- Can update the C flag during the calculation of *operand2* (see *Flexible second operand on page 60*).
- Do not affect the V flag

### **Examples**

```
TST R0, #0x3F8 ; perform bitwise AND of R0 value to 0x3F8,
                  ; APSR is updated but result is discarded
TEQEQ R10, R9 ; conditionally test if value in R10 is equal to 
                  ; value in R9, APSR is updated but result is discarded
```

![](_page_18_Picture_27.jpeg)

PM0214 Rev 10 99/262

# <span id="page-19-0"></span>**3.5.16 UADD16 and UADD8**

Unsigned Add 16 and Unsigned Add 8

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

• op is one of the following:

UADD16: Performs two 16-bit unsigned integer additions.

UADD8: Performs four 8-bit unsigned integer additions.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the first register holding the operand.
- '*Rm*' is the second register holding the operand.

### **Operation**

Use these instructions to add 16- and 8-bit unsigned data:

The UADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Writes the unsigned result in the corresponding halfwords of the destination register.

The UADD16 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Writes the unsigned result in the corresponding byte of the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
UADD16 R1, R0 ; Adds halfwords in R0 to corresponding halfword of R1, 
 ; writes to corresponding halfword of R1
UADD8 R4, R0, R5 ; Adds bytes of R0 to corresponding byte in R5 and writes
 ; to corresponding byte in R4.
```

![](_page_19_Picture_29.jpeg)

# <span id="page-20-0"></span>**3.5.17 UASX and USAX**

Add and Subtract with Exchange and Subtract and Add with Exchange.

## **Syntax**

```
op{cond} {Rd}, Rn, Rm
```

#### Where:

- op is one of:
  - UASX: Add and subtract with exchange.
  - USAX: Subtract and add with exchange.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' '*Rm*' are registers holding the first and second operands.

### **Operation**

The UASX instruction:

- 1. Subtracts the top halfword of the second operand from the bottom halfword of the first operand.
- 2. Writes the unsigned result from the subtraction to the bottom halfword of the destination register.
- 3. Adds the top halfword of the first operand with bottom halfword of the second operand.
- 4. Writes the unsigned result of the addition to the top halfword of the destination register.

#### The USAX instruction:

- 1. Adds the bottom halfword of the first operand to the top halfword of the second operand.
- 2. Writes the unsigned result of the addition to the bottom halfword of the destination register.
- 3. Subtracts the bottom halfword of the second operand from the top halfword of the first operand.
- 4. Writes the unsigned result from the subtraction to the top halfword of the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
UASX R0, R4, R5 ; Adds top halfword of R4 to bottom halfword of R5 and 
                  ; writes to top halfword of R0
                  ; Subtracts bottom halfword of R5 from top halfword of R0
                  ; and writes to bottom halfword of R0
USAX R7, R3, R2 ; Subtracts top halfword of R2 from bottom halfword of R3 
                  ; and writes to bottom halfword of R7
                  ; Adds top halfword of R3 to bottom halfword of R2 and
```

PM0214 Rev 10 101/262

; writes to top halfword of R7.

## <span id="page-21-0"></span>**3.5.18 UHADD16 and UHADD8**

Unsigned Halving Add 16 and Unsigned Halving Add 8

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

- op is any of the following:
  - UHADD16: Unsigned halving add 16.
    - UHADD8: Unsigned halving add 8.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register.
- '*Rn*' is the register holding the first operand.
- '*Rm*' is the register holding the second operand.

### **Operation**

Use these instructions to add 16- and 8-bit data and then to halve the result before writing the result to the destination register:

The UHADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Shuffles the halfword result by one bit to the right, halving the data.
- 3. Writes the unsigned results to the corresponding halfword in the destination register.

# The UHADD8 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Shuffles the byte result by one bit to the right, halving the data.
- 3. Writes the unsigned results in the corresponding byte in the destination register.

## **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
UHADD16 R7, R3 ; Adds halfwords in R7 to corresponding halfword of R3 &
                  ; writes halved result to corresponding halfword in R7
UHADD8 R4, R0, R5 ; Adds bytes of R0 to corresponding byte in R5 and writes
                  ; halved result to corresponding byte in R4.
```

![](_page_21_Picture_32.jpeg)

# <span id="page-22-0"></span>**3.5.19 UHASX and UHSAX**

Unsigned Halving Add and Subtract with Exchange and Unsigned Halving Subtract and Add with Exchange.

### **Syntax**

```
op{cond} {Rd}, Rn, Rm
```

#### Where:

- op is one of the following:
  - UHASX: Add and subtract with exchange and halving.
  - UHSAX: Subtract and add with exchange and halving.
- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' '*Rm*' are registers holding the first and second operands.

### **Operation**

The UHASX instruction:

- 1. Adds the top halfword of the first operand to the bottom halfword of second operand.
- 2. Shifts the result by one bit to the right, causing a divide by two, or halving.
- 3. Writes the halfword result of the addition to the top halfword of the destination register.
- 4. Subtracts top halfword of second operand from bottom highword of the first operand.
- 5. Shifts the result by one bit to the right, causing a divide by two, or halving.
- 6. Writes halfword result of the division in the bottom halfword of the destination register.

## The UHSAX instruction:

- 1. Subtracts the bottom halfword of the second operand from the top highword of the first operand.
- 2. Shifts the result by one bit to the right, causing a divide by two, or halving.
- 3. Writes halfword result of the subtraction in the top halfword of the destination register.
- 4. Adds the bottom halfword of the first operand to the top halfword of the second operand.
- 5. Shifts the result by one bit to the right, causing a divide by two, or halving.
- 6. Writes halfword result of the addition to the bottom halfword of the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
UHASX R7, R4, R2 ; Adds top halfword of R4 with bottom halfword of R2 
                     ; and writes halved result to top halfword of R7
                     ; Subtracts top halfword of R2 from bottom halfword of 
                     ; R7 and writes halved result to bottom halfword of R7
```

PM0214 Rev 10 103/262

```
UHSAX R0, R3, R5 ; Subtracts bottom halfword of R5 from top halfword of 
                     ; R3 and writes halved result to top halfword of R0
                     ; Adds top halfword of R5 to bottom halfword of R3 and 
                     ; writes halved result to bottom halfword of R0.
```

# <span id="page-23-0"></span>**3.5.20 UHSUB16 and UHSUB8**

Unsigned Halving Subtract 16 and Unsigned Halving Subtract 8

# **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

• op is any of the following:

UHSUB16: Performs two unsigned 16-bit integer additions, halves the results, and writes the results to the destination register.

UHSUB8: Performs four unsigned 8-bit integer additions, halves the results, and writes the results to the destination register.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the first register holding the operand.
- '*Rm*' is the second register holding the operand.

### **Operation**

Use these instructions to add 16-bit and 8-bit data and then to halve the result before writing the result to the destination register:

The UHSUB16 instruction:

- 1. Subtracts each halfword of the second operand from the corresponding halfword of the first operand.
- 2. Shuffles each halfword result to the right by one bit, halving the data.
- 3. Writes each unsigned halfword result to corresponding halfword in destination register.

The UHSUB8 instruction:

- 1. Subtracts each byte of second operand from the corresponding byte of the first operand.
- 2. Shuffles each byte result by one bit to the right, halving the data.
- 3. Writes the unsigned byte results to the corresponding byte of the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
UHSUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding R1 halfword
               ; and writes halved result to corresponding halfword in R1
```

![](_page_23_Picture_32.jpeg)

UHSUB8 R4, R0, R5 ; Subtracts bytes of R5 from corresponding byte in R0 and ; writes halved result to corresponding byte in R4.

## **3.5.21 SEL**

Select bytes. Selects each byte of its result from either its first operand or its second operand, according to the values of the GE flags.

### **Syntax**

```
SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
```

#### Where:

- <c>, <q> are standard assembler syntax fields.
- <Rd> is the destination register.
- <Rn> is the first operand register.
- <Rm> is the second operand register.

### **Operation**

The SEL instruction:

- 1. Reads the value of each bit of APSR.GE.
- 2. Assigns the destination register the value of either the first or second operand register, depending on the value of APSR.GE.

### **Restrictions**

None.

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SADD16 R0, R1, R2 ; Set GE bits based on result
SEL R0, R0, R3 ; Select bytes from R0 or R3, based on GE.
```

PM0214 Rev 10 105/262

# <span id="page-25-0"></span>**3.5.22 USAD8**

Unsigned Sum of Absolute Differences

### **Syntax**

```
USAD8{cond}{Rd,} Rn, Rm
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the first operand register.
- '*Rm*' is the second operand register.

### **Operation**

The USAD8 instruction:

- 1. Subtracts each byte of the second operand register from the corresponding byte of the first operand register.
- 2. Adds the absolute values of the differences together.
- 3. Writes the result to the destination register.

### **Restrictions**

Do not use either SP or use PC.

# **Condition flags**

These instructions do not change the flags.

### **Examples**

```
USAD8 R1, R4, R0 ; Subtracts each byte in R0 from corresponding byte of
 ; R4 adds the differences and writes to R1
USAD8 R0, R5 ; Subtracts bytes of R5 from corresponding byte in R0, 
 ; adds the differences and writes to R0.
```

![](_page_25_Picture_23.jpeg)

# <span id="page-26-0"></span>**3.5.23 USADA8**

Unsigned Sum of Absolute Differences and Accumulate

### **Syntax**

```
USADA8{cond}{Rd,} Rn, Rm, Ra
```

#### Where:

- '*cond*' is an optional condition code (see *Conditional execution on page 65*).
- '*Rd*' is the destination register.
- '*Rn*' is the first operand register.
- '*Rm*' is the second operand register.
- '*Ra*' is the register that contains the accumulation value.

### **Operation**

The USADA8 instruction:

- 1. Subtracts each byte of the second operand register from the corresponding byte of the first operand register.
- 2. Adds the unsigned absolute differences together.
- 3. Adds the accumulation value to the sum of the absolute differences.
- 4. Writes the result to the destination register.

### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
USADA8 R1, R0, R6 ; Subtracts bytes in R0 from corresponding halfword of R1
                  ; adds differences, adds value of R6, writes to R1
USADA8 R4, R0, R5, R2 ; Subtracts bytes of R5 from corresponding byte in R0 
                  ; adds differences, adds value of R2 writes to R4.
```

PM0214 Rev 10 107/262

# <span id="page-27-0"></span>**3.5.24 USUB16 and USUB8**

Unsigned Subtract 16 and Unsigned Subtract 8

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
```

#### Where:

• op is any of:

USUB16: Unsigned Subtract 16.

USUB8: Unsigned Subtract 8.

- '*cond*' is an optional condition code (see *Conditional execution on page 65*)
- '*Rd*' is the destination register
- '*Rn*' is the register holding the operand
- '*Rm*' is the second operand register

### **Operation**

Use these instructions to subtract 16-bit and 8-bit data before writing the result to the destination register:

The USUB16 instruction:

- 1. Subtracts each halfword from the second operand register from the corresponding halfword of the first operand register.
- 2. Writes the unsigned result in the corresponding halfwords of the destination register.

The USUB8 instruction:

- 1. Subtracts each byte of the second operand register from the corresponding byte of the first operand register.
- 2. Writes the unsigned byte result in the corresponding byte of the destination register.

# **Restrictions**

Do not use either SP or PC.

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
USUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding halfword of
               ; R1 and writes to corresponding halfword in R1
USUB8 R4, R0, R5 ; Subtracts bytes of R5 from corresponding byte in R0 and 
                  ; writes to the corresponding byte in R4.
```

![](_page_27_Picture_29.jpeg)