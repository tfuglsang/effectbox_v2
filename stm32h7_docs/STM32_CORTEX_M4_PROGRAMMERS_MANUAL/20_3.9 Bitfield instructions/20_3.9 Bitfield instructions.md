### **Restrictions**

Do not use SP and do not use PC.

#### **Condition flags**

These instructions do not affect the flags.

## **Examples**

```
SXTAH R4, R8, R6, ROR #16 ; Rotates R6 right by 16 bits, obtains bottom
                     ; halfword, sign extends to 32 bits, adds R8,and 
                     ; writes to R4
UXTAB R3, R4, R10 ; Extracts bottom byte of R10 and zero extends to 32 
                     ; bits, adds R4, and writes to R3.
```

# **3.9 Bitfield instructions**

*[Table 32](#page-0-0)* shows the instructions that operate on adjacent sets of bits in registers or bitfields.

<span id="page-0-0"></span>**Mnemonic Brief description See** BFC Bit field clear *[BFC and BFI on page 139](#page-1-0)* BFI Bit field insert *[BFC and BFI on page 139](#page-1-0)* SBFX Signed bit field extract *[SBFX and UBFX on page 140](#page-2-0)* SXTB Sign extend a byte *[SXT and UXT on page 141](#page-3-0)* SXTH Sign extend a halfword *[SXT and UXT on page 141](#page-3-0)* UBFX Unsigned bit field extract *[SBFX and UBFX on page 140](#page-2-0)* UXTB Zero extend a byte *[SXT and UXT on page 141](#page-3-0)*

UXTH Zero extend a halfword *[SXT and UXT on page 141](#page-3-0)*

**Table 32. Instructions that operate on adjacent sets of bits** 

# <span id="page-1-0"></span>**3.9.1 BFC and BFI**

Bit Field Clear and Bit Field Insert.

## **Syntax**

```
BFC{cond} Rd, #lsb, #width
BFI{cond} Rd, Rn, #lsb, #width
```

#### Where:

- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rd*' is the destination register.
- '*Rn*' is the source register.
- *'lsb'* is the position of the least significant bit of the bitfield. *lsb* must be in the range 0 to 31.
- *'width'* is the width of the bitfield and must be in the range 1 to 32-*lsb*.

### **Operation**

BFC clears a bitfield in a register. It clears width bits in *Rd*, starting at the low bit position *lsb*. Other bits in *Rd* are unchanged.

BFI copies a bitfield into one register from another register. It replaces width bits in *Rd* starting at the low bit position *lsb*, with width bits from *Rn* starting at bit[0]. Other bits in *Rd* are unchanged.

## **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the flags.

#### **Examples**

```
 BFC R4, #8, #12 ; Clear bit 8 to bit 19 (12 bits) of R4 to 0
 BFI R9, R2, #8, #12 ; Replace bit 8 to bit 19 (12 bits) of R9 with
 ; bit 0 to bit 11 from R2
```

PM0214 Rev 10 139/262

# <span id="page-2-0"></span>**3.9.2 SBFX and UBFX**

Signed Bit Field Extract and Unsigned Bit Field Extract.

### **Syntax**

```
SBFX{cond} Rd, Rn, #lsb, #width
UBFX{cond} Rd, Rn, #lsb, #width
```

#### Where:

- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rd*' is the destination register.
- '*Rn*' is the source register.
- *'lsb'* is the position of the least significant bit of the bitfield. *lsb* must be in the range 0 to 31.
- *'width'* is the width of the bitfield and must be in the range 1 to 32-*lsb*.

### **Operation**

SBFX extracts a bitfield from one register, sign extends it to 32 bits, and writes the result to the destination register.

UBFX extracts a bitfield from one register, zero extends it to 32 bits, and writes the result to the destination register.

#### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the flags.

### **Examples**

```
SBFX R0, R1, #20, #4 ; Extract bit 20 to bit 23 (4 bits) from R1 and sign 
                     ; extend to 32 bits and then write the result to R0. 
UBFX R8, R11, #9, #10; Extract bit 9 to bit 18 (10 bits) from R11 and zero 
                     ; extend to 32 bits and then write the result to R8
```

# <span id="page-3-0"></span>**3.9.3 SXT and UXT**

Sign extend and Zero extend.

### **Syntax**

```
SXTextend{cond} {Rd,} Rm {, ROR #n}
UXTextend{cond} {Rd}, Rm {, ROR #n}
```

#### Where:

- 'extend' is one of:
  - B: Extends an 8-bit value to a 32-bit value.
  - H: Extends a 16-bit value to a 32-bit value.
- '*cond*' is an optional condition code, see *Conditional execution on page 65*.
- '*Rd*' is the destination register.
- *'Rm'* is the register holding the value to extend.
- ROR #*n* is one of:

```
ROR #8: Value from Rm is rotated right 8 bits.
```

ROR #16: Value from *Rm* is rotated right 16 bits.

ROR #24: Value from *Rm* is rotated right 24 bits.

If ROR #*n* is omitted, no rotation is performed.

#### **Operation**

These instructions do the following:

- 1. Rotate the value from *Rm* right by 0, 8, 16 or 24 bits.
- 2. Extract bits from the resulting value:
  - SXTB extracts bits[7:0] and sign extends to 32 bits.
    - UXTB extracts bits[7:0] and zero extends to 32 bits.
    - SXTH extracts bits[15:0] and sign extends to 32 bits.
    - UXTH extracts bits[15:0] and zero extends to 32 bits.

#### **Restrictions**

Do not use SP and do not use PC.

#### **Condition flags**

These instructions do not affect the flags.

#### **Examples**

```
SXTH R4, R6, ROR #16 ; Rotate R6 right by 16 bits, then obtain the lower
                      ; halfword of the result and then sign extend to
                      ; 32 bits and write the result to R4.
UXTB R3, R10 ; Extract lowest byte of the value in R10 and zero
                      ; extend it, and write the result to R3
```

![](_page_3_Picture_32.jpeg)

PM0214 Rev 10 141/262

# **3.9.4 Branch and control instructions**

*[Table 33](#page-4-0)* shows the branch and control instructions:

**Table 33. Branch and control instructions** 

<span id="page-4-0"></span>

| Mnemonic | Brief description                 | See                            |
|----------|-----------------------------------|--------------------------------|
| B        | Branch                            | B, BL, BX, and BLX on page 142 |
| BL       | Branch with Link                  | B, BL, BX, and BLX on page 142 |
| BLX      | Branch indirect with Link         | B, BL, BX, and BLX on page 142 |
| BX       | Branch indirect                   | B, BL, BX, and BLX on page 142 |
| CBNZ     | Compare and Branch if Non<br>Zero | CBZ and CBNZ on page 144       |
| CBZ      | Compare and Branch if Non<br>Zero | CBZ and CBNZ on page 144       |
| IT       | If-Then                           | IT on page 145                 |
| TBB      | Table Branch Byte                 | TBB and TBH on page 147        |
| TBH      | Table Branch Halfword             | TBB and TBH on page 147        |

## <span id="page-4-1"></span>**3.9.5 B, BL, BX, and BLX**

Branch instructions.

# **Syntax**

B{*cond*} *label* BL{*cond*} *label* BX{*cond*} *Rm* BLX{*cond*} *Rm*

## Where:

- 'B' is branch (immediate).
- 'BL' is branch with link (immediate).
- 'BX' is branch indirect (register).
- 'BLX' is branch indirect with link (register).
- *'cond'* is an optional condition code, see *Conditional execution on page 65*.
- *'label'* is a PC-relative expression. See *PC-relative expressions on page 65*.
- *'Rm'* is a register that indicates an address to branch to. Bit[0] of the value in *Rm* must be 1, but the address to branch to is created by changing bit[0] to 0.

#### **Operation**

All these instructions cause a branch to *label*, or to the address indicated in *Rm*. In addition:

- The BL and BLX instructions write the address of the next instruction to LR (the link register, R14).
- The BX and BLX instructions cause a UsageFault exception if bit[0] of *Rm* is 0.

![](_page_4_Picture_23.jpeg)

B *cond label* is the only conditional instruction that can be either inside or outside an IT block. All other branch instructions must be conditional inside an IT block, and must be unconditional outside the IT block, see *[IT on page 145](#page-7-0)*.

*[Table 34](#page-5-0)* shows the ranges for the various branch instructions.

**Table 34. Branch ranges** 

<span id="page-5-0"></span>

| Instruction                    | Branch range          |
|--------------------------------|-----------------------|
| B label                        | −16 MB to +16 MB      |
| Bcond label (outside IT block) | −1 MB to +1 MB        |
| Bcond label (inside IT block)  | −16 MB to +16 MB      |
| BL{cond} label                 | −16 MB to +16 MB      |
| BX{cond} Rm                    | Any value in register |
| BLX{cond} Rm                   | Any value in register |

You might have to use the .W suffix to get the maximum branch range. See *Instruction width selection on page 68*.

#### **Restrictions**

The restrictions are:

- Do not use PC in the BLX instruction
- For BX and BLX, bit[0] of *Rm* must be 1 for correct execution but a branch occurs to the target address created by changing bit[0] to 0
- When any of these instructions is inside an IT block, it must be the last instruction of the IT block.

B*cond* is the only conditional instruction that is not required to be inside an IT block. However, it has a longer branch range when it is inside an IT block.

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
B loopA ; Branch to loopA
BLE ng ; Conditionally branch to label ng
B.W target ; Branch to target within 16MB range
BEQ target ; Conditionally branch to target
BEQ.W target ; Conditionally branch to target within 1MB
BL funC ; Branch with link (Call) to function funC, return address
 ; stored in LR
BX LR ; Return from function call
BXNE R0 ; Conditionally branch to address stored in R0
```

![](_page_5_Picture_17.jpeg)

PM0214 Rev 10 143/262

```
BLX R0 ; Branch with link and exchange (Call) to a address stored
 ; in R0
```

## <span id="page-6-0"></span>**3.9.6 CBZ and CBNZ**

Compare and Branch on Zero, Compare and Branch on Non-Zero.

#### **Syntax**

```
CBZ Rn, label
CBNZ Rn, label
```

#### Where:

- *'Rn'* is the register holding the operand.
- *'label'* is the branch destination.

## **Operation**

Use the CBZ or CBNZ instructions to avoid changing the condition code flags and to reduce the number of instructions.

CBZ Rn, label does not change condition flags but is otherwise equivalent to:

```
 CMP Rn, #0
 BEQ label
```

CBNZ Rn, label does not change condition flags but is otherwise equivalent to:

```
 CMP Rn, #0
 BNE label
```

#### **Restrictions**

The restrictions are:

- *Rn* must be in the range of R0 to R7.
- The branch destination must be within 4 to 130 bytes after the instruction.
- These instructions must not be used inside an IT block.

#### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
CBZ R5, target ; Forward branch if R5 is zero
CBNZ R0, target ; Forward branch if R0 is not zero
```

# <span id="page-7-0"></span>**3.9.7 IT**

If-Then condition instruction.

# **Syntax**

IT{*x*{*y*{*z*}}} *cond*

#### Where:

- *'x'* specifies the condition switch for the second instruction in the IT block.
- *'y'* specifies the condition switch for the third instruction in the IT block.
- *'z'* specifies the condition switch for the fourth instruction in the IT block.
- *'cond'* specifies the condition for the first instruction in the IT block.

The condition switch for the second, third and fourth instruction in the IT block can be either:

- T: Then. Applies the condition *cond* to the instruction.
- E: Else. Applies the inverse condition of *cond* to the instruction.
- a) It is possible to use AL (the *always* condition) for *cond* in an IT instruction. If this is done, all of the instructions in the IT block must be unconditional, and each of *x*, *y*, and *z* must be T or omitted but not E.

#### **Operation**

The IT instruction makes up to four following instructions conditional. The conditions can be all the same, or some of them can be the logical inverse of the others. The conditional instructions following the IT instruction form the *IT block*.

The instructions in the IT block, including any branches, must specify the condition in the *{cond}* part of their syntax.

Your assembler might be able to generate the required IT instructions for conditional instructions automatically, so that you do not need to write them yourself. See your assembler documentation for details.

A BKPT instruction in an IT block is always executed, even if its condition fails.

Exceptions can be taken between an IT instruction and the corresponding IT block, or within an IT block. Such an exception results in entry to the appropriate exception handler, with suitable return information in LR and stacked PSR.

Instructions designed for use for exception returns can be used as normal to return from the exception, and execution of the IT block resumes correctly. This is the only way that a PCmodifying instruction is permitted to branch to an instruction in an IT block.

## **Restrictions**

The following instructions are not permitted in an IT block:

- IT
- CBZ and CBNZ
- CPSID and CPSIE.

![](_page_7_Picture_27.jpeg)

PM0214 Rev 10 145/262

Other restrictions when using an IT block are:

- a branch or any instruction that modifies the PC must either be outside an IT block or must be the last instruction inside the IT block. These are:
  - ADD PC, PC, Rm
  - MOV PC, Rm
  - B, BL, BX, BLX
  - any LDM, LDR, or POP instruction that writes to the PC
  - TBB and TBH
- Do not branch to any instruction inside an IT block, except when returning from an exception handler
- All conditional instructions except B*cond* must be inside an IT block. B*cond* can be either outside or inside an IT block but has a larger branch range if it is inside one
- Each instruction inside the IT block must specify a condition code suffix that is either the same or logical inverse as for the other instructions in the block.

Your assembler might place extra restrictions on the use of IT blocks, such as prohibiting the use of assembler directives within them.

### **Condition flags**

This instruction does not change the flags.

## **Example**

```
 ITTE NE ; Next 3 instructions are conditional
 ANDNE R0, R0, R1 ; ANDNE does not update condition flags
 ADDSNE R2, R2, #1 ; ADDSNE updates condition flags
 MOVEQ R2, R3 ; Conditional move
 CMP R0, #9 ; Convert R0 hex value (0 to 15) into ASCII 
 ; ('0'-'9', 'A'-'F')
 ITE GT ; Next 2 instructions are conditional
 ADDGT R1, R0, #55 ; Convert 0xA -> 'A'
 ADDLE R1, R0, #48 ; Convert 0x0 -> '0'
 IT GT ; IT block with only one conditional instruction
 ADDGT R1, R1, #1 ; Increment R1 conditionally
 ITTEE EQ ; Next 4 instructions are conditional
 MOVEQ R0, R1 ; Conditional move
 ADDEQ R2, R2, #10 ; Conditional add
 ANDNE R3, R3, #1 ; Conditional AND
 BNE.W dloop ; Branch instruction can only be used in the last
 ; instruction of an IT block
 IT NE ; Next instruction is conditional
 ADD R0, R0, R1 ; Syntax error: no condition code used in IT block
```

![](_page_8_Picture_18.jpeg)

# <span id="page-9-0"></span>**3.9.8 TBB and TBH**

Table Branch Byte and Table Branch Halfword.

### **Syntax**

```
TBB [Rn, Rm]
TBH [Rn, Rm, LSL #1]
```

#### Where:

- *'Rn'* is the register containing the address of the table of branch lengths. If *Rn* is PC, then the address of the table is the address of the byte immediately following the TBB or TBH instruction.
- *'Rm'* is the index register. This contains an index into the table. For halfword tables, LSL #1 doubles the value in *Rm* to form the right offset into the table.

#### **Operation**

These instructions cause a PC-relative forward branch using a table of single byte offsets for TBB, or halfword offsets for TBH. *Rn* provides a pointer to the table, and *Rm* supplies an index into the table. For TBB the branch offset is twice the unsigned value of the byte returned from the table. and for TBH the branch offset is twice the unsigned value of the halfword returned from the table. The branch occurs to the address at that offset from the address of the byte immediately after the TBB or TBH instruction.

### **Restrictions**

The restrictions are:

- *Rn* must not be SP
- *Rm* must not be SP and must not be PC
- When any of these instructions is used inside an IT block, it must be the last instruction of the IT block.

#### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
ADR.W R0, BranchTable_Byte
TBB [R0, R1] ; R1 is the index, R0 is the base address of the branch table
Case1
           ; an instruction sequence follows
Case2
           ; an instruction sequence follows
Case3
           ; an instruction sequence follows
BranchTable_Byte
 DCB 0 ; Case1 offset calculation
 DCB ((Case2-Case1)/2) ; Case2 offset calculation
 DCB ((Case3-Case1)/2) ; Case3 offset calculation
 TBH [PC, R1, LSL #1] ; R1 is the index, PC is used as base of the
 ; branch table
```

PM0214 Rev 10 147/262

```
BranchTable_H
 DCI ((CaseA - BranchTable_H)/2) ; CaseA offset calculation
 DCI ((CaseB - BranchTable_H)/2) ; CaseB offset calculation
 DCI ((CaseC - BranchTable_H)/2) ; CaseC offset calculation
CaseA
          ; an instruction sequence follows
CaseB
          ; an instruction sequence follows
CaseC
          ; an instruction sequence follows
```