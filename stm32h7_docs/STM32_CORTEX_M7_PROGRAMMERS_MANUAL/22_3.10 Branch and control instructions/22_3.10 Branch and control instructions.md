# **3.10 Branch and control instructions**

*[Table](#page-0-0) 35* shows the branch and control instructions:

**Table 35. Branch and control instructions** 

<span id="page-0-0"></span>

| Mnemonic | Brief description              | See                            |
|----------|--------------------------------|--------------------------------|
| B        | Branch                         | B, BL, BX, and BLX on page 145 |
| BL       | Branch with Link               | B, BL, BX, and BLX on page 145 |
| BLX      | Branch indirect with Link      | B, BL, BX, and BLX on page 145 |
| BX       | Branch indirect                | B, BL, BX, and BLX on page 145 |
| CBNZ     | Compare and Branch if Non Zero | CBZ and CBNZ on page 147       |
| CBZ      | Compare and Branch if Zero     | CBZ and CBNZ on page 147       |
| IT       | If-Then                        | IT on page 148                 |
| TBB      | Table Branch Byte              | TBB and TBH on page 150        |
| TBH      | Table Branch Halfword          | TBB and TBH on page 150        |

### <span id="page-0-1"></span>**3.10.1 B, BL, BX, and BLX**

Branch instructions.

### **Syntax**

B{*cond*} label BL{*cond*} label BX{*cond*} *Rm* BLX{*cond*} *Rm*

### Where:

B Is branch (immediate). BL Is branch with link (immediate). BX Is branch indirect (register). BLX Is branch indirect with link (register). *cond* Is an optional condition code. See *Conditional execution on page 68*. *label* Is a PC-relative expression. See *PC-relative expressions on page 68*.

*Rm* Is a register that indicates an address to branch to. Bit[0] of the value in *Rm* must be 1, but the address to branch to is created by changing bit[0] to 0.

### **Operation**

All these instructions cause a branch to *label*, or to the address indicated in *Rm*. In addition:

- The BL and BLX instructions write the address of the next instruction to LR (the link register, R14).
- The BX and BLX instructions result in a UsageFault exception if bit[0] of *Rm* is 0.

![](_page_0_Picture_17.jpeg)

PM0253 Rev 5 145/254

B*cond* label is the only conditional instruction that can be either inside or outside an IT block. All other branch instructions must be conditional inside an IT block, and must be unconditional outside the IT block, see *[IT on page](#page-3-0) 148*.

*[Table](#page-1-0) 36* shows the ranges for the various branch instructions

**Table 36. Branch ranges** 

<span id="page-1-0"></span>

| Instruction                    | Branch range          |
|--------------------------------|-----------------------|
| B label                        | −16 MB to +16 MB      |
| Bcond label (outside IT block) | −1 MB to +1 MB        |
| Bcond label (inside IT block)  | −16 MB to +16 MB      |
| BL{cond} label                 | −16 MB to +16 MB      |
| BX{cond} Rm                    | Any value in register |
| BLX{cond} Rm                   | Any value in register |

The user might have to use the .W suffix to get the maximum branch range. See *Instruction width selection on page 71*.

### **Restrictions**

The restrictions are:

- Do not use PC in the BLX instruction.
- For BX and BLX, bit[0] of *Rm* must be 1 for correct execution but a branch occurs to the target address created by changing bit[0] to 0.
- When any of these instructions is inside an IT block, it must be the last instruction of the IT block.

B*cond* is the only conditional instruction that is not required to be inside an IT block. However, it has a longer branch range when it is inside an IT block.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
B loopA ; Branch to loopA
BLE ng ; Conditionally branch to label ng
B.W target ; Branch to target within 16MB range
BEQ target ; Conditionally branch to target
BEQ.W target ; Conditionally branch to target within 1MB
BL funC ; Branch with link (Call) to function funC, return 
            ; address stored in LR
BX LR ; Return from function call
BXNE R0 ; Conditionally branch to address stored in R0
BLX R0 ; Branch with link and exchange (Call) to a address
            ; stored in R0.
```

146/254 PM0253 Rev 5

![](_page_1_Picture_18.jpeg)

## <span id="page-2-0"></span>**3.10.2 CBZ and CBNZ**

Compare and Branch on Zero, Compare and Branch on Non-Zero.

### **Syntax**

```
CBZ Rn, label
CBNZ Rn, label
Where:
Rn Is the register holding the operand.
label Is the branch destination.
```

### **Operation**

Use the CBZ or CBNZ instructions to avoid changing the condition code flags and to reduce the number of instructions.

```
CBZ Rn, label does not change condition flags but is otherwise equivalent to:
```

```
CMP Rn, #0
    BEQ label
CBNZ Rn, label does not change condition flags but is otherwise equivalent to:
    CMP Rn, #0
    BNE label
```

### **Restrictions**

The restrictions are:

- *Rn* must be in the range of R0 to R7.
- The branch destination must be within 4 to 130 bytes after the instruction.
- These instructions must not be used inside an IT block.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
CBZ R5, target ; Forward branch if R5 is zero
CBNZ R0, target ; Forward branch if R0 is not zero
```

PM0253 Rev 5 147/254

## <span id="page-3-0"></span>**3.10.3 IT**

If-Then condition instruction.

### **Syntax**

```
IT{x{y{z}}} cond
```

#### Where:

*x* specifies the condition switch for the second instruction in the IT block. *y* Specifies the condition switch for the third instruction in the IT block. *z* Specifies the condition switch for the fourth instruction in the IT block.

*cond* Specifies the condition for the first instruction in the IT block.

The condition switch for the second, third and fourth instruction in the IT block can be either:

T Then. Applies the condition *cond* to the instruction.

E Else. Applies the inverse condition of *cond* to the instruction.

It is possible to use AL (the *always* condition) for *cond* in an IT instruction. If this is done, all of the instructions in the IT block must be unconditional, and each of *x*, *y*, and *z* must be T or omitted but not E.

### **Operation**

The IT instruction makes up to four following instructions conditional. The conditions can be all the same, or some of them can be the logical inverse of the others. The conditional instructions following the IT instruction form the *IT block*.

The instructions in the IT block, including any branches, must specify the condition in the {*cond*} part of their syntax.

The assembler might be able to generate the required IT instructions for conditional instructions automatically, so it is not needed to write them yourself. See the assembler documentation for details.

A BKPT instruction in an IT block is always executed, even if its condition fails.

Exceptions can be taken between an IT instruction and the corresponding IT block, or within an IT block. Such an exception results in entry to the appropriate exception handler, with suitable return information in LR and stacked PSR.

Instructions designed for use for exception returns can be used as normal to return from the exception, and execution of the IT block resumes correctly. This is the only way that a PC-modifying instruction is permitted to branch to an instruction in an IT block.

### **Restrictions**

The following instructions are not permitted in an IT block:

- IT.
- CBZ and CBNZ.
- CPSID and CPSIE.

148/254 PM0253 Rev 5

Other restrictions when using an IT block are:

- A branch or any instruction that modifies the PC must either be outside an IT block or must be the last instruction inside the IT block. These are:
  - ADD PC, PC, Rm.
  - MOV PC, Rm.
  - B, BL, BX, BLX.
  - Any LDM, LDR, or POP instruction that writes to the PC.
  - TBB and TBH.
- Do not branch to any instruction inside an IT block, except when returning from an exception handler
- All conditional instructions except B*cond* must be inside an IT block. B*cond* can be either outside or inside an IT block but has a larger branch range if it is inside one
- Each instruction inside the IT block must specify a condition code suffix that is either the same or logical inverse as for the other instructions in the block.

The assembler might place extra restrictions on the use of IT blocks, such as prohibiting the use of assembler directives within them.

### **Condition flags**

This instruction does not change the flags.

# **Example**

```
ITTE NE ; Next 3 instructions are conditional
ANDNE R0, R0, R1 ; ANDNE does not update condition flags
ADDSNE R2, R2, #1 ; ADDSNE updates condition flags
MOVEQ R2, R3 ; Conditional move
CMP R0, #9 ; Convert R0 hex value (0 to 15) into ASCII 
                 ; ('0'-'9', 'A'-'F')
ITE GT ; Next 2 instructions are conditional
ADDGT R1, R0, #55 ; Convert 0xA -> 'A'
ADDLE R1, R0, #48 ; Convert 0x0 -> '0'
IT GT ; IT block with only one conditional instruction
ADDGT R1, R1, #1 ; Increment R1 conditionally
ITTEE EQ ; Next 4 instructions are conditional
MOVEQ R0, R1 ; Conditional move
ADDEQ R2, R2, #10 ; Conditional add
ANDNE R3, R3, #1 ; Conditional AND
BNE.W dloop ; Branch instruction can only be used in the last
                 ; instruction of an IT block
IT NE ; Next instruction is conditional
ADD R0, R0, R1 ; Syntax error: no condition code used in IT block
```

PM0253 Rev 5 149/254

## <span id="page-5-0"></span>**3.10.4 TBB and TBH**

Table Branch Byte and Table Branch Halfword.

### **Syntax**

```
TBB [Rn, Rm]
TBH [Rn, Rm, LSL #1]
```

#### Where:

*Rn* Is the register containing the address of the table of branch lengths.

If *Rn* is PC, then the address of the table is the address of the byte immediately following the TBB or TBH instruction.

*Rm* Is the index register. This contains an index into the table. For halfword tables, LSL #1 doubles the value in *Rm* to form the right offset into the table.

### **Operation**

These instructions cause a PC-relative forward branch using a table of single byte offsets for TBB, or halfword offsets for TBH. *Rn* provides a pointer to the table, and *Rm* supplies an index into the table. For TBB the branch offset is twice the unsigned value of the byte returned from the table, and for TBH the branch offset is twice the unsigned value of the halfword returned from the table. The branch occurs to the address at that offset from the address of the byte immediately after the TBB or TBH instruction.

### **Restrictions**

The restrictions are:

- *Rn* must not be SP.
- *Rm* must not be SP and must not be PC.
- When any of these instructions is used inside an IT block, it must be the last instruction of the IT block.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
ADR.W R0, BranchTable_Byte
   TBB [R0, R1] ; R1 is the index, R0 is the base address of
                         ; the branch table
Case1
; an instruction sequence follows
Case2
; an instruction sequence follows
Case3
; an instruction sequence follows
BranchTable_Byte
   DCB 0 ; Case1 offset calculation
   DCB ((Case2-Case1)/2) ; Case2 offset calculation
   DCB ((Case3-Case1)/2) ; Case3 offset calculation
   TBH [PC, R1, LSL #1] ; R1 is the index, PC is used as base of the
```

150/254 PM0253 Rev 5

![](_page_5_Picture_22.jpeg)