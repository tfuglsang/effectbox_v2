# **Condition flags**

These instructions do not affect the condition code flags.

# **Examples**

```
UQADD16 R7, R4, R2 ; Adds halfwords in R4 to corresponding halfword in 
 ; R2, saturates to 16 bits, writes to corresponding 
 ; halfword of R7
UQADD8 R4, R2, R5 ; Adds bytes of R2 to corresponding byte of R5,
 ; saturates to 8 bits, writes to corresponding bytes 
                 ; of R4
UQSUB16 R6, R3, R0 ; Subtracts halfwords in R0 from corresponding 
 ; halfword in R3, saturates to 16 bits, writes to
 ; corresponding halfword in R6
UQSUB8 R1, R5, R6 ; Subtracts bytes in R6 from corresponding byte of
 ; R5, saturates to 8 bits, writes to corresponding 
                 ; byte of R1.
```

# **3.8 Packing and unpacking instructions**

*[Table](#page-0-0) 33* shows the instructions that operate on packing and unpacking data:

**Table 33. Packing and unpacking instructions** 

<span id="page-0-0"></span>

| Mnemonic | Brief description                     | See                         |
|----------|---------------------------------------|-----------------------------|
| PKH      | Pack Halfword                         | PKHBT and PKHTB on page 138 |
| SXTAB    | Extend 8 bits to 32 and add           | SXTA and UXTA on page 140   |
| SXTAB16  | Dual extend 8 bits to 16 and add      | SXTA and UXTA on page 140   |
| SXTAH    | Extend 16 bits to 32 and add          | SXTA and UXTA on page 140   |
| SXTB     | Sign extend a byte                    | SXT and UXT on page 144     |
| SXTB16   | Dual extend 8 bits to 16 and add      | SXT and UXT on page 144     |
| SXTH     | Sign extend a halfword                | SXT and UXT on page 144     |
| UXTAB    | Extend 8 bits to 32 and add           | SXTA and UXTA on page 140   |
| UXTAB16  | Dual extend 8 bits to 16 and add      | SXTA and UXTA on page 140   |
| UXTAH    | Extend 16 bits to 32 and add          | SXTA and UXTA on page 140   |
| UXTB     | Zero extend a byte                    | SXT and UXT on page 144     |
| UXTB16   | Dual zero extend 8 bits to 16 and add | SXT and UXT on page 144     |
| UXTH     | Zero extend a halfword                | SXT and UXT on page 144     |

![](_page_0_Picture_10.jpeg)

PM0253 Rev 5 137/254

# <span id="page-1-0"></span>**3.8.1 PKHBT and PKHTB**

Pack Halfword.

# **Syntax**

```
op{cond} {Rd}, Rn, Rm {, LSL #imm}
op{cond} {Rd}, Rn, Rm {, ASR #imm}
```

#### Where:

op Is one of:

PKHBT Pack Halfword, bottom and top with shift. PKHTB Pack Halfword, top and bottom with shift.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register. *Rn* Is the first operand register.

*Rm* Is the second operand register holding the value to be optionally shifted.

*imm* Is the shift length. The type of shift length depends on the instruction:

For PKHBT

LSL A left shift with a shift length from 1 to 31, 0 means no shift.

For PKHTB:

ASR An arithmetic shift right with a shift length from 1 to 32, a shift of 32-bits is encoded as 0b00000.

#### **Operation**

#### The PKHBT instruction:

- 1. Writes the value of the bottom halfword of the first operand to the bottom halfword of the destination register.
- 2. If shifted, the shifted value of the second operand is written to the top halfword of the destination register.

#### The PKHTB instruction:

- 1. Writes the value of the top halfword of the first operand to the top halfword of the destination register.
- 2. If shifted, the shifted value of the second operand is written to the bottom halfword of the destination register.

### **Restrictions**

*Rd* must not be SP and must not be PC.

#### **Condition flags**

This instruction does not change the flags.

138/254 PM0253 Rev 5

![](_page_1_Picture_29.jpeg)

#### **Examples**

```
PKHBT R3, R4, R5 LSL #0 ; Writes bottom halfword of R4 to bottom 
 ; halfworfd of R3, writes top halfword of R5, 
                ; unshifted, to top halfword of R3
PKHTB R4, R0, R2 ASR #1 ; Writes R2 shifted right by 1 bit to bottom 
 ; halfword of R4, and writes top halfword of R0 
 ; to top halfword of R4.
```

# **3.8.2 SXT and UXT**

Sign extend and Zero extend.

### **Syntax**

```
op{cond} {Rd,} Rm {, ROR #n}
op{cond} {Rd}, Rm {, ROR #n}
Where:
op Is one of:
           SXTB Sign extends an 8-bit value to a 32-bit value.
           SXTH Sign extends a 16-bit value to a 32-bit value.
           SXTB16 Sign extends two 8-bit values to two 16-bit values.
           UXTB Zero extends an 8-bit value to a 32-bit value.
           UXTH Zero extends a 16-bit value to a 32-bit value.
           UXTB16 Zero extends two 8-bit values to two 16-bit values.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rm Is the register holding the value to extend.
ROR #n Is one of:
           ROR #8 Value from Rm is rotated right 8 bits.
           ROR #16 Value from Rm is rotated right 16 bits.
```

### **Operation**

These instructions do the following:

- 1. Rotate the value from *Rm* right by 0, 8, 16 or 24 bits.
- 2. Extract bits from the resulting value:
  - SXTB extracts bits[7:0] and sign extends to 32 bits.

ROR #24 Value from *Rm* is rotated right 24 bits. If ROR #*n* is omitted, no rotation is performed.

- UXTB extracts bits[7:0] and zero extends to 32 bits.
- SXTH extracts bits[15:0] and sign extends to 32 bits.
- UXTH extracts bits[15:0] and zero extends to 32 bits.
- SXTB16 extracts bits[7:0] and sign extends to 16 bits, and extracts bits [23:16] and sign extends to 16 bits.
- UXTB16 extracts bits[7:0] and zero extends to 16 bits, and extracts bits [23:16] and zero extends to 16 bits.

![](_page_2_Picture_18.jpeg)

PM0253 Rev 5 139/254

### **Restrictions**

Do not use SP and do not use PC.

# **Condition flags**

These instructions do not affect the flags.

# **Examples**

```
SXTH R4, R6, ROR #16 ; Rotates R6 right by 16 bits, obtains bottom 
                      ; halfword of result, sign extends to 32 bits and 
                      ; writes to R4
UXTB R3, R10 ; Extracts lowest byte of value in R10, zero 
                      ; extends, and writes to R3.
```

# <span id="page-3-0"></span>**3.8.3 SXTA and UXTA**

Signed and Unsigned Extend and Add.

#### **Syntax**

```
op{cond} {Rd,} Rn, Rm {, ROR #n}
op{cond} {Rd,} Rn, Rm {, ROR #n}
Where:
op Is one of:
            SXTAB Sign extends an 8-bit value to a 32-bit value and add.
            SXTAH Sign extends a 16-bit value to a 32-bit value and add.
            SXTAB16 Sign extends two 8-bit values to two 16-bit values and add.
            UXTAB Zero extends an 8-bit value to a 32-bit value and add.
            UXTAH Zero extends a 16-bit value to a 32-bit value and add.
            UXTAB16 Zero extends two 8-bit values to two 16-bit values and add.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first operand register.
Rm Is the register holding the value to rotate and extend.
ROR #n Is one of:
            ROR #8 Value from Rm is rotated right 8 bits.
            ROR #16 Value from Rm is rotated right 16 bits.
            ROR #24 Value from Rm is rotated right 24 bits.
            If ROR #n is omitted, no rotation is performed.
```

#### **Operation**

These instructions do the following:

- 1. Rotate the value from *Rm* right by 0, 8, 16 or 24 bits.
- 2. Extract bits from the resulting value:
  - SXTAB extracts bits[7:0] from *Rm* and sign extends to 32 bits.
  - UXTAB extracts bits[7:0] from *Rm* and zero extends to 32 bits.

140/254 PM0253 Rev 5

![](_page_3_Picture_19.jpeg)