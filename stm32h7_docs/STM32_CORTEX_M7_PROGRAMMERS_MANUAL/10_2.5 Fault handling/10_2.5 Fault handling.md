# **2.5 Fault handling**

Faults are a subset of the exceptions, see *Exception model on page 39*. Faults are generated by:

- A bus error on:
  - An instruction fetch or vector table load.
  - A data access.
- An internally-detected error such as an undefined instruction.
- Attempting to execute an instruction from a memory region marked as *Execute Never* (XN).
- A privilege violation or an attempt to access an unmanaged region causing an MPU fault.

#### **2.5.1 Fault types**

*[Table](#page-0-0) 21* shows the types of fault, the handler used for the fault, the corresponding fault status register, and the register bit that indicates that the fault has occurred. See *Configuration and control register on page 200* for more information about the fault status registers

<span id="page-0-0"></span>**Table 21. Faults Fault Handler Bit name Fault status register** HardFault VECTTBL *HardFault status register on* 

| Bus error on a vector read                       | HardFault | VECTTBL      | HardFault status register on<br>page 210       |
|--------------------------------------------------|-----------|--------------|------------------------------------------------|
| Fault escalated to a hard fault                  |           | FORCED       |                                                |
| MPU or default memory map mismatch:              | MemManage | -            | -                                              |
| On instruction access                            |           | IACCVIOL (1) | MemManage fault status register on<br>page 206 |
| On data access                                   |           | DACCVIOL     |                                                |
| During exception stacking                        |           | MSTKERR      |                                                |
| During exception unstacking                      |           | MUNSKERR     |                                                |
| During lazy floating-point state<br>preservation |           | MLSPERR      |                                                |
| Bus error:                                       |           | -            | -                                              |
| During exception stacking                        |           | STKERR       | BusFault status register on page 207           |
| During exception unstacking                      | BusFault  | UNSTKERR     |                                                |
| During instruction prefetch                      |           | IBUSERR      |                                                |
| During lazy floating-point state<br>preservation |           | LSPERR       |                                                |
| Precise data bus error                           |           | PRECISERR    |                                                |
| Imprecise data bus error                         |           | IMPRECISERR  |                                                |

![](_page_0_Picture_14.jpeg)

PM0253 Rev 5 47/254

| Fault                                                    | Handler    | Bit name   | Fault status register         |
|----------------------------------------------------------|------------|------------|-------------------------------|
| Attempt to access a coprocessor                          | UsageFault | NOCP       | UsageFault status register on |
| Undefined instruction                                    |            | UNDEFINSTR | page 209                      |
| Attempt to enter an invalid instruction set<br>state (2) |            | INVSTATE   |                               |
| Invalid EXC_RETURN value                                 |            | INVPC      |                               |
| Illegal unaligned load or store                          |            | UNALIGNED  |                               |
| Divide By 0                                              |            | DIVBYZERO  |                               |

**Table 21. Faults (continued)**

## **2.5.2 Fault escalation and hard faults**

All the fault exceptions except for HardFault have configurable exception priority, see *System handler priority registers on page 202*. the software can disable the execution of the handlers for these faults, see *System handler control and state register on page 204*.

Usually, the exception priority, together with the values of the exception mask registers, determines whether the processor enters the fault handler, and whether a fault handler can preempt another fault handler. as described in *Exception model on page 39*.

In some situations, a fault with configurable priority is treated as a HardFault. This is called *priority escalation*, and the fault is described as *escalated to HardFault*. Escalation to HardFault occurs when:

- A fault handler causes the same kind of fault as the one it is servicing. This escalation to HardFault occurs because a fault handler cannot preempt itself because it must have the same priority as the current priority level.
- A fault handler causes a fault with the same or lower priority as the fault it is servicing. This is because the handler for the new fault cannot preempt the currently executing fault handler.
- An exception handler causes a fault for which the priority is the same as or lower than the currently executing exception.
- A fault occurs and the handler for that fault is not enabled.

If a BusFault occurs during a stack push when entering a BusFault handler, the BusFault does not escalate to a HardFault. This means that if a corrupted stack causes a fault, the fault handler executes even though the stack push for the handler failed. The fault handler operates but the stack contents are corrupted.

*Note: Only Reset and NMI can preempt the fixed priority HardFault. A HardFault can preempt any exception other than Reset, NMI, or another HardFault.*

48/254 PM0253 Rev 5

![](_page_1_Picture_17.jpeg)

<sup>1.</sup> Occurs on an access to an XN region even if the processor does not include an MPU or the MPU is disabled.

<sup>2.</sup> Attempting to use an instruction set other than the Thumb instruction set or returns to a non load/store-multiple instruction with ICI continuation.

#### **2.5.3 Synchronous and Asynchronous bus faults**

In the CortexÂ®-M7 processor all bus faults triggered by:

- Processor load operations are synchronous.
- Processor store operations are asynchronous, including stores to Device and Stronglyordered regions.
- Debugger load or store accesses are synchronous, and are visible to the debugger interface only.

When an asynchronous bus fault is triggered, the BusFault exception is pended. If the BusFault handler is not enabled, the HardFault exception is pended instead. The HardFault caused by the asynchronous BusFault never escalates into lockup.

If an IRQ is triggered after the write, the write buffer might not drain before the ISR is executed. Therefore an asynchronous BusFault can occur across context boundaries.

A synchronous BusFault can escalate into lockup if it occurs inside a NMI or HardFault handler.

Cache maintenance operations can also trigger a bus fault. See *Faults handling considerations on page 244* for more information.

### **2.5.4 Fault status registers and fault address registers**

The fault status registers indicate the cause of a fault. For synchronous BusFaults and MemManage faults, the fault address register indicates the address accessed by the operation that caused the fault, as shown in *[Table](#page-2-0) 22*.

<span id="page-2-0"></span>

| Handler    | Status register<br>name | Address register<br>name | Register description                                                                           |
|------------|-------------------------|--------------------------|------------------------------------------------------------------------------------------------|
| HardFault  | HFSR                    | -                        | HardFault status register on page 210                                                          |
| MemManage  | MMFSR                   | MMFAR                    | MemManage fault status register on page 206<br>MemManage fault address register on<br>page 211 |
| BusFault   | BFSR                    | BFAR                     | BusFault status register on page 207<br>BusFault address register on page 212                  |
| UsageFault | UFSR                    | -                        | UsageFault status register on page 209                                                         |

**Table 22. Fault status and fault address registers** 

#### **2.5.5 Lockup**

The processor enters a lockup state if a fault occurs when executing the NMI or HardFault handlers. When the processor is in lockup state it does not execute any instructions. The processor remains in lockup state until either:

- It is reset.
- An NMI occurs.
- It is halted by a debugger.

*Note: If a lockup state occurs from the NMI handler a subsequent NMI does not cause the processor to leave lockup state.*

PM0253 Rev 5 49/254