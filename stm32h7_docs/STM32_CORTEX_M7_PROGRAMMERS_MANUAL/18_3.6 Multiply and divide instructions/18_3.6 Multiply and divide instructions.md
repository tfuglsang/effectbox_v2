- 1. Subtracts each byte of the second operand register from the corresponding byte of the first operand register.
- 2. Writes the unsigned byte result in the corresponding byte of the destination register.

### **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
USUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding halfword
 ; of R1 and writes to corresponding halfword in R1.
USUB8 R4, R0, R5 ; Subtracts bytes of R5 from corresponding byte in R0 
 ; and writes to the corresponding byte in R4.
```

# **3.6 Multiply and divide instructions**

*[Table](#page-0-0) 31* shows the multiply and divide instructions:

**Table 31. Multiply and divide instructions** 

<span id="page-0-0"></span>

| Mnemonic           | Brief description                                            | See                                           |
|--------------------|--------------------------------------------------------------|-----------------------------------------------|
| MLA                | Multiply with Accumulate, 32-bit result                      | MUL, MLA, and MLS on page 112                 |
| MLS                | Multiply and Subtract, 32-bit result                         | MUL, MLA, and MLS on page 112                 |
| MUL                | Multiply, 32-bit result                                      | MUL, MLA, and MLS on page 112                 |
| SDIV               | Signed Divide                                                | SDIV and UDIV on page 127                     |
| SMLA[B,T]          | Signed Multiply Accumulate (halfwords)                       | SMMLA and SMMLS on page 121                   |
| SMLAD,<br>SMLADX   | Signed Multiply Accumulate Dual                              | SMLAD on page 116                             |
| SMLAL              | Signed Multiply with Accumulate (32x32+64),<br>64-bit result | UMULL, UMLAL, SMULL, and SMLAL on<br>page 126 |
| SMLAL[B,T]         | Signed Multiply Accumulate Long (halfwords)                  | SMLAL and SMLALD on page 117                  |
| SMLALD,<br>SMLALDX | Signed Multiply Accumulate Long Dual                         | SMLAL and SMLALD on page 117                  |
| SMLAW[B T]         | Signed Multiply Accumulate (word by<br>halfword)             | SMLA and SMLAW on page 115                    |
| SMLSD              | Signed Multiply Subtract Dual                                | SMLSD and SMLSLD on page 119                  |
| SMLSLD             | Signed Multiply Subtract Long Dual                           | SMLSD and SMLSLD on page 119                  |
| SMMLA              | Signed Most Significant Word Multiply<br>Accumulate          | SMMLA and SMMLS on page 121                   |
| SMMLS,<br>SMMLSR   | Signed Most Significant Word Multiply<br>Subtract            | SMMLA and SMMLS on page 121                   |

![](_page_0_Picture_14.jpeg)

PM0253 Rev 5 111/254

| Mnemonic          | Brief description                                                            | See                                           |
|-------------------|------------------------------------------------------------------------------|-----------------------------------------------|
| SMUAD,<br>SMUADX  | Signed Dual Multiply Add                                                     | SMUAD and SMUSD on page 123                   |
| SMUL[B,T]         | Signed Multiply (word by halfword)                                           | SMUL and SMULW on page 124                    |
| SMMUL,<br>SMMULR  | Signed Most Significant Word Multiply                                        | SMMUL on page 122                             |
| SMULL             | Signed Multiply (32x32), 64-bit result                                       | UMULL, UMLAL, SMULL, and SMLAL on<br>page 126 |
| SMULWB,<br>SMULWT | Signed Multiply (word by halfword)<br>SMUL and SMULW on page 124             |                                               |
| SMUSD,<br>SMUSDX  | Signed Dual Multiply Subtract                                                | SMUAD and SMUSD on page 123                   |
| UDIV              | Unsigned Divide                                                              | SDIV and UDIV on page 127                     |
| UMAAL             | Unsigned Multiply Accumulate Accumulate<br>Long (32x32+32+32), 64-bit result | UMULL, UMAAL, UMLAL on page 113               |
| UMLAL             | Unsigned Multiply with Accumulate<br>(32x32+64), 64-bit result               | UMULL, UMAAL, UMLAL on page 113               |
| UMULL             | Unsigned Multiply (32x32), 64-bit result                                     | UMULL, UMAAL, UMLAL on page 113               |

**Table 31. Multiply and divide instructions (continued)**

## <span id="page-1-0"></span>**3.6.1 MUL, MLA, and MLS**

Multiply, Multiply with Accumulate, and Multiply with Subtract, using 32-bit operands, and producing a 32-bit result.

### **Syntax**

```
MUL{S}{cond} {Rd,} Rn, Rm ; Multiply
MLA{cond} Rd, Rn, Rm, Ra ; Multiply with accumulate
MLS{cond} Rd, Rn, Rm, Ra ; Multiply with subtract
```

Where: *cond* Is an optional condition code. See *Conditional execution on page 68*. S Is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation, see *Conditional execution on page 68*. *Rd* Is the destination register. If *Rd* is omitted, the destination register is *Rn*. *Rn, Rm* Are registers holding the values to be multiplied. *Ra* Is a register holding the value to be added or subtracted from.

### **Operation**

The MUL instruction multiplies the values from *Rn* and *Rm*, and places the least significant 32 bits of the result in *Rd*.

The MLA instruction multiplies the values from *Rn* and *Rm*, adds the value from *Ra*, and places the least significant 32 bits of the result in *Rd*.

![](_page_1_Picture_13.jpeg)

The MLS instruction multiplies the values from *Rn* and *Rm*, subtracts the product from the value from *Ra*, and places the least significant 32 bits of the result in *Rd*.

The results of these instructions do not depend on whether the operands are signed or unsigned.

### **Restrictions**

In these instructions, do not use SP and do not use PC.

If the S suffix is used with the MUL instruction:

- *Rd*, *Rn*, and *Rm* must all be in the range R0 to R7.
- *Rd* must be the same as *Rm*.
- The *cond* suffix must not be used.

### **Condition flags**

If S is specified, the MUL instruction:

- Updates the N and Z flags according to the result.
- Does not affect the C and V flags.

### **Examples**

```
MUL R10, R2, R5 ; Multiply, R10 = R2 x R5
MLA R10, R2, R1, R5 ; Multiply with accumulate, R10 = (R2 x R1) + 
                      ; R5
MULS R0, R2, R2 ; Multiply with flag update, R0 = R2 x R2
MULLT R2, R3, R2 ; Conditionally multiply, R2 = R3 x R2
MLS R4, R5, R6, R7 ; Multiply with subtract, R4 = R7 - (R5 x R6)
```

### <span id="page-2-0"></span>**3.6.2 UMULL, UMAAL, UMLAL**

Unsigned Long Multiply, with optional Accumulate, using 32-bit operands and producing a 64-bit result.

### **Syntax**

```
op{cond} RdLo, RdHi, Rn, Rm
Where:
op Is one of:
           UMULL Unsigned Long Multiply.
           UMAAL Unsigned Long Multiply with Accumulate Accumulate.
           UMLAL Unsigned Long Multiply, with Accumulate.
cond Is an optional condition code. See Conditional execution on page 68.
RdHi, RdLo Are the destination registers. For UMAAL, UMLAL and UMLAL they also hold the 
           accumulating value.
Rn, Rm Are registers holding the first and second operands.
```

PM0253 Rev 5 113/254

### **Operation**

These instructions interpret the values from *Rn* and *Rm* as unsigned 32-bit integers. The UMULL instruction:

- Multiplies the two unsigned integers in the first and second operands.
- Writes the least significant 32 bits of the result in *RdLo.*
- Writes the most significant 32 bits of the result in *RdHi*.

#### The UMAAL instruction:

- Multiplies the two unsigned 32-bit integers in the first and second operands.
- Adds the unsigned 32-bit integer in *RdHi* to the 64-bit result of the multiplication.
- Adds the unsigned 32-bit integer in *RdLo* to the 64-bit result of the addition.
- Writes the top 32-bits of the result to *RdHi.*
- Writes the lower 32-bits of the result to *RdLo*.

#### The UMLAL instruction:

- Multiplies the two unsigned integers in the first and second operands.
- Adds the 64-bit result to the 64-bit unsigned integer contained in *RdHi* and *RdLo*.
- Writes the result back to *RdHi* and *RdLo*.

### **Restrictions**

In these instructions:

- Do not use SP and do not use PC.
- *RdHi* and *RdLo* must be different registers.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
UMULL R0, R4, R5, R6 ; Multiplies R5 and R6, writes the top 32 bits to
 ; R4 and the bottom 32 bits to R0.
UMAAL R3, R6, R2, R7 ; Multiplies R2 and R7, adds R6, adds R3, writes 
 ; the top 32 bits to R6, and the bottom 32 bits 
                     ; to R3.
UMLAL R2, R1, R3, R5 ; Multiplies R5 and R3, adds R1:R2, writes to 
                     ; R1:R2.
```

## <span id="page-4-0"></span>**3.6.3 SMLA and SMLAW**

Signed Multiply Accumulate (halfwords).

### **Syntax**

```
op{XY}{cond} Rd, Rn, Rm
op{Y}{cond} Rd, Rn, Rm, Ra
```

#### Where:

#### op Is one of:

SMLA Signed Multiply Accumulate Long (halfwords)

*X* and *Y* specifies which half of the source registers *Rn* and *Rm* are

used as the first and second multiply operand.

If *X* is *B*, then the bottom halfword, bits [15:0], of *Rn* is used. If *X* is *T*, then the top halfword, bits [31:16], of *Rn* is used. If *Y* is *B*, then the bottom halfword, bits [15:0], of *Rm* is used. If *Y* is *T*, then the top halfword, bits [31:16], of *Rm* is used.

SMLAW Signed Multiply Accumulate (word by halfword)

*Y* specifies which half of the source register *Rm* is used as the second

multiply operand.

If *Y* is T, then the top halfword, bits [31:16] of *Rm* is used. If *Y* is B, then the bottom halfword, bits [15:0] of *Rm* is used.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register. If *Rd* is omitted, the destination register is *Rn*.

*Rn, Rm* Are registers holding the values to be multiplied.

*Ra* Is a register holding the value to be added or subtracted from.

### **Operation**

The SMALBB, SMLABT, SMLATB, SMLATT instructions:

- Multiplies the specified signed halfword, top or bottom, values from *Rn* and *Rm*.
- Adds the value in *Ra* to the resulting 32-bit product.
- Writes the result of the multiplication and addition in *Rd*.

The non-specified halfwords of the source registers are ignored.

The SMLAWB and SMLAWT instructions:

- Multiply the 32-bit signed values in *Rn* with:
  - The top signed halfword of *Rm*, *T* instruction suffix.
  - The bottom signed halfword of *Rm*, *B* instruction suffix.
- Add the 32-bit signed value in *Ra* to the top 32 bits of the 48-bit product
- Writes the result of the multiplication and addition in *Rd*.

The bottom 16 bits of the 48-bit product are ignored.

If overflow occurs during the addition of the accumulate value, the instruction sets the Q flag in the APSR. No overflow can occur during the multiplication.

![](_page_4_Picture_34.jpeg)

PM0253 Rev 5 115/254

### **Restrictions**

In these instructions, do not use SP and do not use PC.

### **Condition flags**

If an overflow is detected, the Q flag is set.

### **Examples**

```
SMLABB R5, R6, R4, R1 ; Multiplies bottom halfwords of R6 and R4, adds
 ; R1 and writes to R5.
SMLATB R5, R6, R4, R1 ; Multiplies top halfword of R6 with bottom 
 ; halfword of R4, adds R1 and writes to R5.
SMLATT R5, R6, R4, R1 ; Multiplies top halfwords of R6 and R4, adds 
 ; R1 and writes the sum to R5.
SMLABT R5, R6, R4, R1 ; Multiplies bottom halfword of R6 with top 
 ; halfword of R4, adds R1 and writes to R5.
SMLABT R4, R3, R2 ; Multiplies bottom halfword of R4 with top 
 ; halfword of R3, adds R2 and writes to R4.
SMLAWB R10, R2, R5, R3 ; Multiplies R2 with bottom halfword of R5, adds
 ; R3 to the result and writes top 32-bits to R10.
SMLAWT R10, R2, R1, R5 ; Multiplies R2 with top halfword of R1, adds R5 
 ; and writes top 32-bits to R10.
```

### <span id="page-5-0"></span>**3.6.4 SMLAD**

Signed Multiply Accumulate Long Dual.

### **Syntax**

```
op{X}{cond} Rd, Rn, Rm, Ra
Where:
op Is one of:
           SMLAD Signed Multiply Accumulate Dual.
           SMLADX Signed Multiply Accumulate Dual Reverse.
                    X specifies which halfword of the source register Rn is used as the 
                    multiply operand. 
                    If X is omitted, the multiplications are bottom × bottom and top × top. 
                    If X is present, the multiplications are bottom × top and top × bottom.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first operand register holding the values to be multiplied.
Rm Is the second operand register.
Ra Is the accumulate value.
```

![](_page_5_Picture_13.jpeg)

## **Operation**

The SMLAD and SMLADX instructions regard the two operands as four halfword 16-bit values. The SMLAD and SMLADX instructions:

- If *X* is not present, multiply the top signed halfword value in *Rn* with the top signed halfword of *Rm* and the bottom signed halfword values in *Rn* with the bottom signed halfword of *Rm*.
- Or if *X* is present, multiply the top signed halfword value in *Rn* with the bottom signed halfword of *Rm* and the bottom signed halfword values in *Rn* with the top signed halfword of *Rm*.
- Add both multiplication results to the signed 32-bit value in *Ra*.
- Writes the 32-bit signed result of the multiplication and addition to *Rd*.

### **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SMLAD R10, R2, R1, R5 ; Multiplies two halfword values in R2 with 
 ; corresponding halfwords in R1, adds R5 and 
 ; writes to R10.
SMLALDX R0, R2, R4, R6 ; Multiplies top halfword of R2 with bottom 
 ; halfword of R4, multiplies bottom halfword of R2 
 ; with top halfword of R4, adds R6 and writes to 
                  ; R0.
```

## <span id="page-6-0"></span>**3.6.5 SMLAL and SMLALD**

Signed Multiply Accumulate Long, Signed Multiply Accumulate Long (halfwords) and Signed Multiply Accumulate Long Dual.

### **Syntax**

```
op{cond} RdLo, RdHi, Rn, Rm
op{XY}{cond} RdLo, RdHi, Rn, Rm
op{X}{cond} RdLo, RdHi, Rn, Rm
Where:
op Is one of:
            SMLAL Signed Multiply Accumulate Long.
            SMLALXY Signed Multiply Accumulate Long (halfwords, X and Y).
                     X and Y specify which halfword of the source registers Rn and Rm are 
                     used as the first and second multiply operand:
                     If X is B, then the bottom halfword, bits [15:0], of Rn is used. 
                     If X is T, then the top halfword, bits [31:16], of Rn is used.
                     If Y is B, then the bottom halfword, bits [15:0], of Rm is used.
```

If *Y* is T, then the top halfword, bits [31:16], of *Rm* is used.

![](_page_6_Picture_18.jpeg)

PM0253 Rev 5 117/254

SMLALD Signed Multiply Accumulate Long Dual.

SMLALDX Signed Multiply Accumulate Long Dual Reversed.

If the *X* is omitted, the multiplications are bottom × bottom and top × top.

If *X* is present, the multiplications are bottom × top and top × bottom.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*RdHi*, *RdLo* Are the destination registers.

*RdLo* is the lower 32 bits and *RdHi* is the upper 32 bits of the 64-bit integer. For SMLAL, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLALD and SMLALDX, they also hold the accumulating value.

*Rn, Rm* Are registers holding the first and second operands.

### **Operation**

The SMLAL instruction:

- Multiplies the two's complement signed word values from *Rn* and *Rm*.
- Adds the 64-bit value in *RdLo* and *RdHi* to the resulting 64-bit product.
- Writes the 64-bit result of the multiplication and addition in *RdLo* and *RdHi*.

The SMLALBB, SMLALBT, SMLALTB and SMLALTT instructions:

- Multiplies the specified signed halfword, Top or Bottom, values from *Rn* and *Rm*.
- Adds the resulting sign-extended 32-bit product to the 64-bit value in *RdLo* and *RdHi*.
- Writes the 64-bit result of the multiplication and addition in *RdLo* and *RdHi*.

The non-specified halfwords of the source registers are ignored.

The SMLALD and SMLALDX instructions interpret the values from *Rn* and *Rm* as four halfword two's complement signed 16-bit integers. These instructions:

- If *X* is not present, multiply the top signed halfword value of *Rn* with the top signed halfword of *Rm* and the bottom signed halfword values of *Rn* with the bottom signed halfword of *Rm*.
- Or if *X* is present, multiply the top signed halfword value of *Rn* with the bottom signed halfword of *Rm* and the bottom signed halfword values of *Rn* with the top signed halfword of *Rm*.
- Add the two multiplication results to the signed 64-bit value in *RdLo* and *RdHi* to create the resulting 64-bit product.
- Write the 64-bit product in *RdLo* and *RdHi*.

### **Restrictions**

In these instructions:

- Do not use SP and do not use PC.
- *RdHi* and *RdLo* must be different registers.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

SMLAL R4, R5, R3, R8 ; Multiplies R3 and R8, adds R5:R4 and writes

![](_page_7_Picture_34.jpeg)

```
 ; to R5:R4.
SMLALBT R2, R1, R6, R7 ; Multiplies bottom halfword of R6 with top 
 ; halfword of R7, sign extends to 32-bit, 
 ; adds R1:R2 and writes to R1:R2.
SMLALTB R2, R1, R6, R7 ; Multiplies top halfword of R6 with bottom
 ; halfword of R7,sign extends to 32-bit, adds 
 ; R1:R2 and writes to R1:R2.
SMLALD R6, R8, R5, R1 ; Multiplies top halfwords in R5 and R1 and b
 ; bottom halfwords of R5 and R1, adds R8:R6 
 ; and writes to R8:R6.
SMLALDX R6, R8, R5, R1 ; Multiplies top halfword in R5 with bottom
 ; halfword of R1, and bottom halfword of R5 
 ; with top halfword of R1, adds R8:R6 and 
 ; writes to R8:R6.
```

### <span id="page-8-0"></span>**3.6.6 SMLSD and SMLSLD**

Signed Multiply Subtract Dual and Signed Multiply Subtract Long Dual.

### **Syntax**

```
op{X}{cond} Rd, Rn, Rm, Ra
Where:
op Is one of:
           SMLSD Signed Multiply Subtract Dual.
           SMLSDX Signed Multiply Subtract Dual Reversed.
           SMLSLD Signed Multiply Subtract Long Dual.
           SMLSLDX Signed Multiply Subtract Long Dual Reversed.
           If X is present, the multiplications are bottom × top and top × bottom.
           If the X is omitted, the multiplications are bottom × bottom and top × top.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn, Rm Are registers holding the first and second operands.
Ra Is the register holding the accumulate value.
```

### **Operation**

The SMLSD instruction interprets the values from the first and second operands as four signed halfwords. This instruction:

- Optionally rotates the halfwords of the second operand.
- Performs two signed 16 × 16-bit halfword multiplications.
- Subtracts the result of the upper halfword multiplication from the result of the lower halfword multiplication.
- Adds the signed accumulate value to the result of the subtraction.
- Writes the result of the addition to the destination register.

![](_page_8_Picture_14.jpeg)

PM0253 Rev 5 119/254

The SMLSLD instruction interprets the values from *Rn* and *Rm* as four signed halfwords. This instruction:

- Optionally rotates the halfwords of the second operand.
- Performs two signed 16 × 16-bit halfword multiplications.
- Subtracts the result of the upper halfword multiplication from the result of the lower halfword multiplication.
- Adds the 64-bit value in *RdHi* and *RdLo* to the result of the subtraction.
- Writes the 64-bit result of the addition to the *RdHi* and *RdLo*.

### **Restrictions**

In these instructions:

• Do not use SP and do not use PC.

### **Condition flags**

This instruction sets the Q flag if the accumulate operation overflows. Overflow cannot occur during the multiplications or subtraction.

For the Thumb instruction set, these instructions do not affect the condition code flags.

### **Examples**

```
SMLSD R0, R4, R5, R6 ; Multiplies bottom halfword of R4 with
 ; bottom halfword of R5, multiplies top 
 ; halfword of R4 with top halfword of R5, sub
 ; substracts second from first, adds R6, 
                    ; writes to R0.
SMLSDX R1, R3, R2, R0 ; Multiplies bottom halfword of R3 with top
 ; halfword of R2, multiplies top halfword of 
 ; R3 with bottom halfword of R2, subtracts se
 ; second from first, adds R0, writes to R1.
SMLSLD R3, R6, R2, R7 ; Multiplies bottom halfword of R6 with 
 ; bottom halfword of R2, multiplies top 
 ; halfword of R6 with top halfword of R2, sub
 ; substracts second first, adds R6:R3, writes 
                    ; to R6:R3.
SMLSLDX R3, R6, R2, R7 ; Multiplies bottom halfword of R6 with top
 ; halfword of R2, multiplies top halfword of 
 ; R6 with bottom halfword of R2, subtracts 
 ; second from first, adds R6:R3, writes to 
                    ; R6:R3.
```

![](_page_9_Picture_17.jpeg)

## <span id="page-10-0"></span>**3.6.7 SMMLA and SMMLS**

Signed Most Significant Word Multiply Accumulate and Signed Most Significant Word Multiply Subtract.

### **Syntax**

op{*R*}{*cond*} *Rd*, *Rn*, *Rm*, *Ra*

#### Where:

*op* Is one of:

SMMLA Signed Most Significant Word Multiply Accumulate.

SMMLS Signed Most Significant Word Multiply Subtract.

R Is a rounding error flag. If *R* is specified, the result is rounded instead of being

truncated. In this case the constant 0x80000000 is added to the product before

the high word is extracted.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register.

*Rn, Rm* Are registers holding the first and second multiply operands.

*Ra* Is the register holding the accumulate value.

### **Operation**

The SMMLA instruction interprets the values from *Rn* and *Rm* as signed 32-bit words.

The SMMLA instruction:

- Multiplies the values in *Rn* and *Rm*.
- Optionally rounds the result by adding 0x80000000.
- Extracts the most significant 32 bits of the result.
- Adds the value of *Ra* to the signed extracted value.
- Writes the result of the addition in *Rd*.

The SMMLS instruction interprets the values from *Rn* and *Rm* as signed 32-bit words.

The SMMLS instruction:

- Multiplies the values in *Rn* and *Rm*.
- Optionally rounds the result by adding 0x80000000.
- Extracts the most significant 32 bits of the result.
- Subtracts the extracted value of the result from the value in *Ra*.
- Writes the result of the subtraction in *Rd*.

### **Restrictions**

In these instructions:

• Do not use SP and do not use PC.

### **Condition flags**

These instructions do not affect the condition code flags.

![](_page_10_Picture_37.jpeg)

PM0253 Rev 5 121/254

## **Examples**

```
SMMLA R0, R4, R5, R6 ; Multiplies R4 and R5, extracts top 32 bits, 
 ; adds R6, truncates and writes to R0.
SMMLAR R6, R2, R1, R4 ; Multiplies R2 and R1, extracts top 32 bits, 
 ; adds R4, rounds and writes to R6.
SMMLSR R3, R6, R2, R7 ; Multiplies R6 and R2, extracts top 32 bits,
 ; subtracts R7, rounds and writes to R3.
SMMLS R4, R5, R3, R8 ; Multiplies R5 and R3, extracts top 32 bits, 
 ; subtracts R8, truncates and writes to R4.
```

### <span id="page-11-0"></span>**3.6.8 SMMUL**

Signed Most Significant Word Multiply.

### **Syntax**

```
op{R}{cond} Rd, Rn, Rm
Where:
op Is one of:
           SMMUL Signed Most Significant Word Multiply
R Is a rounding error flag. If R is specified, the result is rounded instead of being 
           truncated. In this case the constant 0x80000000 is added to the product before 
           the high word is extracted.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn, Rm Are registers holding the first and second operands.
```

### **Operation**

The SMMUL instruction interprets the values from *Rn* and *Rm* as two's complement 32-bit signed integers. The SMMUL instruction:

- Multiplies the values from *Rn* and *Rm*.
- Optionally rounds the result, otherwise truncates the result.
- Writes the most significant signed 32 bits of the result in *Rd*.

### **Restrictions**

In this instruction:

• Do not use SP and do not use PC.

### **Condition flags**

This instruction does not affect the condition code flags.

### **Examples**

```
SMULL R0, R4, R5 ; Multiplies R4 and R5, truncates top 32 bits
 ; and writes to R0.
SMULLR R6, R2 ; Multiplies R6 and R2, rounds the top 32
 ; bits and writes to R6.
```

![](_page_11_Picture_21.jpeg)

## <span id="page-12-0"></span>**3.6.9 SMUAD and SMUSD**

Signed Dual Multiply Add and Signed Dual Multiply Subtract.

### **Syntax**

```
op{X}{cond} Rd, Rn, Rm
Where:
op Is one of:
           SMUAD Signed Dual Multiply Add.
           SMUADX Signed Dual Multiply Add Reversed.
           SMUSD Signed Dual Multiply Subtract.
           SMUSDX Signed Dual Multiply Subtract Reversed.
           If X is present, the multiplications are bottom × top and top × bottom.
           If the X is omitted, the multiplications are bottom × bottom and top × top.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn, Rm Are registers holding the first and the second operands.
```

### **Operation**

The SMUAD instruction interprets the values from the first and second operands as two signed halfwords in each operand. This instruction:

- Optionally rotates the halfwords of the second operand.
- Performs two signed 16 × 16-bit multiplications.
- Adds the two multiplication results together.
- Writes the result of the addition to the destination register.

The SMUSD instruction interprets the values from the first and second operands as two's complement signed integers. This instruction:

- Optionally rotates the halfwords of the second operand.
- Performs two signed 16 × 16-bit multiplications.
- Subtracts the result of the top halfword multiplication from the result of the bottom halfword multiplication.
- Writes the result of the subtraction to the destination register.

### **Restrictions**

In these instructions:

• Do not use SP and do not use PC.

### **Condition flags**

Sets the Q flag if the addition overflows. The multiplications cannot overflow.

### **Examples**

```
SMUAD R0, R4, R5 ; Multiplies bottom halfword of R4 with the
 ; bottom halfword of R5, adds multiplication of
```

![](_page_12_Picture_24.jpeg)

PM0253 Rev 5 123/254

```
 ; top halfword of R4 with top halfword of R5, 
                   ; writes to R0.
SMUADX R3, R7, R4 ; Multiplies bottom halfword of R7 with top 
 ; halfword of R4, adds multiplication of top 
 ; halfword of R7 with bottom halfword of R4, 
                   ; writes to R3.
SMUSD R3, R6, R2 ; Multiplies bottom halfword of R4 with bottom 
 ; halfword of R6, subtracts multiplication of top 
 ; halfword of R6 with top halfword of R3, writes 
                   ; to R3.
SMUSDX R4, R5, R3 ; Multiplies bottom halfword of R5 with top
 ; halfword of R3, subtracts multiplication of top 
 ; halfword of R5 with bottom halfword of R3, 
                   ; writes to R4.
```

### <span id="page-13-0"></span>**3.6.10 SMUL and SMULW**

Signed Multiply (halfwords) and Signed Multiply (word by halfword).

## **Syntax**

```
op{XY}{cond} Rd,Rn, Rm
op{Y}{cond} Rd. Rn, Rm
For SMULXY only:
op Is one of:
            SMUL{XY} Signed Multiply (halfwords) 
            X and Y specify which halfword of the source registers Rn and Rm is used as the 
            first and second multiply operand. 
            If X is B, then the bottom halfword, bits [15:0] of Rn is used. 
            If X is T, then the top halfword, bits [31:16] of Rn is used.If Y is B, then the 
            bottom halfword, bits [15:0], of Rm is used. 
            If Y is T, then the top halfword, bits [31:16], of Rm is used.
            SMULW{Y} Signed Multiply (word by halfword)
            Y specifies which halfword of the source register Rm is used as the second 
            multiply operand. 
            If Y is B, then the bottom halfword (bits [15:0]) of Rm is used. 
            If Y is T, then the top halfword (bits [31:16]) of Rm is used.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn, Rm Are registers holding the first and second operands.
```

### **Operation**

The SMULBB, SMULTB, SMULBT and SMULTT instructions interprets the values from *Rn* and *Rm* as four signed 16-bit integers.

These instructions:

- Multiply the specified signed halfword, Top or Bottom, values from *Rn* and *Rm*.
- Write the 32-bit result of the multiplication in *Rd.*

The SMULWT and SMULWB instructions interprets the values from *Rn* as a 32-bit signed integer and *Rm* as two halfword 16-bit signed integers. These instructions:

- Multiply the first operand and the top, T suffix, or the bottom, B suffix, halfword of the second operand.
- Write the signed most significant 32 bits of the 48-bit result in the destination register.

### **Restrictions**

In these instructions:

- Do not use SP and do not use PC.
- *RdHi* and *RdLo* must be different registers.

### **Examples**

| SMULBT | R0, R4, R5 | ; Multiplies the bottom halfword of R4 with  |
|--------|------------|----------------------------------------------|
|        |            | ; the top halfword of R5, multiplies results |
|        |            | ; and writes to R0.                          |
| SMULBB | R0, R4, R5 | ; Multiplies the bottom halfword of R4 with  |
|        |            | ; the bottom halfword of R5, multiplies      |
|        |            | ; results and writes to R0.                  |
| SMULTT | R0, R4, R5 | ; Multiplies the top halfword of R4 with the |
|        |            | ; top halfword of R5, multiplies results and |
|        |            | ; writes to R0.                              |
| SMULTB | R0, R4, R5 | ; Multiplies the top halfword of R4 with the |
|        |            | ; bottom halfword of R5, multiplies results  |
|        |            | ; and writes to R0.                          |
| SMULWT | R4, R5, R3 | ; Multiplies R5 with the top halfword of R3, |
|        |            | ; extracts top 32 bits and writes to R4.     |
| SMULWB | R4, R5, R3 | ; Multiplies R5 with the bottom halfword of  |
|        |            | ; R3, extracts top 32 bits and writes to R4. |

![](_page_14_Picture_11.jpeg)

PM0253 Rev 5 125/254

### <span id="page-15-0"></span>**3.6.11 UMULL, UMLAL, SMULL, and SMLAL**

Signed and Unsigned Long Multiply, with optional Accumulate, using 32-bit operands and producing a 64-bit result.

### **Syntax**

```
op{cond} RdLo, RdHi, Rn, Rm
Where:
op Is one of:
           UMULL Unsigned Long Multiply.
           UMLAL Unsigned Long Multiply, with Accumulate.
           SMULL Signed Long Multiply.
           SMLAL Signed Long Multiply, with Accumulate.
cond Is an optional condition code. See Conditional execution on page 68.
RdHi, RdLo Are the destination registers. For UMLAL and SMLAL they also hold the 
           accumulating value.
Rn, Rm Are registers holding the operands.
```

### **Operation**

The UMULL instruction interprets the values from *Rn* and *Rm* as unsigned integers. It multiplies these integers and places the least significant 32 bits of the result in *RdLo*, and the most significant 32 bits of the result in *RdHi*.

The UMLAL instruction interprets the values from *Rn* and *Rm* as unsigned integers. It multiplies these integers, adds the 64-bit result to the 64-bit unsigned integer contained in *RdHi* and *RdLo*, and writes the result back to *RdHi* and *RdLo*.

The SMULL instruction interprets the values from *Rn* and *Rm* as two's complement signed integers. It multiplies these integers and places the least significant 32 bits of the result in *RdLo*, and the most significant 32 bits of the result in *RdHi*.

The SMLAL instruction interprets the values from *Rn* and *Rm* as two's complement signed integers. It multiplies these integers, adds the 64-bit result to the 64-bit signed integer contained in *RdHi* and *RdLo*, and writes the result back to *RdHi* and *RdLo*.

### **Restrictions**

In these instructions:

- Do not use SP and do not use PC.
- *RdHi* and *RdLo* must be different registers.

### **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
UMULL R0, R4, R5, R6 ; Unsigned (R4,R0) = R5 x R6
SMLAL R4, R5, R3, R8 ; Signed (R5,R4) = (R5,R4) + R3 x R8
```

![](_page_15_Picture_20.jpeg)

## <span id="page-16-0"></span>**3.6.12 SDIV and UDIV**

Signed Divide and Unsigned Divide.

### **Syntax**

```
SDIV{cond} {Rd,} Rn, Rm
UDIV{cond} {Rd,} Rn, Rm
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *Rd* Is the destination register. If *Rd* is omitted, the destination register is *Rn*.

*Rn* Is the register holding the value to be divided.

*Rm* Is a register holding the divisor.

### **Operation**

The SDIV instruction performs a signed integer division of the value in *Rn* by the value in *Rm*.

The UDIV instruction performs an unsigned integer division of the value in *Rn* by the value in *Rm*.

For both instructions, if the value in *Rn* is not divisible by the value in *Rm*, the result is rounded towards zero.

### **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SDIV R0, R2, R4 ; Signed divide, R0 = R2/R4
UDIV R8, R8, R1 ; Unsigned divide, R8 = R8/R1
```

PM0253 Rev 5 127/254