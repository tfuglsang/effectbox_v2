# **3.4 Memory access instructions**

*[Table](#page-0-0) 27* shows the memory access instructions:

**Table 27. Memory access instructions** 

<span id="page-0-0"></span>

| Mnemonic    | Brief description                       | See                                      |  |
|-------------|-----------------------------------------|------------------------------------------|--|
| ADR         | Generate PC-relative address            | ADR on page 73                           |  |
| CLREX       | Clear Exclusive                         | CLREX on page 84                         |  |
| LDM{mode}   | Load Multiple registers                 | LDM and STM on page 79                   |  |
| LDR{type}   | Load register using immediate offset    | LDR and STR, immediate offset on page 73 |  |
| LDR{type}   | Load register using register offset     | LDR and STR, register offset on page 76  |  |
| LDR{type}T  | Load register with unprivileged access  | LDR and STR, unprivileged on page 77     |  |
| LDR         | Load register using PC-relative address | LDR, PC-relative on page 78              |  |
| LDRD        | Load register Dual                      | LDR and STR, immediate offset on page 73 |  |
| LDREX{type} | Load register Exclusive                 | LDREX and STREX on page 83               |  |
| PLD         | Preload Data.                           | PLD on page 81                           |  |
| POP         | Pop registers from stack                | PUSH and POP on page 82                  |  |
| PUSH        | Push registers onto stack               | PUSH and POP on page 82                  |  |
| STM{mode}   | Store Multiple registers                | LDM and STM on page 79                   |  |
| STR{type}   | Store register using immediate offset   | LDR and STR, immediate offset on page 73 |  |
| STR{type}   | Store register using register offset    | LDR and STR, register offset on page 76  |  |
| STR{type}T  | Store register with unprivileged access | LDR and STR, unprivileged on page 77     |  |
| STREX{type} | Store register Exclusive                | LDREX and STREX on page 83               |  |

![](_page_0_Picture_6.jpeg)

## <span id="page-1-1"></span>**3.4.1 ADR**

Generate PC-relative address.

### **Syntax**

```
ADR{cond} Rd, label
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register.

*label* Is a PC-relative expression. See *PC-relative expressions on page 68*.

### **Operation**

ADR generates an address by adding an immediate value to the PC, and writes the result to the destination register.

ADR provides the means by which position-independent code can be generated, because the address is PC-relative.

If ADR is used to generate a target address for a BX or BLX instruction, The user must ensure that bit[0] of the address generated is set to1 for correct execution.

Values of *label* must be within the range of -4095 to +4095 from the address in the PC.

The user might have to use the .W suffix to get the maximum offset range or to generate addresses that are not word-aligned. See *Instruction width selection on page 71*.

### **Restrictions**

*Rd* must not be SP and must not be PC.

### **Condition flags**

This instruction does not change the flags.

### **Examples**

```
ADR R1, TextMessage ; Write address value of a location labelled
                        ; as TextMessage to R1.
```

## <span id="page-1-0"></span>**3.4.2 LDR and STR, immediate offset**

Load and Store with immediate offset, pre-indexed immediate offset, or post-indexed immediate offset.

### **Syntax**

```
op{type}{cond} Rt, [Rn {, #offset}] ; immediate offset
op{type}{cond} Rt, [Rn, #offset]! ; pre-indexed
op{type}{cond} Rt, [Rn], #offset ; post-indexed
opD{cond} Rt, Rt2, [Rn {, #offset}] ; immediate offset, two words
opD{cond} Rt, Rt2, [Rn, #offset]! ; pre-indexed, two words
opD{cond} Rt, Rt2, [Rn], #offset ; post-indexed, two words
```

PM0253 Rev 5 73/254

#### Where:

*op* Is one of:

LDR Load register. STR Store register.

*type* Is one of:

B Unsigned byte, zero extend to 32 bits on loads. SB Signed byte, sign extend to 32 bits (LDR only). H Unsigned halfword, zero extend to 32 bits on loads. SH Signed halfword, sign extend to 32 bits (LDR only).

- Omit, for word.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rt* Is the register to load or store.

*Rn* Is the register on which the memory address is based.

*offset* Is an offset from *Rn*. If *offset* is omitted, the address is the contents of *Rn*.

*Rt2* Is the additional register to load or store for two-word operations.

### **Operation**

LDR instructions load one or two registers with a value from memory.

STR instructions store one or two register values to memory.

Load and store instructions with immediate offset can use the following addressing modes:

### **Offset addressing**

The offset value is added to or subtracted from the address obtained from the register *Rn*. The result is used as the address for the memory access. The register *Rn* is unaltered. The assembly language syntax for this mode is:

[*Rn*, #*offset*]

### **Pre-indexed addressing**

The offset value is added to or subtracted from the address obtained from the register *Rn*. The result is used as the address for the memory access and written back into the register *Rn*. The assembly language syntax for this mode is:

[*Rn*, #*offset*]!

### **Post-indexed addressing**

The address obtained from the register *Rn* is used as the address for the memory access. The offset value is added to or subtracted from the address, and written back into the register *Rn*. The assembly language syntax for this mode is:

[*Rn*], #*offset*

The value to load or store can be a byte, halfword, word, or two words. Bytes and halfwords can either be signed or unsigned. See *Address alignment on page 68*.

*[Table](#page-3-0) 28* shows the ranges of offset for immediate, pre-indexed and post-indexed forms

![](_page_2_Picture_28.jpeg)

<span id="page-3-0"></span>

| Instruction type                                         | Immediate offset                            | Pre-indexed                                 | Post-indexed                                |  |  |
|----------------------------------------------------------|---------------------------------------------|---------------------------------------------|---------------------------------------------|--|--|
| Word, halfword, signed<br>halfword, byte, or signed byte | -255 to 4095                                | -255 to 255                                 | -255 to 255                                 |  |  |
| Two words                                                | multiple of 4 in the<br>range -1020 to 1020 | multiple of 4 in the<br>range -1020 to 1020 | multiple of 4 in the<br>range -1020 to 1020 |  |  |

**Table 28. Offset ranges** 

### **Restrictions**

For load instructions:

- *Rt* can be SP or PC for word loads only.
- *Rt* must be different from *Rt2* for two-word loads.
- *Rn* must be different from *Rt* and *Rt2* in the pre-indexed or post-indexed forms.

When *Rt* is PC in a word load instruction:

- Bit[0] of the loaded value must be 1 for correct execution.
- A branch occurs to the address created by changing bit[0] of the loaded value to 0.
- If the instruction is conditional, it must be the last instruction in the IT block.

For store instructions:

- *Rt* can be SP for word stores only.
- *Rt* must not be PC.
- *Rn* must not be PC.
- *Rn* must be different from *Rt* and *Rt2* in the pre-indexed or post-indexed forms.

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
LDR R8, [R10] ; Loads R8 from the address in R10.
LDRNE R2, [R5, #960]! ; Loads (conditionally) R2 from a word
                             ; 960 bytes above the address in R5, 
                             ; and increments R5 by 960.
STR R2, [R9,#const-struc] ; const-struc is an expression 
                             ; evaluating to a constant in the range 
                             ; 0-4095.
STRH R3, [R4], #4 ; Store R3 as halfword data into
                             ; address in R4, then increment R4 by 
                             ; 4.
LDRD R8, R9, [R3, #0x20] ; Load R8 from a word 32 bytes above
                             ; the address in R3, and load R9 from a
                             ; word 36 bytes above the address in 
                             ; R3.
STRD R0, R1, [R8], #-16 ; Store R0 to address in R8, and store
                             ; R1 to a word 4 bytes above the 
                             ; address in R8, and then decrement R8 
                             ; by 16.
```

PM0253 Rev 5 75/254

## <span id="page-4-0"></span>**3.4.3 LDR and STR, register offset**

Load and Store with register offset.

### **Syntax**

```
op{type}{cond} Rt, [Rn, Rm {, LSL #n}]
Where:
op Is one of:
           LDR Load register.
           STR Store register.
type Is one of:
           B Unsigned byte, zero extend to 32 bits on loads.
           SB Signed byte, sign extend to 32 bits (LDR only).
           H Unsigned halfword, zero extend to 32 bits on loads.
           SH Signed halfword, sign extend to 32 bits (LDR only).
           - omit, for word.
cond Is an optional condition code. See Conditional execution on page 68.
Rt Is the register to load or store.
Rn Is the register on which the memory address is based.
Rm Is a register containing a value to be used as the offset.
LSL #n Is an optional shift, with n in the range 0 to 3.
```

### **Operation**

LDR instructions load a register with a value from memory.

STR instructions store a register value into memory.

The memory address to load from or store to is at an offset from the register *Rn*. The offset is specified by the register *Rm* and can be shifted left by up to 3 bits using LSL.

The value to load or store can be a byte, halfword, or word. For load instructions, bytes and halfwords can either be signed or unsigned. See *Address alignment on page 68*.

### **Restrictions**

In these instructions:

- *Rn* must not be PC.
- *Rm* must not be SP and must not be PC.
- *Rt* can be SP only for word loads and word stores.
- *Rt* can be PC only for word loads.

When *Rt* is PC in a word load instruction:

- Bit[0] of the loaded value must be 1 for correct execution, and a branch occurs to this halfword-aligned address.
- If the instruction is conditional, it must be the last instruction in the IT block.

### **Condition flags**

These instructions do not change the flags.

![](_page_4_Picture_23.jpeg)

## **Examples**

```
STR R0, [R5, R1] ; Store value of R0 into an address equal 
                           ; to sum of R5 and R1.
LDRSB R0, [R5, R1, LSL #1] ; Read byte value from an address equal to
                           ; sum of R5 and two times R1, sign 
                           ; extended it to a word value and put it 
                           , in R0.
STR R0, [R1, R2, LSL #2] ; Stores R0 to an address equal to sum of 
                           ; R1 and four times R2.
```

## <span id="page-5-0"></span>**3.4.4 LDR and STR, unprivileged**

Load and Store with unprivileged access.

### **Syntax**

```
op{type}T{cond} Rt, [Rn {, #offset}] ; immediate offset
Where:
op Is one of:
           LDR Load register.
           STR Store register.
type Is one of:
           B Unsigned byte, zero extend to 32 bits on loads.
           SB Signed byte, sign extend to 32 bits (LDR only).
           H Unsigned halfword, zero extend to 32 bits on loads.
           SH Signed halfword, sign extend to 32 bits (LDR only).
           - Omit, for word.
cond Is an optional condition code. See Conditional execution on page 68.
Rt Is the register to load or store.
Rn Is the register on which the memory address is based.
offset Is an offset from Rn and can be 0 to 255. If offset is omitted, the address is 
           the value in Rn.
```

### **Operation**

These load and store instructions perform the same function as the memory access instructions with immediate offset, see *[LDR and STR, immediate offset on page](#page-1-0) 73*. The difference is that these instructions have only unprivileged access even when used in privileged software.

When used in unprivileged software, these instructions behave in exactly the same way as normal memory access instructions with immediate offset.

## **Restrictions**

In these instructions:

- *Rn* must not be PC.
- *Rt* must not be SP and must not be PC.

![](_page_5_Picture_15.jpeg)

PM0253 Rev 5 77/254

### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
STRBTEQ R4, [R7] ; Conditionally store least significant byte 
                       ; in R4 to an address in R7, with unprivileged 
                       ; access.
LDRHT R2, [R2, #8] ; Load halfword value from an address equal to
                       ; sum of R2 and 8 into R2, with unprivileged 
                       ; access.
```

# <span id="page-6-0"></span>**3.4.5 LDR, PC-relative**

Load register from memory.

### **Syntax**

```
LDR{type}{cond} Rt, label
LDRD{cond} Rt, Rt2, label ; Load two words
Where:
type Is one of:
          B Unsigned byte, zero extend to 32 bits.
          SB Signed byte, sign extend to 32 bits.
          H Unsigned halfword, zero extend to 32 bits.
          SH Signed halfword, sign extend to 32 bits.
          - Omit, for word.
cond Is an optional condition code. See Conditional execution on page 68.
Rt Is the register to load or store.
Rt2 Is the second register to load or store.
label Is a PC-relative expression. See PC-relative expressions on page 68.
```

### **Operation**

LDR loads a register with a value from a PC-relative memory address. The memory address is specified by a label or by an offset from the PC.

The value to load or store can be a byte, halfword, or word. For load instructions, bytes and halfwords can either be signed or unsigned. See *Address alignment on page 68*.

*label* must be within a limited range of the current instruction. *[Table](#page-6-1) 29* shows the possible offsets between *label* and the PC

**Table 29. Offset ranges** 

<span id="page-6-1"></span>

| Instruction type                                   | Offset range  |  |
|----------------------------------------------------|---------------|--|
| Word, halfword, signed halfword, byte, signed byte | −4095 to 4095 |  |
| Two words                                          | −1020 to 1020 |  |

![](_page_6_Picture_17.jpeg)

*Note: The user might have to use the .W suffix to get the maximum offset range. See Instruction width selection on page 71.*

### **Restrictions**

In these instructions:

- *Rt* can be SP or PC only for word loads.
- *Rt2* must not be SP and must not be PC.
- *Rt* must be different from *Rt2.*

When *Rt* is PC in a word load instruction:

- Bit[0] of the loaded value must be 1 for correct execution, and a branch occurs to this halfword-aligned address.
- If the instruction is conditional, it must be the last instruction in the IT block.

## **Condition flags**

These instructions do not change the flags.

### **Examples**

```
LDR R0, LookUpTable ; Load R0 with a word of data from an
                         ; address labelled as LookUpTable.
LDRSB R7, localdata ; Load a byte value from an address labelled
                         ; as localdata, sign extend it to a word
                         ; value, and put it in R7.
```

## <span id="page-7-0"></span>**3.4.6 LDM and STM**

Load and Store Multiple registers.

### **Syntax**

```
op{addr_mode}{cond} Rn{!}, reglist
Where:
op Is one of:
           LDM Load Multiple registers.
           STM Store Multiple registers.
addr_mode Is any one of the following:
           IA Increment address After each access. This is the default.
           DB Decrement address Before each access.
cond Is an optional condition code. See Conditional execution on page 68.
Rn Is the register on which the memory addresses are based. 
! Is an optional writeback suffix. If ! is present the final address, that is loaded 
           from or stored to, is written back into Rn.
reglist Is a list of one or more registers to be loaded or stored, enclosed in braces. It 
           can contain register ranges. It must be comma separated if it contains more 
           than one register or register range, see Examples on page 80.
```

LDM and LDMFD are synonyms for LDMIA. LDMFD refers to its use for popping data from Full Descending stacks.

PM0253 Rev 5 79/254

LDMEA is a synonym for LDMDB, and refers to its use for popping data from Empty Ascending stacks.

STM and STMEA are synonyms for STMIA. STMEA refers to its use for pushing data onto Empty Ascending stacks.

STMFD is s synonym for STMDB, and refers to its use for pushing data onto Full Descending stacks

### **Operation**

LDM instructions load the registers in *reglist* with word values from memory addresses based on *Rn*.

STM instructions store the word values in the registers in *reglist* to memory addresses based on *Rn*.

For LDM, LDMIA, LDMFD, STM, STMIA, and STMEA the memory addresses used for the accesses are at 4-byte intervals ranging from *Rn* to *Rn* + 4 \* (*n*-1), where *n* is the number of registers in *reglist*. The accesses happens in order of increasing register numbers, with the lowest numbered register using the lowest memory address and the highest number register using the highest memory address. If the writeback suffix is specified, the value of *Rn* + 4 \* (*n*-1) is written back to *Rn*.

For LDMDB, LDMEA, STMDB, and STMFD the memory addresses used for the accesses are at 4-byte intervals ranging from *Rn* to *Rn* - 4 \* (*n*-1), where *n* is the number of registers in *reglist*. The accesses happen in order of decreasing register numbers, with the highest numbered register using the highest memory address and the lowest number register using the lowest memory address. If the writeback suffix is specified, the value of *Rn* - 4 \* (*n*-1) is written back to *Rn*.

The PUSH and POP instructions can be expressed in this form. See *[PUSH and POP on](#page-10-0)  [page](#page-10-0) 82* for details.

### **Restrictions**

In these instructions:

- *Rn* must not be PC.
- *reglist* must not contain SP.
- In any STM instruction, *reglist* must not contain PC.
- In any LDM instruction, *reglist* must not contain PC if it contains LR.
- *reglist* must not contain *Rn* if the writeback suffix is specified.

When PC is in *reglist* in an LDM instruction:

- Bit[0] of the value loaded to the PC must be 1 for correct execution, and a branch occurs to this halfword-aligned address
- If the instruction is conditional, it must be the last instruction in the IT block.

### **Condition flags**

These instructions do not change the flags.

### <span id="page-8-0"></span>**Examples**

```
LDM R8,{R0,R2,R9} ; LDMIA is a synonym for LDM.
STMDB R1!,{R3-R6,R11,R12}
```

### **Incorrect examples**

```
STM R5!,{R5,R4,R9} ; Value stored for R5 is unpredictable. 
LDM R2, {} ; There must be at least one register in the 
                    ; list.
```

## <span id="page-9-0"></span>**3.4.7 PLD**

Preload Data.

### **Syntax**

```
PLD [<Rn>,#<imm12>]
PLD [<Rn>, <Rm> {, LSL #<shift>}]
PLD <label>
```

#### where:

<Rn> Is the base register.

<imm> Is the immediate offset used to form the address.

<Rm> Is the optionally shifted offset register.

<shift> Specifies the shift to apply to the value read from <Rm>, in the range 0-3. If this

option is omitted, a shift by 0 is assumed.

<label> The label of the literal item that is likely to be accessed in the near future.

### **Operation**

PLD signals the memory system that data memory accesses from a specified address are likely in the near future. If the address is cacheable then the memory system responds by pre-loading the cache line containing the specified address into the data cache. If the address is not cacheable, or the data cache is disabled, this instruction behaves as no operation.

## **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

![](_page_9_Picture_21.jpeg)

PM0253 Rev 5 81/254

## <span id="page-10-0"></span>**3.4.8 PUSH and POP**

Push registers onto, and pop registers off a full-descending stack.

### **Syntax**

PUSH{*cond*} *reglist* POP{*cond*} *reglist*

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*reglist* Is a non-empty list of registers, enclosed in braces. It can contain register

ranges. It must be comma separated if it contains more than one register or

register range.

PUSH and POP are synonyms for STMDB and LDM (or LDMIA) with the memory addresses for the access based on SP, and with the final address for the access written back to the SP. PUSH and POP are the preferred mnemonics in these cases.

### **Operation**

PUSH stores registers on the stack, with the lowest numbered register using the lowest memory address and the highest numbered register using the highest memory address.

POP loads registers from the stack, with the lowest numbered register using the lowest memory address and the highest numbered register using the highest memory address.

PUSH uses the value in the SP register minus four as the highest memory address, POP uses the value in the SP register as the lowest memory address, implementing a fulldescending stack. On completion, PUSH updates the SP register to point to the location of the lowest store value, POP updates the SP register to point to the location above the highest location loaded.

If a POP instruction includes PC in its reglist, a branch to this location is performed when the POP instruction has completed. Bit[0] of the value read for the PC is used to update the APSR T-bit. This bit must be 1 to ensure correct operation.

See *[LDM and STM on page](#page-7-0) 79* for more information.

# **Restrictions**

In these instructions:

- *reglist* must not contain SP.
- For the PUSH instruction, *reglist* must not contain PC.
- For the POP instruction, *reglist* must not contain PC if it contains LR.

When PC is in *reglist* in a POP instruction:

- Bit[0] of the value loaded to the PC must be 1 for correct execution, and a branch occurs to this halfword-aligned address.
- If the instruction is conditional, it must be the last instruction in the IT block.

### **Condition flags**

These instructions do not change the flags.

![](_page_10_Picture_29.jpeg)

### **Examples**

```
PUSH {R0,R4-R7} ; Push R0,R4,R5,R6,R7 onto the stack
PUSH {R2,LR} ; Push R2 and the link-register onto the stack
POP {R0,R6,PC} ; Pop r0,r6 and PC from the stack, then branch to the 
               ; new PC.
```

## <span id="page-11-0"></span>**3.4.9 LDREX and STREX**

Load and Store Register Exclusive.

# **Syntax**

```
LDREX{cond} Rt, [Rn {, #offset}]
STREX{cond} Rd, Rt, [Rn {, #offset}]
LDREXB{cond} Rt, [Rn]
STREXB{cond} Rd, Rt, [Rn]
LDREXH{cond} Rt, [Rn]
STREXH{cond} Rd, Rt, [Rn]
```

### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register for the returned status.

*Rt* Is the register to load or store.

*Rn* Is the register on which the memory address is based.

*offset* Is an optional offset applied to the value in *Rn*. If *offset* is omitted, the address

is the value in *Rn*.

# **Operation**

LDREX, LDREXB, and LDREXH load a word, byte, and halfword respectively from a memory address.

STREX, STREXB, and STREXH attempt to store a word, byte, and halfword respectively to a memory address. The address used in any Store-Exclusive instruction must be the same as the address in the most recently executed Load-exclusive instruction. The value stored by the Store-Exclusive instruction must also have the same data size as the value loaded by the preceding Load-exclusive instruction. This means software must always use a Loadexclusive instruction and a matching Store-Exclusive instruction to perform a synchronization operation, see *Synchronization primitives on page 37*.

If a Store-Exclusive instruction performs the store, it writes 0 to its destination register. If it does not perform the store, it writes 1 to its destination register. If the Store-Exclusive instruction writes 0 to the destination register, it is guaranteed that no other process in the system has accessed the memory location between the Load-exclusive and Store-Exclusive instructions.

For reasons of performance, keep the number of instructions between corresponding Load-Exclusive and Store-Exclusive instruction to a minimum.

The result of executing a Store-Exclusive instruction to an address that is different from that used in the preceding Load-Exclusive instruction is unpredictable.

PM0253 Rev 5 83/254

### **Restrictions**

In these instructions:

- Do not use PC.
- Do not use SP for *Rd* and *Rt*.
- For STREX, *Rd* must be different from both *Rt* and *Rn*.
- The value of *offset* must be a multiple of four in the range 0-1020.

### **Condition flags**

These instructions do not change the flags.

# **Examples**

```
MOV R1, #0x1 ; Initialize the 'lock taken' value try
LDREX R0, [LockAddr] ; Load the lock value
CMP R0, #0 ; Is the lock free?
ITT EQ ; IT instruction for STREXEQ and CMPEQ
STREXEQ R0, R1, [LockAddr] ; Try and claim the lock
CMPEQ R0, #0 ; Did this succeed?
BNE try ; No – try again
.... ; Yes – we have the lock.
```

## <span id="page-12-0"></span>**3.4.10 CLREX**

Clear Exclusive.

### **Syntax**

CLREX{*cond*}

Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

### **Operation**

Use CLREX to make the next STREX, STREXB, or STREXH instruction write 1 to its destination register and fail to perform the store. It is useful in exception handler code to force the failure of the store exclusive if the exception occurs between a load exclusive instruction and the matching store exclusive instruction in a synchronization operation.

See *Synchronization primitives on page 37* for more information.

## **Condition flags**

This instruction does not change the flags.

### **Examples**

CLREX