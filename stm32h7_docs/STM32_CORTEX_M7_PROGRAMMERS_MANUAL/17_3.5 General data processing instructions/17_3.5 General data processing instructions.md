# **3.5 General data processing instructions**

*[Table](#page-0-0) 30* shows the data processing instructions:

**Table 30. Data processing instructions** 

<span id="page-0-0"></span>

| Mnemonic | Brief description                                        | See                                    |
|----------|----------------------------------------------------------|----------------------------------------|
| ADC      | Add with Carry                                           | ADD, ADC, SUB, SBC, and RSB on page 87 |
| ADD      | Add                                                      | ADD, ADC, SUB, SBC, and RSB on page 87 |
| ADDW     | Add                                                      | ADD, ADC, SUB, SBC, and RSB on page 87 |
| AND      | Logical AND                                              | AND, ORR, EOR, BIC, and ORN on page 89 |
| ASR      | Arithmetic Shift Right                                   | ASR, LSL, LSR, ROR, and RRX on page 90 |
| BIC      | Bit Clear                                                | AND, ORR, EOR, BIC, and ORN on page 89 |
| CLZ      | Count leading zeros                                      | CLZ on page 91                         |
| CMN      | Compare Negative                                         | CMP and CMN on page 92                 |
| CMP      | Compare                                                  | CMP and CMN on page 92                 |
| EOR      | Exclusive OR                                             | AND, ORR, EOR, BIC, and ORN on page 89 |
| LSL      | Logical Shift Left                                       | ASR, LSL, LSR, ROR, and RRX on page 90 |
| LSR      | Logical Shift Right                                      | ASR, LSL, LSR, ROR, and RRX on page 90 |
| MOV      | Move                                                     | MOV and MVN on page 93                 |
| MOVT     | Move Top                                                 | MOVT on page 94                        |
| MOVW     | Move 16-bit constant                                     | MOV and MVN on page 93                 |
| MVN      | Move NOT                                                 | MOV and MVN on page 93                 |
| ORN      | Logical OR NOT                                           | AND, ORR, EOR, BIC, and ORN on page 89 |
| ORR      | Logical OR                                               | AND, ORR, EOR, BIC, and ORN on page 89 |
| RBIT     | Reverse Bits                                             | REV, REV16, REVSH, and RBIT on page 95 |
| REV      | Reverse byte order in a word                             | REV, REV16, REVSH, and RBIT on page 95 |
| REV16    | Reverse byte order in each halfword                      | REV, REV16, REVSH, and RBIT on page 95 |
| REVSH    | Reverse byte order in bottom halfword and sign<br>extend | REV, REV16, REVSH, and RBIT on page 95 |
| ROR      | Rotate Right                                             | ASR, LSL, LSR, ROR, and RRX on page 90 |
| RRX      | Rotate Right with Extend                                 | ASR, LSL, LSR, ROR, and RRX on page 90 |
| RSB      | Reverse Subtract                                         | ADD, ADC, SUB, SBC, and RSB on page 87 |
| SADD16   | Signed Add 16                                            | SADD16 and SADD8 on page 96            |
| SADD8    | Signed Add 8                                             | SADD16 and SADD8 on page 96            |
| SASX     | Signed Add and Subtract with Exchange                    | SASX and SSAX on page 101              |
| SSAX     | Signed Subtract and Add with Exchange                    | SASX and SSAX on page 101              |
| SBC      | Subtract with Carry                                      | ADD, ADC, SUB, SBC, and RSB on page 87 |
| SHADD16  | Signed Halving Add 16                                    | SHADD16 and SHADD8 on page 97          |
|          |                                                          |                                        |

![](_page_0_Picture_6.jpeg)

PM0253 Rev 5 85/254

**Table 30. Data processing instructions (continued)**

| Mnemonic | Brief description                                      | See                                    |
|----------|--------------------------------------------------------|----------------------------------------|
| SHADD8   | Signed Halving Add 8                                   | SHADD16 and SHADD8 on page 97          |
| SHASX    | Signed Halving Add and Subtract with Exchange          | SHASX and SHSAX on page 98             |
| SHSAX    | Signed Halving Subtract and Add with Exchange          | SHASX and SHSAX on page 98             |
| SHSUB16  | Signed Halving Subtract 16                             | SHSUB16 and SHSUB8 on page 99          |
| SHSUB8   | Signed Halving Subtract 8                              | SHSUB16 and SHSUB8 on page 99          |
| SSUB16   | Signed Subtract 16                                     | SSUB16 and SSUB8 on page 100           |
| SSUB8    | Signed Subtract 8                                      | SSUB16 and SSUB8 on page 100           |
| SUB      | Subtract                                               | ADD, ADC, SUB, SBC, and RSB on page 87 |
| SUBW     | Subtract                                               | ADD, ADC, SUB, SBC, and RSB on page 87 |
| TEQ      | Test Equivalence                                       | TST and TEQ on page 102                |
| TST      | Test                                                   | TST and TEQ on page 102                |
| UADD16   | Unsigned Add 16                                        | UADD16 and UADD8 on page 103           |
| UADD8    | Unsigned Add 8                                         | UADD16 and UADD8 on page 103           |
| UASX     | Unsigned Add and Subtract with Exchange                | UASX and USAX on page 104              |
| USAX     | Unsigned Subtract and Add with Exchange                | UASX and USAX on page 104              |
| UHADD16  | Unsigned Halving Add 16                                | UHADD16 and UHADD8 on page 105         |
| UHADD8   | Unsigned Halving Add 8                                 | UHADD16 and UHADD8 on page 105         |
| UHASX    | Unsigned Halving Add and Subtract with Exchange        | UHASX and UHSAX on page 106            |
| UHSAX    | Unsigned Halving Subtract and Add with Exchange        | UHASX and UHSAX on page 106            |
| UHSUB16  | Unsigned Halving Subtract 16                           | UHSUB16 and UHSUB8 on page 107         |
| UHSUB8   | Unsigned Halving Subtract 8                            | UHSUB16 and UHSUB8 on page 107         |
| USAD8    | Unsigned Sum of Absolute Differences                   | USAD8 on page 108                      |
| USADA8   | Unsigned Sum of Absolute Differences and<br>Accumulate | USADA8 on page 109                     |
| USUB16   | Unsigned Subtract 16                                   | USUB16 and USUB8 on page 110           |
| USUB8    | Unsigned Subtract 8                                    | USUB16 and USUB8 on page 110           |
|          |                                                        |                                        |

### <span id="page-2-0"></span>**3.5.1 ADD, ADC, SUB, SBC, and RSB**

Add, Add with carry, Subtract, Subtract with carry, and Reverse Subtract.

### **Syntax**

```
op{S}{cond} {Rd,} Rn, Operand2
op{cond} {Rd,} Rn, #imm12 ; ADD and SUB only
Where:
op Is one of:
           ADD Add.
           ADC Add with Carry.
           SUB Subtract.
           SBC Subtract with Carry.
           RSB Reverse Subtract.
S Is an optional suffix. If S is specified, the condition code flags are updated on 
           the result of the operation, see Conditional execution on page 68.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register. If Rd is omitted, the destination register is Rn.
Rn Is the register holding the first operand.
Operand2 Is a flexible second operand. See Flexible second operand on page 64 for 
           details of the options.
imm12 Is any value in the range 0-4095.
```

#### **Operation**

The ADD instruction adds the value of *Operand2* or *imm12* to the value in *Rn*.

The ADC instruction adds the values in *Rn* and *Operand2*, together with the carry flag.

The SUB instruction subtracts the value of *Operand2* or *imm12* from the value in *Rn*.

The SBC instruction subtracts the value of *Operand2* from the value in *Rn*. If the carry flag is clear, the result is reduced by one.

The RSB instruction subtracts the value in *Rn* from the value of *Operand2*. This is useful because of the wide range of options for *Operand2*.

Use ADC and SBC to synthesize multiword arithmetic, see *[Multiword arithmetic examples](#page-3-0)  [on page](#page-3-0) 88*.

See also *ADR on page 73*.

ADDW is equivalent to the ADD syntax that uses the *imm12* operand. SUBW is equivalent to the SUB syntax that uses the *imm12* operand.

PM0253 Rev 5 87/254

### **Restrictions**

In these instructions:

- *Operand2* must not be SP and must not be PC
- *Rd* can be SP only in ADD and SUB, and only with the additional restrictions:
  - *Rn* must also be SP.
  - Any shift in *Operand2* must be limited to a maximum of 3 bits using LSL.
- *Rn* can be SP only in ADD and SUB
- *Rd* can be PC only in the ADD{*cond*} PC, PC, Rm instruction where:
  - The S suffix must not be specified.
  - *Rm* must not be PC and must not be SP.
  - If the instruction is conditional, it must be the last instruction in the IT block.
- With the exception of the ADD{*cond*} PC, PC, Rm instruction, *Rn* can be PC only in ADD and SUB, and only with the additional restrictions:
  - The S suffix must not be specified.
  - The second operand must be a constant in the range 0 to 4095.
  - When using the PC for an addition or a subtraction, bits[1:0] of the PC are rounded to 0b00 before performing the calculation, making the base address for the calculation word-aligned.
  - If the user wants to generate the address of an instruction, the constant has to be adjusted based on the value of the PC. Arm recommends using the ADR instruction instead of ADD or SUB with *Rn* equal to the PC, because the assembler automatically calculates the correct constant for the ADR instruction.

When *Rd* is PC in the ADD{*cond*} PC, PC, Rm instruction:

- Bit[0] of the value written to the PC is ignored.
- A branch occurs to the address created by forcing bit[0] of that value to 0.

#### **Condition flags**

If S is specified, these instructions update the N, Z, C and V flags according to the result.

#### **Examples**

```
ADD R2, R1, R3
SUBS R8, R6, #240 ; Sets the flags on the result.
RSB R4, R4, #1280 ; Subtracts contents of R4 from 1280.
ADCHI R11, R0, R3 ; Only executed if C flag set and Z.
                        ; flag clear.
```

#### <span id="page-3-0"></span>**Multiword arithmetic examples**

*[Example 3-4: 64-bit addition](#page-3-1)* shows two instructions that add a 64-bit integer contained in R2 and R3 to another 64-bit integer contained in R0 and R1, and place the result in R4 and R5.

### <span id="page-3-1"></span>**Example 3-4: 64-bit addition**

```
ADDS R4, R0, R2 ; Add the least significant words.
ADC R5, R1, R3 ; Add the most significant words with carry.
```

The multiword values do not have to use consecutive registers. *[Example 3-5: 96-bit](#page-4-1)*

*[subtraction](#page-4-1)* shows instructions that subtract a 96-bit integer contained in R9, R1, and R11 from another contained in R6, R2, and R8. The example stores the result in R6, R9, and R2.

#### <span id="page-4-1"></span>**Example 3-5: 96-bit subtraction**

```
SUBS R6, R6, R9 ; Subtract the least significant words.
SBCS R9, R2, R1 ; Subtract the middle words with carry.
SBC R2, R8, R11 ; Subtract the most significant words with 
                     ; carry.
```

### <span id="page-4-0"></span>**3.5.2 AND, ORR, EOR, BIC, and ORN**

Logical AND, OR, Exclusive OR, Bit Clear, and OR NOT.

#### **Syntax**

```
op{S}{cond} {Rd,} Rn, Operand2
Where:
op Is one of:
           AND Logical AND.
           ORR Logical OR, or bit set.
           EOR Logical Exclusive OR.
           BIC Logical AND NOT, or bit clear.
           ORN Logical OR NOT.
S Is an optional suffix. If S is specified, the condition code flags are updated on 
           the result of the operation, see Conditional execution on page 68.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the register holding the first operand.
Operand2 Is a flexible second operand. See Flexible second operand on page 64 for
```

#### **Operation**

The AND, EOR, and ORR instructions perform bitwise AND, Exclusive OR, and OR operations on the values in *Rn* and *Operand2*.

The BIC instruction performs an AND operation on the bits in *Rn* with the complements of the corresponding bits in the value of *Operand2*.

The ORN instruction performs an OR operation on the bits in *Rn* with the complements of the corresponding bits in the value of *Operand2*.

### **Restrictions**

Do not use SP and do not use PC.

details of the options.

![](_page_4_Picture_15.jpeg)

PM0253 Rev 5 89/254

#### **Condition flags**

If S is specified, these instructions:

- Update the N and Z flags according to the result.
- Can update the C flag during the calculation of *Operand2*, see *[Example 3-5: 96-bit](#page-4-1)  [subtraction on page 89](#page-4-1)*.
- Do not affect the V flag.

#### **Examples**

```
AND R9, R2, #0xFF00
ORREQ R2, R0, R5
ANDS R9, R8, #0x19
EORS R7, R11, #0x18181818 
BIC R0, R1, #0xab
ORN R7, R11, R14, ROR #4
ORNS R7, R11, R14, ASR #32
```

### <span id="page-5-0"></span>**3.5.3 ASR, LSL, LSR, ROR, and RRX**

Arithmetic Shift Right, Logical Shift Left, Logical Shift Right, Rotate Right, and Rotate Right with Extend.

### **Syntax**

```
op{S}{cond} Rd, Rm, Rs
op{S}{cond} Rd, Rm, #n
RRX{S}{cond} Rd, Rm
Where:
```

### *op* Is one of:

```
ASR Arithmetic Shift Right.
LSL Logical Shift Left.
LSR Logical Shift Right.
ROR Rotate Right.
```

S Is an optional suffix. If S is specified, the condition code flags are updated on the result of the operation, see *Conditional execution on page 68*.

*Rd* Is the destination register.

*Rm* Is the register holding the value to be shifted.

*Rs* Is the register holding the shift length to apply to the value in *Rm*. Only the least significant byte is used and can be in the range 0 to 255.

*n* Is the shift length. The range of shift length depends on the instruction:

```
ASR Shift length from 1 to 32
LSL Shift length from 0 to 31
LSR Shift length from 1 to 32
ROR Shift length from 1 to 31
```

MOVS Rd, Rm is the preferred syntax for LSLS Rd, Rm, #0.

### **Operation**

ASR, LSL, LSR, and ROR move the bits in the register *Rm* to the left or right by the number of places specified by constant *n* or register *Rs*.

RRX moves the bits in register *Rm* to the right by 1.

In all these instructions, the result is written to *Rd*, but the value in register *Rm* remains unchanged. For details on what result is generated by the different instructions, see *Shift operations on page 65*.

#### **Restrictions**

Do not use SP and do not use PC.

### **Condition flags**

If S is specified:

- These instructions update the N and Z flags according to the result.
- The C flag is updated to the last bit shifted out, except when the shift length is 0, see *Shift operations on page 65*.

### **Examples**

```
ASR R7, R8, #9 ; Arithmetic shift right by 9 bits.
LSLS R1, R2, #3 ; Logical shift left by 3 bits with flag update.
LSR R4, R5, #6 ; Logical shift right by 6 bits.
ROR R4, R5, R6 ; Rotate right by the value in the bottom byte of 
                 ; R6.
RRX R4, R5 ; Rotate right with extend.
```

# <span id="page-6-0"></span>**3.5.4 CLZ**

Count Leading Zeros.

#### **Syntax**

```
CLZ{cond} Rd, Rm
```

## Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register. *Rm* Is the operand register.

#### **Operation**

The CLZ instruction counts the number of leading zeros in the value in *Rm* and returns the result in *Rd*. The result value is 32 if no bits are set and zero if bit[31] is set.

#### **Restrictions**

Do not use SP and do not use PC.

#### **Condition flags**

This instruction does not change the flags.

![](_page_6_Picture_27.jpeg)

PM0253 Rev 5 91/254

#### **Examples**

```
CLZ R4,R9
CLZNE R2,R3
```

### <span id="page-7-0"></span>**3.5.5 CMP and CMN**

Compare and Compare Negative.

#### **Syntax**

```
CMP{cond} Rn, Operand2
CMN{cond} Rn, Operand2
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rn* Is the register holding the first operand.

*Operand2* Is a flexible second operand. See *Flexible second operand on page 64* for

details of the options.

#### **Operation**

These instructions compare the value in a register with *Operand2*. They update the condition flags on the result, but do not write the result to a register.

The CMP instruction subtracts the value of *Operand2* from the value in *Rn*. This is the same as a SUBS instruction, except that the result is discarded.

The CMN instruction adds the value of *Operand2* to the value in *Rn*. This is the same as an ADDS instruction, except that the result is discarded.

### **Restrictions**

In these instructions:

- Do not use PC.
- *Operand2* must not be SP.

### **Condition flags**

These instructions update the N, Z, C and V flags according to the result.

#### **Examples**

```
CMP R2, R9
CMN R0, #6400
CMPGT SP, R7, LSL #2
```

![](_page_7_Picture_25.jpeg)

# <span id="page-8-0"></span>**3.5.6 MOV and MVN**

Move and Move NOT.

#### **Syntax**

```
MOV{S}{cond} Rd, Operand2
MOV{cond} Rd, #imm16
MVN{S}{cond} Rd, Operand2
```

#### Where:

S Is an optional suffix. If S is specified, the condition code flags are updated on

the result of the operation, see *Conditional execution on page 68*.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register.

*Operand2* Is a flexible second operand. See *Flexible second operand on page 64* for

details of the options.

*imm16* Is any value in the range 0-65535.

#### **Operation**

The MOV instruction copies the value of *Operand2* into *Rd*.

When *Operand2* in a MOV instruction is a register with a shift other than LSL #0, the preferred syntax is the corresponding shift instruction:

- ASR{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, ASR #n.
- LSL{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, LSL #n if *n* != 0.
- LSR{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, LSR #n.
- ROR{S}{cond} Rd, Rm, #n is the preferred syntax for MOV{S}{cond} Rd, Rm, ROR #n.
- RRX{S}{cond} Rd, Rm is the preferred syntax for MOV{S}{cond} Rd, Rm, RRX.

Also, the MOV instruction permits additional forms of *Operand2* as synonyms for shift instructions:

- MOV{S}{cond} Rd, Rm, ASR Rs is a synonym for ASR{S}{cond} Rd, Rm, Rs.
- MOV{S}{cond} Rd, Rm, LSL Rs is a synonym for LSL{S}{cond} Rd, Rm, Rs.
- MOV{S}{cond} Rd, Rm, LSR Rs is a synonym for LSR{S}{cond} Rd, Rm, Rs.
- MOV{S}{cond} Rd, Rm, ROR Rs is a synonym for ROR{S}{cond} Rd, Rm, Rs

See *[ASR, LSL, LSR, ROR, and RRX on page](#page-5-0) 90*.

The MVN instruction takes the value of *Operand2*, performs a bitwise logical NOT operation on the value, and places the result into *Rd*.

The MOVW instruction provides the same function as MOV, but is restricted to using the *imm16* operand.

![](_page_8_Picture_30.jpeg)

PM0253 Rev 5 93/254

### **Restrictions**

The user can use SP and PC only in the MOV instruction, with the following restrictions:

- The second operand must be a register without shift.
- The S suffix must not be specified.

When *Rd* is PC in a MOV instruction:

- Bit[0] of the value written to the PC is ignored.
- A branch occurs to the address created by forcing bit[0] of that value to 0.

Though it is possible to use MOV as a branch instruction, Arm strongly recommends the use of a BX or BLX instruction to branch for software portability to the Arm instruction set.

#### **Condition flags**

If S is specified, these instructions:

- Update the N and Z flags according to the result.
- Can update the C flag during the calculation of *Operand2*, see *Flexible second operand on page 64*.
- Do not affect the V flag.

### **Example**

```
MOVS R11, #0x000B ; Write value of 0x000B to R11, flags get 
                    ; updated.
MOV R1, #0xFA05 ; Write value of 0xFA05 to R1, flags are not 
                    ; updated.
MOVS R10, R12 ; Write value in R12 to R10, flags get updated.
MOV R3, #23 ; Write value of 23 to R3.
MOV R8, SP ; Write value of stack pointer to R8.
MVNS R2, #0xF ; Write value of 0xFFFFFFF0 (bitwise inverse of
                    ; 0xF) to the R2 and update flags.
```

# <span id="page-9-0"></span>**3.5.7 MOVT**

Move Top.

#### **Syntax**

```
MOVT{cond} Rd, #imm16
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register. *imm16* Is a 16-bit immediate constant.

# **Operation**

MOVT writes a 16-bit immediate value, *imm16*, to the top halfword, *Rd*[31:16], of its destination register. The write does not affect *Rd*[15:0].

The MOV, MOVT instruction pair enables to generate any 32-bit constant.

# **Restrictions**

*Rd* must not be SP and must not be PC.

# **Condition flags**

This instruction does not change the flags.

### **Examples**

```
MOVT R3, #0xF123 ; Write 0xF123 to upper halfword of R3, lower 
                  ; halfword and APSR are unchanged.
```

### <span id="page-10-0"></span>**3.5.8 REV, REV16, REVSH, and RBIT**

Reverse bytes and Reverse bits.

### **Syntax**

```
op{cond} Rd, Rn
```

#### Where:

*op* Is one of:

REV Reverse byte order in a word.

REV16 Reverse byte order in each halfword independently.

REVSH Reverse byte order in the bottom halfword, and sign extend to 32

bits.

RBIT Reverse the bit order in a 32-bit word.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register.

*Rn* Is the register holding the operand.

### **Operation**

Use these instructions to change endianness of data:

REV converts either:

- 32-bit big-endian data into little-endian data.
- 32-bit little-endian data into big-endian data.

REV16 converts either:

- 16-bit big-endian data into little-endian data.
- 16-bit little-endian data into big-endian data.

REVSH converts either:

- 16-bit signed big-endian data into 32-bit signed little-endian data.
- 16-bit signed little-endian data into 32-bit signed big-endian data.

### **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions do not change the flags.

![](_page_10_Picture_35.jpeg)

PM0253 Rev 5 95/254

# **Examples**

```
REV R3, R7 ; Reverse byte order of value in R7 and write it to R3.
REV16 R0, R0 ; Reverse byte order of each 16-bit halfword in R0.
REVSH R0, R5 ; Reverse Signed Halfword.
REVHS R3, R7 ; Reverse with Higher or Same condition.
RBIT R7, R8 ; Reverse bit order of value in R8 and write the result 
              ; to R7.
```

# <span id="page-11-0"></span>**3.5.9 SADD16 and SADD8**

Signed Add 16 and Signed Add 8.

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
           SADD16 Performs two 16-bit signed integer additions.
           SADD8 Performs four 8-bit signed integer additions.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first register holding the operand.
Rm Is the second register holding the operand.
```

#### **Operation**

Use these instructions to perform a halfword or byte add in parallel.

The SADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Writes the result in the corresponding halfwords of the destination register.

The SADD8 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Writes the result in the corresponding bytes of the destination register.

#### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
SADD16 R1, R0 ; Adds the halfwords in R0 to the corresponding 
 ; halfwords of R1 and writes to corresponding halfword 
                ; of R1.
SADD8 R4, R0, R5 ; Adds bytes of R0 to the corresponding byte in R5 and
 ; writes to the corresponding byte in R4.
```

![](_page_11_Picture_23.jpeg)

# <span id="page-12-0"></span>**3.5.10 SHADD16 and SHADD8**

Signed Halving Add 16 and Signed Halving Add 8.

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
          SHADD16 Signed Halving Add 16
          SHADD8 Signed Halving Add 8
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first operand register.
Rm Is the second operand register.
```

### **Operation**

Use these instructions to add 16-bit and 8-bit data and then to halve the result before writing the result to the destination register.

The SHADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the halfword results in the destination register.

The SHADDB8 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the byte results in the destination register.

## **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
SHADD16 R1, R0 ; Adds halfwords in R0 to corresponding halfword of R1
 ; and writes halved result to corresponding halfword in 
                ; R1.
SHADD8 R4, R0, R5 ; Adds bytes of R0 to corresponding byte in R5 and 
 ; writes halved result to corresponding byte in R4.
```

PM0253 Rev 5 97/254

# <span id="page-13-0"></span>**3.5.11 SHASX and SHSAX**

Signed Halving Add and Subtract with Exchange and Signed Halving Subtract and Add with Exchange.

#### **Syntax**

```
op{cond} {Rd}, Rn, Rm
```

#### Where:

*op* Is one of:

SHASX Add and Subtract with Exchange and Halving. SHSAX Subtract and Add with Exchange and Halving.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register.

*Rn*, *Rm* Are registers holding the first and second operands.

#### **Operation**

The SHASX instruction:

- 1. Adds the top halfword of the first operand with the bottom halfword of the second operand.
- 2. Writes the halfword result of the addition to the top halfword of the destination register, shifted by one bit to the right causing a divide by two, or halving.
- 3. Subtracts the top halfword of the second operand from the bottom highword of the first operand.
- 4. Writes the halfword result of the division in the bottom halfword of the destination register, shifted by one bit to the right causing a divide by two, or halving.

The SHSAX instruction:

- 1. Subtracts the bottom halfword of the second operand from the top highword of the first operand.
- 2. Writes the halfword result of the addition to the bottom halfword of the destination register, shifted by one bit to the right causing a divide by two, or halving.
- 3. Adds the bottom halfword of the first operand with the top halfword of the second operand.
- 4. Writes the halfword result of the division in the top halfword of the destination register, shifted by one bit to the right causing a divide by two, or halving.

### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not affect the condition code flags.

#### **Examples**

```
SHASX R7, R4, R2 ; Adds top halfword of R4 to bottom halfword of 
 ; R2 and writes halved result to top halfword of
 ; R7. Subtracts top halfword of R2 from bottom
```

![](_page_13_Picture_30.jpeg)

```
 ; halfword of R4 and writes halved result to 
                   ; bottom halfword of R7.
SHSAX R0, R3, R5 ; Subtracts bottom halfword of R5 from top
 ; halfword of R3 and writes halved result to top 
                   ; halfword of R0.
 ; Adds top halfword of R5 to bottom halfword of
 ; R3 and writes halved result to bottom halfword 
                   ; of R0.
```

# <span id="page-14-0"></span>**3.5.12 SHSUB16 and SHSUB8**

Signed Halving Subtract 16 and Signed Halving Subtract 8.

#### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
           SHSUB16 Signed Halving Subtract 16.
           SHSUB8 Signed Halving Subtract 8.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first operand register.
Rm Is the second operand register
```

#### **Operation**

Use these instructions to add 16-bit and 8-bit data and then to halve the result before writing the result to the destination register.

The SHSUB16 instruction:

- 1. Subtracts each halfword of the second operand from the corresponding halfwords of the first operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the halved halfword results in the destination register.

The SHSUBB8 instruction:

- 1. Subtracts each byte of the second operand from the corresponding byte of the first operand.
- 2. Shuffles the result by one bit to the right, halving the data.
- 3. Writes the corresponding signed byte results in the destination register.

### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not change the flags.

![](_page_14_Picture_21.jpeg)

PM0253 Rev 5 99/254

#### **Examples**

```
SHSUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding
 ; halfword of R1 and writes to corresponding halfword 
                 ; of R1.
SHSUB8 R4, R0, R5 ; Subtracts bytes of R0 from corresponding byte in R5,
 ; and writes to corresponding byte in R4.
```

### <span id="page-15-0"></span>**3.5.13 SSUB16 and SSUB8**

Signed Subtract 16 and Signed Subtract 8.

#### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
           SSUB16 Performs two 16-bit signed integer subtractions.
           SSUB8 Performs four 8-bit signed integer subtractions.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first operand register.
```

### **Operation**

Use these instructions to change endianness of data.

*Rm* Is the second operand register.

The SSUB16 instruction:

- 1. Subtracts each halfword from the second operand from the corresponding halfword of the first operand.
- 2. Writes the difference result of two signed halfwords in the corresponding halfword of the destination register.

The SSUB8 instruction:

- 1. Subtracts each byte of the second operand from the corresponding byte of the first operand.
- 2. Writes the difference result of four signed bytes in the corresponding byte of the destination register.

#### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not change the flags.

### **Examples**

```
SSUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding 
halfword of R1
```

![](_page_15_Picture_23.jpeg)

```
 ; halfword of R1 and writes to corresponding halfword 
                ; of R1.
SSUB8 R4, R0, R5 ; Subtracts bytes of R5 from corresponding byte in 
 ; R0, and writes to corresponding byte of R4.
```

### <span id="page-16-0"></span>**3.5.14 SASX and SSAX**

Signed Add and Subtract with Exchange and Signed Subtract and Add with Exchange.

## **Syntax**

```
op{cond} {Rd}, Rm, Rn
Where:
op Is one of:
           SASX Signed Add and Subtract with Exchange.
           SSAX Signed Subtract and Add with Exchange.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn, Rm Are registers holding the first and second operands.
```

#### **Operation**

The SASX instruction:

- 1. Adds the signed top halfword of the first operand with the signed bottom halfword of the second operand.
- 2. Writes the signed result of the addition to the top halfword of the destination register.
- 3. Subtracts the signed bottom halfword of the second operand from the top signed highword of the first operand.
- 4. Writes the signed result of the subtraction to the bottom halfword of the destination register.

#### The SSAX instruction:

- 1. Subtracts the signed bottom halfword of the second operand from the top signed highword of the first operand.
- 2. Writes the signed result of the addition to the bottom halfword of the destination register.
- 3. Adds the signed top halfword of the first operand with the signed bottom halfword of the second operand.
- 4. Writes the signed result of the subtraction to the top halfword of the destination register.

#### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not affect the condition code flags.

#### **Examples**

```
SASX R0, R4, R5 ; Adds top halfword of R4 to bottom halfword of R5
```

![](_page_16_Picture_24.jpeg)

PM0253 Rev 5 101/254

```
 ; and writes to top halfword of R0.
 ; Subtracts bottom halfword of R5 from top halfword 
 ; of R4 and writes to bottom halfword of R0.
SSAX R7, R3, R2 ; Subtracts top halfword of R2 from bottom halfword 
 ; of R3 and writes to bottom halfword of R7.
 ; Adds top halfword of R3 with bottom halfword of R
 ; R2 and writes to top halfword of R7.
```

### <span id="page-17-0"></span>**3.5.15 TST and TEQ**

Test bits and Test Equivalence.

#### **Syntax**

```
TST{cond} Rn, Operand2
TEQ{cond} Rn, Operand2
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rn* Is the register holding the first operand.

*Operand2* Is a flexible second operand. See *Flexible second operand on page 64* for

details of the options.

#### **Operation**

These instructions test the value in a register against *Operand2*. They update the condition flags based on the result, but do not write the result to a register.

The TST instruction performs a bitwise AND operation on the value in *Rn* and the value of *Operand2*. This is the same as the ANDS instruction, except that it discards the result.

To test whether a bit of *Rn* is 0 or 1, use the TST instruction with an *Operand2* constant that has that bit set to 1 and all other bits cleared to 0.

The TEQ instruction performs a bitwise Exclusive OR operation on the value in *Rn* and the value of *Operand2*. This is the same as the EORS instruction, except that it discards the result.

Use the TEQ instruction to test if two values are equal without affecting the V or C flags.

TEQ is also useful for testing the sign of a value. After the comparison, the N flag is the logical Exclusive OR of the sign bits of the two operands.

### **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions:

- Update the N and Z flags according to the result.
- Can update the C flag during the calculation of *Operand2*, see *Flexible second operand on page 64*.
- Do not affect the V flag.

![](_page_17_Picture_26.jpeg)

#### **Examples**

```
TST R0, #0x3F8 ; Perform bitwise AND of R0 value to 0x3F8, 
                   ; APSR is updated but result is discarded
TEQEQ R10, R9 ; Conditionally test if value in R10 is equal to 
                   ; value in R9, APSR is updated but result is 
                   ; discarded.
```

### <span id="page-18-0"></span>**3.5.16 UADD16 and UADD8**

Unsigned Add 16 and Unsigned Add 8.

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
           UADD16 Performs two 16-bit unsigned integer additions.
           UADD8 Performs four 8-bit unsigned integer additions.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first register holding the operand.
Rm Is the second register holding the operand.
```

### **Operation**

Use these instructions to add 16- and 8-bit unsigned data.

The UADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Writes the unsigned result in the corresponding halfwords of the destination register.

The UADD16 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Writes the unsigned result in the corresponding byte of the destination register.

#### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
UADD16 R1, R0 ; Adds halfwords in R0 to corresponding halfword of R1, 
 ; writes to corresponding halfword of R1.
UADD8 R4, R0, R5 ; Adds bytes of R0 to corresponding byte in R5 and 
 ; writes to corresponding byte in R4.
```

![](_page_18_Picture_22.jpeg)

PM0253 Rev 5 103/254

# <span id="page-19-0"></span>**3.5.17 UASX and USAX**

Add and Subtract with Exchange and Subtract and Add with Exchange.

#### **Syntax**

```
op{cond} {Rd}, Rn, Rm
Where:
op Is one of:
           UASX Add and Subtract with Exchange.
           USAX Subtract and Add with Exchange.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn, Rm Are registers holding the first and second operands.
```

### **Operation**

The UASX instruction:

- 1. Subtracts the top halfword of the second operand from the bottom halfword of the first operand.
- 2. Writes the unsigned result from the subtraction to the bottom halfword of the destination register.
- 3. Adds the top halfword of the first operand with the bottom halfword of the second operand.
- 4. Writes the unsigned result of the addition to the top halfword of the destination register.

#### The USAX instruction:

- 1. Adds the bottom halfword of the first operand with the top halfword of the second operand.
- 2. Writes the unsigned result of the addition to the bottom halfword of the destination register.
- 3. Subtracts the bottom halfword of the second operand from the top halfword of the first operand.
- 4. Writes the unsigned result from the subtraction to the top halfword of the destination register.

# **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not affect the condition code flags.

#### **Examples**

```
UASX R0, R4, R5 ; Adds top halfword of R4 to bottom halfword of R5 
 ; and writes to top halfword of R0.
 ; Subtracts bottom halfword of R5 from top halfword 
 ; of R0 and writes to bottom halfword of R0.
USAX R7, R3, R2 ; Subtracts top halfword of R2 from bottom halfword 
 ; of R3 and writes to bottom halfword of R7.
 ; Adds top halfword of R3 to bottom halfword of R2
```

![](_page_19_Picture_24.jpeg)

; and writes to top halfword of R7.

### <span id="page-20-0"></span>**3.5.18 UHADD16 and UHADD8**

Unsigned Halving Add 16 and Unsigned Halving Add 8.

### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
           UHADD16 Unsigned Halving Add 16.
           UHADD8 Unsigned Halving Add 8.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the register holding the first operand.
Rm Is the register holding the second operand.
```

#### **Operation**

Use these instructions to add 16- and 8-bit data and then to halve the result before writing the result to the destination register.

The UHADD16 instruction:

- 1. Adds each halfword from the first operand to the corresponding halfword of the second operand.
- 2. Shuffles the halfword result by one bit to the right, halving the data.
- 3. Writes the unsigned results to the corresponding halfword in the destination register.

The UHADD8 instruction:

- 1. Adds each byte of the first operand to the corresponding byte of the second operand.
- 2. Shuffles the byte result by one bit to the right, halving the data.
- 3. Writes the unsigned results in the corresponding byte in the destination register.

### **Restrictions**

Do not use SP and do not use PC*.*

#### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
UHADD16 R7, R3 ; Adds halfwords in R7 to corresponding halfword of R3 
 ; and writes halved result to corresponding halfword 
                 ; in R7.
UHADD8 R4, R0, R5 ; Adds bytes of R0 to corresponding byte in R5 and 
 ; writes halved result to corresponding byte in R4.
```

PM0253 Rev 5 105/254

# <span id="page-21-0"></span>**3.5.19 UHASX and UHSAX**

Unsigned Halving Add and Subtract with Exchange and Unsigned Halving Subtract and Add with Exchange.

#### **Syntax**

```
op{cond} {Rd}, Rn, Rm
```

#### Where:

*op* Is one of:

UHASX Add and Subtract with Exchange and Halving. UHSAX Subtract and Add with Exchange and Halving.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register.

*Rn*, *Rm* Are registers holding the first and second operands.

#### **Operation**

#### The UHASX instruction:

- 1. Adds the top halfword of the first operand with the bottom halfword of the second operand.
- 2. Shifts the result by one bit to the right causing a divide by two, or halving.
- 3. Writes the halfword result of the addition to the top halfword of the destination register.
- 4. Subtracts the top halfword of the second operand from the bottom highword of the first operand.
- 5. Shifts the result by one bit to the right causing a divide by two, or halving.
- 6. Writes the halfword result of the division in the bottom halfword of the destination register.

#### The UHSAX instruction:

- 1. Subtracts the bottom halfword of the second operand from the top highword of the first operand.
- 2. Shifts the result by one bit to the right causing a divide by two, or halving.
- 3. Writes the halfword result of the subtraction in the top halfword of the destination register.
- 4. Adds the bottom halfword of the first operand with the top halfword of the second operand.
- 5. Shifts the result by one bit to the right causing a divide by two, or halving.
- 6. Writes the halfword result of the addition to the bottom halfword of the destination register.

#### **Restrictions**

Do not use SP and do not use PC*.*

## **Condition flags**

These instructions do not affect the condition code flags.

### **Examples**

```
UHASX R7, R4, R2 ; Adds top halfword of R4 with bottom halfword of
```

![](_page_21_Picture_34.jpeg)

```
 ; R2 and writes halved result to top halfword of 
                  ; R7.
 ; Subtracts top halfword of R2 from bottom 
 ; halfword of R7 and writes halved result to 
                  ; bottom halfword of R7.
UHSAX R0, R3, R5 ; Subtracts bottom halfword of R5 from top
 ; halfword of R3 and writes halved result to top 
                  ; halfword of R0.
 ; Adds top halfword of R5 to bottom halfword of R3 
 ; and writes halved result to bottom halfword of 
                  ; R0.
```

## <span id="page-22-0"></span>**3.5.20 UHSUB16 and UHSUB8**

Unsigned Halving Subtract 16 and Unsigned Halving Subtract 8.

#### **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
            UHSUB16 Performs two unsigned 16-bit integer additions, halves the results, 
                     and writes the results to the destination register.
            UHSUB8 Performs four unsigned 8-bit integer additions, halves the results, 
                     and writes the results to the destination register.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first register holding the operand.
Rm Is the second register holding the operand.
```

#### **Operation**

Use these instructions to add 16-bit and 8-bit data and then to halve the result before writing the result to the destination register.

The UHSUB16 instruction:

- 1. Subtracts each halfword of the second operand from the corresponding halfword of the first operand.
- 2. Shuffles each halfword result to the right by one bit, halving the data.
- 3. Writes each unsigned halfword result to the corresponding halfwords in the destination register.

The UHSUB8 instruction:

- 1. Subtracts each byte of second operand from the corresponding byte of the first operand.
- 2. Shuffles each byte result by one bit to the right, halving the data.
- 3. Writes the unsigned byte results to the corresponding byte of the destination register.

### **Restrictions**

Do not use SP and do not use PC*.*

![](_page_22_Picture_19.jpeg)

PM0253 Rev 5 107/254

# **Condition flags**

These instructions do not change the flags.

### **Examples**

```
UHSUB16 R1, R0 ; Subtracts halfwords in R0 from corresponding 
 ; halfword of R1 and writes halved result to 
 ; corresponding halfword in R1.
UHSUB8 R4, R0, R5 ; Subtracts bytes of R5 from corresponding byte in R0 
 ; and writes halved result to corresponding byte in 
                 ; R4.
```

## **3.5.21 SEL**

Select Bytes. Selects each byte of its result from either its first operand or its second operand, according to the values of the GE flags.

### **Syntax**

```
SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
Where:
<c>, <q> Is a standard assembler syntax field.
<Rd> Is the destination register.
<Rn> Is the first operand register.
<Rm> Is the second operand register.
```

#### **Operation**

The SEL instruction:

- 1. Reads the value of each bit of APSR.GE.
- 2. Depending on the value of APSR.GE, assigns the destination register the value of either the first or second operand register.

### **Restrictions**

None.

### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
SADD16 R0, R1, R2 ; Set GE bits based on result.
SEL R0, R0, R3 ; Select bytes from R0 or R3, based on GE.
```

### <span id="page-23-0"></span>**3.5.22 USAD8**

Unsigned Sum of Absolute Differences.

#### **Syntax**

```
USAD8{cond}{Rd,} Rn, Rm
```

![](_page_23_Picture_24.jpeg)

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register. *Rn* Is the first operand register. *Rm* Is the second operand register.

#### **Operation**

The USAD8 instruction:

- 1. Subtracts each byte of the second operand register from the corresponding byte of the first operand register.
- 2. Adds the absolute values of the differences together.
- 1. Writes the result to the destination register.

#### **Restrictions**

Do not use SP and do not use PC*.*

### **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
USAD8 R1, R4, R0 ; Subtracts each byte in R0 from corresponding byte
 ; of R4 adds the differences and writes to R1.
USAD8 R0, R5 ; Subtracts bytes of R5 from corresponding byte in 
 ; R0, adds the differences and writes to R0.
```

### <span id="page-24-0"></span>**3.5.23 USADA8**

Unsigned Sum of Absolute Differences and Accumulate.

## **Syntax**

```
USADA8{cond}{Rd,} Rn, Rm, Ra
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rd* Is the destination register. *Rn* Is the first operand register. *Rm* Is the second operand register.

*Ra* Is the register that contains the accumulation value.

### **Operation**

The USADA8 instruction:

![](_page_24_Picture_26.jpeg)

PM0253 Rev 5 109/254

- 1. Subtracts each byte of the second operand register from the corresponding byte of the first operand register.
- 2. Adds the unsigned absolute differences together.
- 3. Adds the accumulation value to the sum of the absolute differences.
- 4. Writes the result to the destination register.

### **Restrictions**

Do not use SP and do not use PC*.*

# **Condition flags**

These instructions do not change the flags.

#### **Examples**

```
USADA8 R1, R0, R6 ; Subtracts bytes in R0 from corresponding halfword
 ; of R1 adds differences, adds value of R6, writes 
                   ; to R1.
USADA8 R4, R0, R5, R2 ; Subtracts bytes of R5 from corresponding byte in
 ; R0 adds differences, adds value of R2 writes to 
                   ; R4.
```

### <span id="page-25-0"></span>**3.5.24 USUB16 and USUB8**

Unsigned Subtract 16 and Unsigned Subtract 8.

# **Syntax**

```
op{cond}{Rd,} Rn, Rm
Where:
op Is one of:
          USUB16 Unsigned Subtract 16.
          USUB8 Unsigned Subtract 8.
cond Is an optional condition code. See Conditional execution on page 68.
Rd Is the destination register.
Rn Is the first operand register.
Rm Is the second operand register.
```

#### **Operation**

Use these instructions to subtract 16-bit and 8-bit data before writing the result to the destination register.

The USUB16 instruction:

- 1. Subtracts each halfword from the second operand register from the corresponding halfword of the first operand register.
- 2. Writes the unsigned result in the corresponding halfwords of the destination register.

The USUB8 instruction: