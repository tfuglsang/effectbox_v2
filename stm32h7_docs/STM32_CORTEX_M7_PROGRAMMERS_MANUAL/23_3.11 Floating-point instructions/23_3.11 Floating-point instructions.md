```
; branch table
BranchTable_H
   DCW ((CaseA - BranchTable_H)/2) ; CaseA offset calculation
   DCW ((CaseB - BranchTable_H)/2) ; CaseB offset calculation
   DCW ((CaseC - BranchTable_H)/2) ; CaseC offset calculation
CaseA
; an instruction sequence follows
CaseB
; an instruction sequence follows
CaseC
; an instruction sequence follows
```

# **3.11 Floating-point instructions**

This section provides the instruction set that the single-precision and double-precision FPU uses.

*[Table](#page-0-0) 37* shows the floating-point instructions.

These instructions are only available if the FPU is included, and enabled, in the system. See *Enabling the FPU on page 238* for information about enabling the floating-point unit.

**Table 37. Floating-point instructions** 

<span id="page-0-0"></span>

| Mnemonic | Brief description                                                                                                 | See                                                           |
|----------|-------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------|
| VABS     | Floating-point Absolute                                                                                           | VABS on page 153                                              |
| VADD     | Floating-point Add                                                                                                | VADD on page 153                                              |
| VCMP     | Compares two floating-point registers, or one<br>floating-point register and zero                                 | VCMP, VCMPE on page 154                                       |
| VCMPE    | Compares two floating-point registers, or one<br>floating-point register and zero with Invalid<br>Operation check | VCMP, VCMPE on page 154                                       |
| VCVT     | Converts between floating-point and integer                                                                       | VCVT between floating-point and fixed-point on<br>page 156    |
| VCVT     | Converts between floating-point and fixed point                                                                   | VCVT between floating-point and fixed-point on<br>page 156    |
| VCVTR    | Converts between floating-point and integer with<br>rounding                                                      | VCVT, VCVTR between floating-point and<br>integer on page 155 |
| VCVTB    | Converts half-precision value to single-precision                                                                 | VCVTB, VCVTT on page 157                                      |
| VCVTT    | Converts single-precision register to half-precision                                                              | VCVTB, VCVTT on page 157                                      |
| VDIV     | Floating-point Divide                                                                                             | VDIV on page 157                                              |
| VFMA     | Floating-point Fused Multiply Accumulate                                                                          | VFMA, VFMS on page 158                                        |
| VFNMA    | Floating-point Fused Negate Multiply Accumulate                                                                   | VFNMA, VFNMS on page 159                                      |
| VFMS     | Floating-point Fused Multiply Subtract                                                                            | VFMA, VFMS on page 158                                        |
| VFNMS    | Floating-point Fused Negate Multiply Subtract                                                                     | VFNMA, VFNMS on page 159                                      |
| VLDM     | Loads Multiple extension registers                                                                                | VLDM on page 159                                              |

![](_page_0_Picture_9.jpeg)

PM0253 Rev 5 151/254

**Table 37. Floating-point instructions (continued)**

| Mnemonic                            | Brief description                                                 | See                                                                          |
|-------------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------|
| VLDR                                | Loads an extension register from memory                           | VLDR on page 160                                                             |
| VMLA                                | Floating-point Multiply Accumulate                                | VMLA, VMLS on page 161                                                       |
| VMLS                                | Floating-point Multiply Subtract                                  | VMLA, VMLS on page 161                                                       |
| VMOV                                | Floating-point Move Immediate                                     | VMOV immediate on page 162                                                   |
| VMOV                                | Floating-point Move register                                      | VMOV register on page 162                                                    |
| VMOV                                | Copies Arm core register to single-precision                      | VMOV Arm core register to single-precision on<br>page 163                    |
| VMOV                                | Copies 2 Arm core registers to 2 single-precision                 | VMOV two Arm core registers to two single<br>precision registers on page 164 |
| VMOV                                | Copies between Arm core register to scalar                        | VMOV Arm core register to scalar on page 165                                 |
| VMOV                                | Copies between Scalar to Arm core register                        | VMOV scalar to Arm core register on page 163                                 |
| VMRS                                | Moves to Arm core register from floating-point<br>System register | VMRS on page 165                                                             |
| VMSR                                | Moves to floating-point System register from Arm<br>core register | VMSR on page 166                                                             |
| VMUL                                | Multiplies floating-point                                         | VMUL on page 166                                                             |
| VNEG                                | Floating-point negate                                             | VNEG on page 167                                                             |
| VNMLA                               | Floating-point multiply and add                                   | VNMLA, VNMLS, VNMUL on page 167                                              |
| VNMLS                               | Floating-point multiply and subtract                              | VNMLA, VNMLS, VNMUL on page 167                                              |
| VNMUL                               | Floating-point multiply                                           | VNMLA, VNMLS, VNMUL on page 167                                              |
| VPOP                                | Pop extension registers                                           | VPOP on page 168                                                             |
| VPUSH                               | Pushes extension registers                                        | VPUSH on page 169                                                            |
| VSQRT                               | Floating-point square root                                        | VSQRT on page 169                                                            |
| VSTM                                | Stores Multiple extension registers                               | VSTM on page 170                                                             |
| VSTR                                | Stores an extension register to memory                            | VSTR on page 170                                                             |
| VSUB                                | Floating-point Subtract                                           | VSUB on page 171                                                             |
| VSEL                                | Selects register, alternative to a pair of conditional<br>VMOV    | VSEL on page 172                                                             |
| VMAXNM,<br>VMINNM                   | Maximum, Minimum with IEEE754-2008 NaN<br>handling                | VMAXNM, VMINNM on page 172                                                   |
| VCVTA,<br>VCVTN,<br>VCVTP,<br>VCVTM | Float to integer conversion with directed rounding                | VCVTA, VCVTN, VCVTP, VCVTM on page 173                                       |

![](_page_1_Picture_4.jpeg)

**Table 37. Floating-point instructions (continued)**

| Mnemonic                                | Brief description                                                                | See                                                   |
|-----------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------|
| VRINTR,<br>VRINTX                       | Float to integer (in floating-point format)<br>conversion                        | VRINTR, VRINTX on page 173                            |
| VRINTA,<br>VRINTN,<br>VRINTP,<br>VRINTM | Float to integer (in floating-point format)<br>conversion with directed rounding | VRINTA, VRINTN, VRINTP, VRINTM, VRINTZ<br>on page 174 |

# <span id="page-2-0"></span>**3.11.1 VABS**

Floating-point Absolute.

# **Syntax**

VABS{*cond*}.F<32|64> *<Sd|Dd>*, *<Sm|Dm>*

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>*, *<Sm|Dm>*

Are the destination floating-point value and the operand floating-point value.

# **Operation**

This instruction:

- 1. Takes the absolute value of the operand floating-point register.
- 2. Places the results in the destination floating-point register.

#### **Restrictions**

There are no restrictions.

# **Condition flags**

This instruction does not change the flags.

## **Examples**

VABS.F32 S4, S6

# <span id="page-2-1"></span>**3.11.2 VADD**

Floating-point Add.

### **Syntax**

```
VADD{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
VADD{cond}.F64 {Dd,} Dn, Dm
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *<Sd|Dd>* Is the destination floating-point value.

![](_page_2_Picture_28.jpeg)

PM0253 Rev 5 153/254

```
<Sn|Dn>, <Sm|Dm>
```

Are the operand floating-point values.

### **Operation**

This instruction:

- 1. Adds the values in the two floating-point operand registers.
- 2. Places the results in the destination floating-point register.

#### **Restrictions**

There are no restrictions.

### **Condition flags**

This instruction does not change the flags.

### **Examples**

```
VADD.F32 S4, S6, S7
```

# <span id="page-3-0"></span>**3.11.3 VCMP, VCMPE**

Compares two floating-point registers, or one floating-point register and zero.

### **Syntax**

```
VCMP{E}{cond}.F<32|64> <Sd|Dd>, <Sm|Dm>
VCMP{E}{cond}.F<32|64> <Sd|Dd>, #0.0
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *E* If present, any NaN operand causes an Invalid Operation exception.

Otherwise, only a signaling NaN causes the exception.

*<Sd|Dd>* Is the floating-point operand to compare.

*<Sm|Dm>* Is the floating-point operand that is compared with.

#### **Operation**

This instruction:

- 1. Compares either:
  - Two floating-point registers.
    - Or one floating-point register and zero.
- 2. Writes the result to the FPSCR flags.

### **Restrictions**

This instruction can optionally raise an Invalid Operation exception if either operand is any type of NaN. It always raises an Invalid Operation exception if either operand is a signaling NaN.

## **Condition flags**

When this instruction writes the result to the FPSCR flags, the values are normally transferred to the Arm flags by a subsequent VMRS instruction, see *[VMRS on page](#page-14-1) 165*.

![](_page_3_Picture_34.jpeg)

#### **Examples**

```
VCMP.F32 S4, #0.0VCMP.F32 S4, S2
```

# <span id="page-4-0"></span>**3.11.4 VCVT, VCVTR between floating-point and integer**

Converts a value in a register from floating-point to and from a 32-bit integer.

### **Syntax**

```
VCVT{R}{cond}.Tm.F<32|64> <Sd|Dd>, <Sm|Dm>
VCVT{cond}.F<32|64>.Tm <Sd|Dd>, <Sm|Dm>
```

#### Where:

*R* If *R* is specified, the operation uses the rounding mode specified by the FPSCR.

If *R* is omitted. the operation uses the Round towards Zero rounding mode.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Tm* Is the data type for the operand. It must be one of:

• S32 signed 32-bit value.

• U32 unsigned 32-bit value.

*<Sd|Dd>*, *<Sm|Dm>*

Are the destination register and the operand register.

#### **Operation**

These instructions:

- 1. Either:
  - Convert a value in a register from floating-point value to a 32-bit integer.
  - Convert from a 32-bit integer to floating-point value.
- 2. Place the result in a second register.

The floating-point to integer operation normally uses the Round towards Zero rounding mode, but can optionally use the rounding mode specified by the FPSCR.

The integer to floating-point operation uses the rounding mode specified by the FPSCR.

### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

![](_page_4_Picture_29.jpeg)

PM0253 Rev 5 155/254

# <span id="page-5-0"></span>**3.11.5 VCVT between floating-point and fixed-point**

Converts a value in a register from floating-point to and from fixed-point.

# **Syntax**

```
VCVT{cond}.Td.F<32|64> <Sd|Dd>, <Sd|Dd>, #fbits
VCVT{cond}.F<32|64>.Td <Sd|Dd>, <Sd|Dd>, #fbits
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *Td* Is the data type for the fixed-point number. It must be one of:

- S16 signed 16-bit value.
- U16 unsigned 16-bit value.
- S32 signed 32-bit value.
- U32 unsigned 32-bit value.

*<Sd|Dd>* Is the destination register and the operand register. *fbits* Is the number of fraction bits in the fixed-point number:

- If *Td* is S16 or U16, *fbits* must be in the range 0-16.
- If *Td* is S32 or U32, *fbits* must be in the range 1-32.

#### **Operation**

This instruction:

- 1. Either
  - Converts a value in a register from floating-point to fixed-point.
  - Converts a value in a register from fixed-point to floating-point.
- 2. Places the result in a second register.

The floating-point values are single-precision or double-precision.

The fixed-point value can be 16-bit or 32-bit. Conversions from fixed-point values take their operand from the low-order bits of the source register and ignore any remaining bits.

Signed conversions to fixed-point values sign-extend the result value to the destination register width.

Unsigned conversions to fixed-point values zero-extend the result value to the destination register width.

The floating-point to fixed-point operation uses the Round towards Zero rounding mode. The fixed-point to floating-point operation uses the Round to Nearest rounding mode.

### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

# <span id="page-6-0"></span>**3.11.6 VCVTB, VCVTT**

Converts between half-precision and single-precision or double-precision without intermediate rounding.

#### **Syntax**

```
VCVT{y}{cond}.F<32|64>.F16 <Sd|Dd>, Sm
VCVT{y}{cond}.F16.F<32|64> Sd, <Sm|Dm>
```

#### Where:

*y* Specifies which half of the operand register *Sm* or destination register *Sd* is used for the operand or destination:

- If y is B, then the bottom half, bits [15:0], of *Sm* or *Sd* is used.
- If *y* is T, then the top half, bits [31:16], of *Sm* or *Sd* is used.

*cond* Is an optional condition code. See *Conditional execution on page 68*. *<Sd|Dd>* Is the destination register. *<Sm|Dm>* Is the operand register.

### **Operation**

This instruction with the .F16.F<32|64> suffix:

- 1. Converts the half-precision value in the top or bottom half of a single-precision register to single-precision or double-precision value.
- 2. Writes the result to a single-precision or double-precision register.

This instruction with the .F<32|64>.F16 suffix:

- 1. Converts the value in a double-precision or single-precision register to half-precision value.
- 2. Writes the result into the top or bottom half of a single-precision register, preserving the other half of the target register.

# **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-6-1"></span>**3.11.7 VDIV**

Divides floating-point values.

### **Syntax**

```
VDIV{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *<Sd|Dd>* Is the destination register.

*<Sn|Dn>*, *<Sm|Dm>*

Are the operand registers.

![](_page_6_Picture_31.jpeg)

PM0253 Rev 5 157/254

This instruction:

- 1. Divides one floating-point value by another floating-point value.
- 2. Writes the result to the floating-point destination register.

### **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-7-0"></span>**3.11.8 VFMA, VFMS**

Floating-point Fused Multiply Accumulate and Subtract.

#### **Syntax**

```
VFMA{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
VFMS{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
```

#### Where:

```
cond Is an optional condition code. See Conditional execution on page 68.
<Sd|Dd> Is the destination register.
<Sn|Dn>, <Sm|Dm>
```

Are the operand registers.

### **Operation**

The VFMA instruction:

- 1. Multiplies the floating-point values in the operand registers.
- 2. Accumulates the results into the destination register.

The result of the multiply is not rounded before the accumulation.

The VFMS instruction:

- 1. Negates the first operand register.
- 2. Multiplies the floating-point values of the first and second operand registers.
- 3. Adds the products to the destination register.
- 4. Places the results in the destination register.

The result of the multiply is not rounded before the addition.

#### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

# <span id="page-8-0"></span>**3.11.9 VFNMA, VFNMS**

Floating-point Fused Negate Multiply Accumulate and Subtract.

# **Syntax**

```
VFNMA{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
VFNMS{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *<Sd|Dd>* Is the destination register.

*<Sn|Dn>*, *<Sm|Dm>*

Are the operand registers.

### **Operation**

The VFNMA instruction:

- 1. Negates the first floating-point operand register.
- 2. Multiplies the first floating-point operand with second floating-point operand.
- 3. Adds the negation of the floating -point destination register to the product
- 4. Places the result into the destination register.

The result of the multiply is not rounded before the addition.

The VFNMS instruction:

- 1. Multiplies the first floating-point operand with second floating-point operand.
- 2. Adds the negation of the floating-point value in the destination register to the product.
- 3. Places the result in the destination register.

The result of the multiply is not rounded before the addition.

#### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

# <span id="page-8-1"></span>**3.11.10 VLDM**

Floating-point Load Multiple.

#### **Syntax**

```
VLDM{mode}{cond}{.size} Rn{!}, list
```

#### Where:

*mode* Is the addressing mode:

*IA* Increment after. The consecutive addresses start at the address

specified in *Rn*.

*DB* Decrement before. The consecutive addresses end just before

the address specified in *Rn*.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

![](_page_8_Picture_37.jpeg)

PM0253 Rev 5 159/254

| size | Is an optional data size specifier.                                                                                                                                            |
|------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Rn   | Is the base register. The SP can be used.                                                                                                                                      |
| !    | Is the command to the instruction to write a modified value back to Rn. This is                                                                                                |
|      | required if mode == DB, and is optional if mode == IA.                                                                                                                         |
| list | Is the list of extension registers to be loaded, as a list of consecutively<br>numbered doubleword or singleword registers, separated by commas and<br>surrounded by brackets. |

This instruction loads multiple extension registers from consecutive memory locations using an address from an Arm core register as the base address.

#### **Restrictions**

The restrictions are:

- If *size* is present, it must be equal to the size in bits, 32 or 64, of the registers in *list*.
- For the base address, the SP can be used. In the Arm instruction set, if *!* is not specified the PC can be used.
- *list* must contain at least one register. If it contains doubleword registers, it must not contain more than 16 registers.
- If using the Decrement Before addressing mode, the write back flag, *!*, must be appended to the base register specification.

# **Condition flags**

These instructions do not change the flags.

#### **Example**

```
VLDMIA.F64 r1, {d3,d4,d5}
```

# <span id="page-9-0"></span>**3.11.11 VLDR**

Loads a single extension register from memory.

#### **Syntax**

```
VLDR{cond}{.F<32|64>} <sd|Dd>, [Rn{#imm}]
VLDR{cond}{.F<32|64>} <sd|Dd>, label
VLDR{cond}{.F<32|64>} <sd|Dd>, [PC, #imm}]
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *32*, 64 Are the optional data size specifiers. *Dd* Is the destination register for a doubleword load. *Sd* Is the destination register for a singleword load. *Rn* Is the base register. The SP can be used. *imm* Is the + or - immediate offset used to form the address. Permitted address values are multiples of 4 in the range 0 to 1020. *label* Is the label of the literal data item to be loaded.

![](_page_9_Picture_22.jpeg)

This instruction loads a single extension register from memory, using a base address from an Arm core register, with an optional offset.

#### **Restrictions**

There are no restrictions.

#### **Condition flags**

These instructions do not change the flags.

# <span id="page-10-0"></span>**3.11.12 VMLA, VMLS**

Multiplies two floating-point values, and accumulates or subtracts the result.

#### **Syntax**

```
VMLS{cond}.F<32|64> <Sd|Dd>, <Sn|Dn>, <Sm|Dm>
Where:
cond Is an optional condition code. See Conditional execution on page 68.
<Sd|Dd> Is the destination floating-point value.
<Sn|Dn>, <Sm|Dm>
```

Are the operand floating-point values.

VMLA{*cond*}.F<32|64> *<Sd|Dd>*, *<Sn|Dn>*, *<Sm|Dm>*

#### **Operation**

The floating-point Multiply Accumulate instruction:

- 1. Multiplies two floating-point values.
- 2. Adds the results to the destination floating-point value.

The floating-point Multiply Subtract instruction:

- 1. Multiplies two floating-point values.
- 2. Subtracts the products from the destination floating-point value.
- 3. Places the results in the destination register.

# **Restrictions**

There are no restrictions.

# **Condition flags**

These instructions do not change the flags.

![](_page_10_Picture_25.jpeg)

PM0253 Rev 5 161/254

# <span id="page-11-0"></span>**3.11.13 VMOV immediate**

Moves floating-point Immediate.

# **Syntax**

```
VMOV{cond}.F<32|64> <Sd|Dd>, #imm
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>* Is the destination register. *imm* Is a floating-point constant.

# **Operation**

This instruction copies a constant value to a floating-point register.

### **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-11-1"></span>**3.11.14 VMOV register**

Copies the contents of one register to another.

### **Syntax**

```
VMOV{cond}.F<32|64> <Sd|Dd>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Dd* Is the destination register, for a doubleword operation. *Dm* Is the source register, for a doubleword operation. *Sd* Is the destination register, for a singleword operation. *Sm* Is the source register, for a singleword operation.

#### **Operation**

This instruction copies the contents of one floating-point register to another.

# **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

![](_page_11_Picture_29.jpeg)

# <span id="page-12-1"></span>**3.11.15 VMOV scalar to Arm core register**

Transfers one word of a doubleword floating-point register to an Arm core register.

### **Syntax**

```
VMOV{cond} Rt, Dn[x]
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Rt* Is the destination Arm core register. *Dn* Is the 64-bit doubleword register.

*x* Specifies which half of the doubleword register to use:

- If *x* is 0, use lower half of doubleword register
- If *x* is 1, use upper half of doubleword register.

### **Operation**

This instruction transfers one word from the upper or lower half of a doubleword floatingpoint register to an Arm core register.

# **Restrictions**

*Rt* cannot be PC or SP.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-12-0"></span>**3.11.16 VMOV Arm core register to single-precision**

Transfers a single-precision register to and from an Arm core register.

#### **Syntax**

```
VMOV{cond} Sn, Rt
VMOV{cond} Rt, Sn
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sn>* Is the single-precision floating-point register.

*Rt* Is the Arm core register.

### **Operation**

This instruction transfers:

- The contents of a single-precision register to an Arm core register.
- The contents of an Arm core register to a single-precision register.

### **Restrictions**

*Rt* cannot be PC or SP.

#### **Condition flags**

These instructions do not change the flags.

![](_page_12_Picture_34.jpeg)

PM0253 Rev 5 163/254

# <span id="page-13-0"></span>**3.11.17 VMOV two Arm core registers to two single-precision registers**

Transfers two consecutively numbered single-precision registers to and from two Arm core registers.

### **Syntax**

```
VMOV{cond} Sm, Sm1, Rt, Rt2
VMOV{cond} Rt, Rt2, Sm, Sm1
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Sm* Is the first single-precision register.

*Sm1* Is the second single-precision register. This is the next single-precision register

after *<Sm>*.

*Rt* Is the Arm core register that *<Sm>* is transferred to or from. *Rt2* Is the The Arm core register that *<Sm1>* is transferred to or from.

#### **Operation**

This instruction transfers:

- The contents of two consecutively numbered single-precision registers to two Arm core registers.
- The contents of two Arm core registers to a pair of single-precision registers.

### **Restrictions**

The restrictions are:

- The floating-point registers must be contiguous, one after the other.
- The Arm core registers do not have to be contiguous.
- *Rt* cannot be PC or SP.

### **Condition flags**

These instructions do not change the flags.

# **3.11.18 VMOV two Arm core registers and a double-precision register**

Transfers two words from two Arm core registers to a doubleword register, or from a doubleword register to two Arm core registers.

### **Syntax**

```
VMOV{cond} Dm, Rt, Rt2
VMOV{cond} Rt, Rt2, Dm
```

### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*Dm* Is the double-precision register. *Rt, Rt2* Are the two Arm core registers.

This instruction:

- Transfers two words from two Arm core registers to a doubleword register.
- Transfers a doubleword register to two Arm core registers.

### **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-14-0"></span>**3.11.19 VMOV Arm core register to scalar**

Transfers one word to a floating-point register from an Arm core register.

#### **Syntax**

```
VMOV{cond}{.32} Dd[x], Rt
```

### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*32* Is an optional data size specifier.

*Dd[x]* Is the destination, where [x] defines which half of the doubleword is transferred,

as follows:

• If *x* is 0, the lower half is extracted.

• If *x* is 1, the upper half is extracted.

*Rt* Is the source Arm core register.

#### **Operation**

This instruction transfers one word to the upper or lower half of a doubleword floating-point register from an Arm core register.

### **Restrictions**

*Rt* cannot be PC or SP.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-14-1"></span>**3.11.20 VMRS**

Moves to Arm core register from floating-point System register.

### **Syntax**

```
VMRS{cond} Rt, FPSCR
VMRS{cond} APSR_nzcv, FPSCR
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *Rt* Is the destination Arm core register. This register can be R0-R14.

![](_page_14_Picture_34.jpeg)

PM0253 Rev 5 165/254

*APSR\_nzcv* Transfer floating-point flags to the APSR flags.

#### **Operation**

This instruction performs one of the following actions:

- Copies the value of the FPSCR to a general-purpose register.
- Copies the value of the FPSCR flag bits to the APSR N, Z, C, and V flags.

### **Restrictions**

*Rt* cannot be PC or SP.

# **Condition flags**

These instructions optionally change the N, Z, C, and V flags.

# <span id="page-15-0"></span>**3.11.21 VMSR**

Moves to floating-point System register from Arm core register.

#### **Syntax**

```
VMSR{cond} FPSCR, Rt
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *Rt* Is the general-purpose register to be transferred to the FPSCR.

# **Operation**

This instruction moves the value of a general-purpose register to the FPSCR. See *Floatingpoint status control register on page 236* for more information.

### **Restrictions**

*Rt* cannot be PC or SP.

#### **Condition flags**

This instruction updates the FPSCR.

# <span id="page-15-1"></span>**3.11.22 VMUL**

Floating-point Multiply.

#### **Syntax**

```
VMUL{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>* Is the destination floating-point value.

*<Sn|Dn>*, *<Sm|Dm>*

Are the operand floating-point values.

This instruction:

- 1. Multiplies two floating-point values.
- 2. Places the results in the destination register.

### **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-16-0"></span>**3.11.23 VNEG**

Floating-point Negate.

#### **Syntax**

```
VNEG{cond}.F<32|64> <Sd|Dd>, <Sm|Dm>
```

### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>* Is the destination floating-point value. *<Sm|Dm>* Is the operand floating-point value.

### **Operation**

This instruction:

- 1. Negates a floating-point value.
- 2. Places the results in a second floating-point register.

The floating-point instruction inverts the sign bit.

# **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-16-1"></span>**3.11.24 VNMLA, VNMLS, VNMUL**

Floating-point multiply with negation followed by add or subtract.

# **Syntax**

```
VNMLA{cond}.F<32|64> <Sd|Dd>, <Sn|Dn>, <Sm|Dm>
VNMLS{cond}.F<32|64> <Sd|Dd>, <Sn|Dn>, <Sm|Dm>
VNMUL{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*. *<Sd|Dd>* Is the destination floating-point register.

PM0253 Rev 5 167/254

*<Sn|Dn>*, *<Sm|Dm>* Are the operand floating-point registers.

### **Operation**

The VNMLA instruction:

- 1. Multiplies two floating-point register values.
- 2. Adds the negation of the floating-point value in the destination register to the negation of the product.
- 3. Writes the result back to the destination register.

The VNMLS instruction:

- 1. Multiplies two floating-point register values.
- 2. Adds the negation of the floating-point value in the destination register to the product.
- 3. Writes the result back to the destination register.

The VNMUL instruction:

- 1. Multiplies together two floating-point register values.
- 2. Writes the negation of the result to the destination register.

### **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-17-0"></span>**3.11.25 VPOP**

Floating-point extension register Pop.

### **Syntax**

```
VPOP{cond}{.size} list
```

### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*size* Is an optional data size specifier. If present, it must be equal to the size in bits,

32 or 64, of the registers in *list*.

*list* Is a list of extension registers to be loaded, as a list of consecutively numbered

doubleword or singleword registers, separated by commas and

surrounded by brackets.

#### **Operation**

This instruction loads multiple consecutive extension registers from the stack.

#### **Restrictions**

The list must contain at least one register, and not more than sixteen registers.

### **Condition flags**

These instructions do not change the flags.

![](_page_17_Picture_37.jpeg)

# <span id="page-18-0"></span>**3.11.26 VPUSH**

Floating-point extension register Push.

### **Syntax**

VPUSH{*cond*}{.*size*} *list*

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*size* Is an optional data size specifier. If present, it must be equal to the size in bits,

32 or 64, of the registers in *list*.

*list* Is a list of the extension registers to be stored, as a list of consecutively

numbered doubleword or singleword registers, separated by commas and

surrounded by brackets.

#### **Operation**

This instruction stores multiple consecutive extension registers to the stack.

#### **Restrictions**

*list* must contain at least one register, and not more than sixteen.

#### **Condition flags**

These instructions do not change the flags.

# <span id="page-18-1"></span>**3.11.27 VSQRT**

Floating-point Square Root.

#### **Syntax**

```
VSQRT{cond}.F<32|64> <Sd|Dd>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>* Is the destination floating-point value. *<Sm|Dm>* Is the operand floating-point value.

#### **Operation**

This instruction:

- Calculates the square root of the value in a floating-point register.
- Writes the result to another floating-point register.

#### **Restrictions**

There are no restrictions.

# **Condition flags**

These instructions do not change the flags.

![](_page_18_Picture_34.jpeg)

PM0253 Rev 5 169/254

# <span id="page-19-0"></span>**3.11.28 VSTM**

Floating-point Store Multiple.

### **Syntax**

```
VSTM{mode}{cond}{.size} Rn{!}, list
```

#### Where:

*mode* Is the addressing mode:

- IA *Increment After*. The consecutive addresses start at the address specified in *Rn*. This is the default and can be omitted.
- DB *Decrement Before*. The consecutive addresses end just before the address specified in *Rn*.

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*size* Is an optional data size specifier. If present, it must be equal to the size in bits,

32 or 64, of the registers in *list*.

*Rn* Is the base register. The SP can be used.

*!* Is the function that causes the instruction to write a modified value back to *Rn*.

Required if mode == DB.

*list* Is a list of the extension registers to be stored, as a list of consecutively

numbered doubleword or singleword registers, separated by commas and

surrounded by brackets.

### **Operation**

This instruction stores multiple extension registers to consecutive memory locations using a base address from an Arm core register.

#### **Restrictions**

The restrictions are:

- *list* must contain at least one register. If it contains doubleword registers it must not contain more than 16 registers.
- Use of the PC as *Rn* is deprecated.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-19-1"></span>**3.11.29 VSTR**

Floating-point Store.

### **Syntax**

```
VSTR{cond}{.32} Sd, [Rn{, #imm}]
VSTR{cond}{.64} Dd, [Rn{, #imm}]
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*32*, *64* Are the optional data size specifiers.

*Sd* Is the source register for a singleword store. *Dd* Is the source register for a doubleword store.

![](_page_19_Picture_37.jpeg)

*Rn* Is the base register. The SP can be used.

*imm* Is the + or - immediate offset used to form the address. Values are multiples of

4 in the range 0-1020. *imm* can be omitted, meaning an offset of +0.

### **Operation**

This instruction stores a single extension register to memory, using an address from an Arm core register, with an optional offset, defined in *imm*:

#### **Restrictions**

The use of PC for *Rn* is deprecated.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-20-0"></span>**3.11.30 VSUB**

Floating-point Subtract.

### **Syntax**

```
VSUB{cond}.F<32|64> {<Sd|Dd>,} <Sn|Dn>, <Sm|Dm>
```

#### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>* Is the destination floating-point value.

*<Sn|Dn>*, *<Sm|Dm>*

Are the operand floating-point values.

#### **Operation**

This instruction:

- 1. Subtracts one floating-point value from another floating-point value.
- 2. Places the results in the destination floating-point register.

# **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

![](_page_20_Picture_28.jpeg)

PM0253 Rev 5 171/254

# <span id="page-21-1"></span>**3.11.31 VSEL**

Provides an alternative to a pair of conditional VMOV instructions.

# **Encoding**

```
VSEL{cond}.F<32|64> <Sd|Dd>, <Sn|Dn>, <Sm|Dm>
```

#### Where:

c*ond* Is an optional condition code. See *Conditional execution on page 68*. VSEL has

a subset of the condition codes. The condition codes for VSEL are limited to GE, GT, EQ and VS, with the effect that LT, LE, NE and VC is achievable by exchanging

the source operands.

*<Sd|Dd>* Is the destination single-precision or double-precision floating-point value.

*<Sn|Dn>*, *<Sm|Dm>*

Are the operand single-precision or double-precision floating-point values.

#### **Operation**

Depending on the result of the condition code, this instruction moves either:

- *<Sn|Dn>* source register to the destination register.
- *<Sm|Dm>* source register to the destination register.

### **Restrictions**

The VSEL instruction must not occur inside an IT block.

## **Condition flags**

These instructions do not change the flags.

# <span id="page-21-0"></span>**3.11.32 VMAXNM, VMINNM**

Return the minimum or the maximum of two floating-point numbers with NaN handling as specified by IEEE754-2008.

#### **Encoding**

```
VMAXNM.F<32|64> <Sd|Dd>, <Sn|Dn>, <Sm|Dm>
VMINNM.F<32|64> <Sd|Dd>, <Sn|Dn>, <Sm|Dm>
```

#### Where:

*<Sd|Dd>* Is the destination single-precision or double-precision floating-point value. *<Sn|Dn>*, *<Sm|Dm>*

Are the operand single-precision or double-precision floating-point values.

#### **Operation**

The VMAXNM instruction compares two source registers, and moves the largest to the destination register.

The VMINNM instruction compares two source registers, and moves the lowest to the destination register.

### **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-22-0"></span>**3.11.33 VCVTA, VCVTN, VCVTP, VCVTM**

Floating-point to integer conversion with directed rounding.

### **Syntax**

```
VCVT<rmode>.S32.F<32|64> <Sd>, <Sm|Dm>
VCVT<rmode>.U32.F<32|64> <Sd>, <Sm|Dm>
```

#### Where:

*<Sd|Dd>* Is the destination single-precision or double-precision floating-point value. *<Sn|Dn>*, *<Sm|Dm>*

Are the operand single-precision or double-precision floating-point values.

*<rmode>* Is one of:

A Round to nearest ties away. M Round to nearest even. N Round towards plus infinity. P Round towards minus infinity.

### **Operation**

These instructions:

- 1. Read the source register.
- 2. Convert to integer with directed rounding.
- 3. Write to the destination register.

# **Restrictions**

There are no restrictions.

### **Condition flags**

These instructions do not change the flags.

# <span id="page-22-1"></span>**3.11.34 VRINTR, VRINTX**

Round a floating-point value to an integer in floating-point format.

### **Encoding**

```
VRINT{R,X}{cond}.F<32|64> <Sd|Dd>, <Sm|Dm>
```

### Where:

*cond* Is an optional condition code. See *Conditional execution on page 68*.

*<Sd|Dd>* Is the destination floating-point value. *<Sm|Dm>* Are the operand floating-point values.

![](_page_22_Picture_31.jpeg)

PM0253 Rev 5 173/254

These instructions:

- 1. Read the source register.
- 2. Round to the nearest integer value in floating-point format using the rounding mode specified by the FPSCR.
- 3. Write the result to the destination register.
- 4. For the VRINTZX instruction only. Generate a floating-point exception if the result is not exact.

### **Restrictions**

There are no restrictions.

# **Condition flags**

These instructions do not change the flags.

# <span id="page-23-0"></span>**3.11.35 VRINTA, VRINTN, VRINTP, VRINTM, VRINTZ**

Round a floating-point value to an integer in floating-point format using directed rounding.

### **Encoding**

```
VRINT<rmode>.F<32|64> <Sd|Dd>, <Sm|Dm>
```

# Where:

*<Sd|Dd>* Is the destination single-precision or double-precision floating-point value. *<Sn|Dn>*, *<Sm|Dm>*

Are the operand single-precision or double-precision floating-point values.

### *<rmode>* Is one of:

- A Round to nearest ties away.
- M Round to Nearest Even.
- N Round towards Plus Infinity.
- P Round towards Minus Infinity.
- Z Round towards Zero.

### **Operation**

These instructions:

- 1. Read the source register.
- 2. Round to the nearest integer value with a directed rounding mode specified by the instruction.
- 3. Write the result to the destination register.

#### **Restrictions**

These instructions cannot be conditional. These instructions cannot generate an inexact exception even if the result is not exact.

![](_page_23_Picture_33.jpeg)